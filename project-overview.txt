# Project Overview: Photo Filter
-e 
Generated on: Thu Dec 12 11:45:46 EST 2024

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── DEVELOPMENT_PLAN.md
├── ISSUES.md
├── README.md
├── backend
│   ├── .DS_Store
│   ├── .babelrc
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── index.js
│   │   │   ├── people-controller.js
│   │   │   └── photos-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   ├── people-legacy-controller.js
│   │   └── photo-controller.js
│   ├── data
│   │   ├── albums
│   │   │   ├── .DS_Store
│   │   │   └── 6956E064-5A0E-4451-8A75-FC6724FED866
│   │   │       └── photos.json
│   │   └── albums.json
│   ├── jest.config.js
│   ├── models
│   │   └── photoModel.js
│   ├── osxphotos_crash.log
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── test_albums.json
│   ├── tests
│   │   └── controllers
│   │       └── api
│   │           ├── albums-controller.test.js
│   │           └── photos-controller.test.js
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── export-images.js
│   │   ├── get-photos-library-last-modified.js
│   │   └── run-python-script.js
│   ├── views
│   │   ├── albums.hbs
│   │   ├── index.hbs
│   │   ├── layouts
│   │   │   └── main.hbs
│   │   ├── person.hbs
│   │   └── persons.hbs
│   └── yarn.lock
├── frontend
│   └── photo-filter-frontend
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── README.md
│       ├── app
│       │   ├── adapters
│       │   │   ├── application.js
│       │   │   └── photo.js
│       │   ├── app.js
│       │   ├── components
│       │   │   ├── .gitkeep
│       │   │   ├── photo-grid.hbs
│       │   │   └── photo-grid.js
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   └── albums
│       │   │       ├── album
│       │   │       │   └── persons
│       │   │       │       └── person.js
│       │   │       └── album.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── eq.js
│       │   │   ├── get-nested-property.js
│       │   │   └── replace.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   ├── persons
│       │   │   │   │   │   └── person.js
│       │   │   │   │   └── persons.js
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   └── index.js
│       │   ├── services
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.scss
│       │   └── templates
│       │       ├── albums
│       │       │   ├── album
│       │       │   │   ├── persons
│       │       │   │   │   └── person.hbs
│       │       │   │   └── persons.hbs
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       └── application.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package-lock.json
│       ├── package.json
│       ├── public
│       │   └── robots.txt
│       ├── testem.js
│       ├── tests
│       │   ├── acceptance
│       │   │   └── albums-test.js
│       │   ├── helpers
│       │   │   └── index.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       └── yarn.lock
├── generate-overview.sh
├── osxphotos_crash.log
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
└── top_photo_uuids.txt

56 directories, 123 files
```

---

## Root-Level Files

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

## Update: Implementing Album/Person Sub-Routes

**Date:** December 7, 2024

### Decision

- **Implement Person-Specific Sub-Routes Within an Album**:  
  Add routes that focus on individuals recognized in the album’s photos. When viewing an album, the user can navigate to a sub-route listing all people who appear in the album. From there, they can select a person to view only the photos containing that individual, with the same sorting interface currently available at the album level.

### Rationale

- **Inclusivity of Individuals**:  
  Similar to ensuring coverage of all guests at a wedding, this feature helps ensure event photography doesn’t miss key participants. By focusing on each person, the user can quickly find the best photos of them.
- **Consistent UX**:  
  The person-level photo view should mirror existing album-level sorting and navigation, providing a familiar interface and workflow for the user.

- **Efficiency**:  
  With large albums, filtering by individuals and sorting helps the user quickly find representative images of each participant.

### Implementation Steps

1. **Extract People Data from `photos.json`**:
   - Update or confirm the `photos.json` generation includes a `persons` array (or similar) indicating which people appear in each photo.
2. **Backend Routes for People**:

   - Create a backend endpoint to list all unique people found in a given album’s photos (e.g. `GET /api/albums/:albumUUID/persons`).
   - Create a backend endpoint to fetch photos filtered by a specific person within that album (e.g. `GET /api/albums/:albumUUID/person/:personName`).

3. **Frontend Nested Routes**:

   - Add Ember.js routes to display:
     - A list of people in the album at `albums/album/persons`.
     - A person-specific route at `albums/album/persons/person/:person_name`.
   - These routes will accept `sort` and `order` query parameters to replicate the sorting behavior seen at the album level.

4. **UI Enhancements**:

   - On the album page, add a link to the people list sub-route.
   - The people list page shows all recognized persons as clickable links.
   - The person page shows filtered photos of that individual with the same sorting UI as the album page.

5. **Testing and Validation**:

   - Write tests to ensure that the new endpoints and routes return the expected data.
   - Verify the user can sort photos by various attributes when viewing an individual’s photos.

6. **Documentation**:
   - Update `DEVELOPMENT_PLAN.md` (this file) to reflect the addition of album/person routes.
   - Once implemented, update `README.md`, `ISSUES.md`, and other documentation files as needed.

### Potential Challenges

- **Data Availability**:  
  Ensuring that the people information is correctly included in `photos.json`.

- **Edge Cases**:  
  Handling albums with no recognized people or handling photos where a person’s name may be duplicated with slight variations.

- **Performance**:  
  Filtering and sorting large albums for many individuals could be intensive. Consider caching or efficient indexing if performance becomes an issue.

---

## Update: Implementing Nested Routes and UI Enhancements

**Date:** November 12, 2024

### Decision

- **Implement Nested Routes with `{{outlet}}` in `albums.hbs`**: To properly render child routes within the parent `albums` route.
- **Create Left Navigation Column**: Mimic the UI of the Apple Photos app by adding a left navigation column for album selection.
- **Display Full Photo Library on Index Route**: Show all photos when no specific album is selected.
- **Implement Expanded Sorting and Selection Features**: Allow sorting by various attributes and enable photo selection that persists across sorting changes.

### Rationale

- **User Experience**: Enhances navigation and usability by providing a familiar interface.
- **Functionality**: Supports the requirement to sort photos by multiple attributes and manage selections effectively.
- **Scalability**: Sets a foundation for future features like exporting and advanced photo management.

### Implementation Steps

1. **Add `{{outlet}}` to `albums.hbs`**:

   - Update `app/templates/albums.hbs` to include `{{outlet}}` for rendering child routes.

2. **Create Left Navigation Layout**:

   - Structure `albums.hbs` to have a left navigation column (`albums-list`) and a content area (`album-content`).

3. **Display Full Photo Library When No Album is Selected**:

   - Create `app/routes/albums/index.js` and `app/templates/albums/index.hbs` to fetch and display all photos.

4. **Implement Expanded Sorting Functionality**:

   - Update `app/controllers/albums/album.js` to handle additional sorting attributes and orders.

5. **Implement Photo Selection Mechanism**:

   - Create a selection service (`app/services/selection.js`) to manage selection state.
   - Update `albums/album.hbs` and `albums/album.js` to handle photo selection.

6. **Implement Export Functionality**:

   - Add an endpoint in the backend (`backend/routes/api/photos.js`) to handle exporting selected photos.
   - Update the frontend to send selected photo IDs to the backend for export.

7. **Styling and Responsiveness**:

   - Add CSS styles to `app/styles/app.css` to make the application visually appealing and responsive.

8. **Testing**:

   - Write tests for new features, especially the selection and export functionalities.

9. **Documentation**:

   - Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, and `project-guidelines.md` to reflect changes.

### Potential Challenges

- **Persistent Selection State**: Ensuring the selection persists across sorting and navigation changes.
- **Performance**: Managing performance with large photo libraries, especially during selection and export.
- **Backend Integration**: Properly handling the export functionality without affecting the Photos library integrity.

---

## Previous Updates

### Update: Implementing Cache Invalidation Based on Timestamps

- **Date:** November 1, 2024
- **Decision:** Implement cache invalidation to ensure data freshness.
- **Implementation:** Created utility functions to check last modified times and regenerate cached data as needed.

### Update: Integration of JSON:API Serializer

- **Date:** October 30, 2024
- **Decision:** Use `jsonapi-serializer` package to format API responses according to the JSON:API specification.
- **Implementation:** Refactored backend controllers and updated dependencies.

---

## Project Goal

Develop a web application that interfaces with the user's macOS Photos library to enable interactive exploration, selection, and exporting of photos based on Apple's aesthetic scores and other metadata. The application aims to provide an engaging user experience by allowing users to select photos through intuitive interactions and perform actions like exporting selections.

## Current State

- **Frontend**: Ember.js application with nested routes and a left navigation layout.
- **Backend**: Express.js server with API endpoints serving data in JSON:API format.
- **Data Handling**: Uses `osxphotos` to extract data from the Photos library.
- **Photo Selection**: Implemented using an Ember service to manage selection state.
- **Export Functionality**: Backend API endpoint to handle exporting selected photos.
- **Styling**: Basic CSS styling for responsive design.
- **Documentation**: Project files (`README.md`, `ISSUES.md`, `DEVELOPMENT_PLAN.md`, `project-guidelines.md`) are updated.

## Next Steps

1. **Enhance Photo Selection Features**:

   - Implement the ability to expand the selection to include photos taken immediately before and after the selected photos.
   - Ensure selection persistence across different sorting and navigation.

2. **Complete Export Functionality**:

   - Implement the backend logic to actually export the selected photos to a designated directory.
   - Provide user feedback on the export process.

3. **UI/UX Improvements**:

   - Refine the user interface for better intuitiveness.
   - Add visual indicators for selected photos and selection expansion.

4. **Performance Optimization**:

   - Implement lazy loading for images.
   - Optimize data fetching and rendering for large photo libraries.

5. **Testing and Quality Assurance**:

   - Write comprehensive tests for new features.
   - Perform user testing to gather feedback.

6. **Documentation and Cleanup**:

   - Update documentation to reflect new features and changes.
   - Refactor code for maintainability.

---

**Note:** All changes should be committed to the repository with clear and descriptive commit messages to maintain project history and facilitate collaboration.
```

### **./ISSUES.md**
```
# Issues and Resolutions

This file serves as a log of open issues, debugging steps taken, and resolutions. It's intended to facilitate collaborative problem-solving and prevent redundant efforts.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name] on Nov 12, 2024

**Status:** **Resolved**

### Description

The `albums/album` route was not rendering its template within the `albums` route as expected. Clicking on an album link did not display the album's photos.

### Error Observed

- The child route's template was not rendering within the parent route's template.

### Resolution

- **Root Cause:** The `albums.hbs` template lacked an `{{outlet}}`, which is necessary for rendering nested routes in Ember.js.
- **Solution:** Added an `{{outlet}}` to `app/templates/albums.hbs`.
- **Commit:** Added outlet to `albums.hbs` to render album content and updated styles.

### Action Items

- Updated `albums.hbs` to include `{{outlet}}`.
- Restructured the template to include a left navigation column and content area.
- Restarted the Ember server to apply changes.
- Verified that the child route's content renders correctly.

---

## Issue 14: 404 Error When Fetching Album Data in Ember.js Application

**Opened By:** [Your Name] on Nov 10, 2024

**Status:** **Resolved**

### Description

The Ember.js application encountered a 404 Not Found error when attempting to fetch album data from the endpoint `/api/albums/:albumUUID`.

### Resolution

- **Root Cause:** The backend API did not have an endpoint to handle GET requests to `/api/albums/:albumUUID`.
- **Solution:** Implemented the missing endpoint on the backend to handle GET requests to `/api/albums/:albumUUID`.
- **Commit:** Implemented backend endpoint for fetching single album data.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **In Progress**

### Description

We need to implement the ability for users to select multiple photos by clicking and dragging the mouse over them. Selections should persist as users switch between different sorting attributes.

### Action Items

- **Create Selection Service:** Implemented `app/services/selection.js` to manage selection state.
- **Update Photo Grid:** Modified `albums/album.hbs` to handle photo selection and display selected state.
- **Implement Selection Persistence:** Ensure that selections persist across sorting and navigation.

### Next Steps

- **Expand Selection Feature:** Implement functionality to include photos taken immediately before and after selected photos.
- **Testing:** Write tests to ensure selection works as expected.

---

## Issue 9: Adding Actions for Selected Photos

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **In Progress**

### Description

Allow users to perform actions on the selected photos, such as exporting them to a directory.

### Action Items

- **Backend API Endpoint:** Created `/api/photos/export` to handle exporting photos.
- **Frontend Integration:** Updated `albums/album.js` to send selected photo IDs to the backend.
- **User Feedback:** Added alert messages to inform users about the export status.

### Next Steps

- **Implement Actual Export Logic:** Complete the backend function to export photos.
- **Enhance User Feedback:** Provide better UI notifications and progress indicators.

---

## Issue 16: Filename Collisions When Reconstructing Directory Structure

**Opened By:** [Your Name] on Dec 11, 2024

**Status:** **Open** (Reopened December 12, 2024)

### Description

When exporting images from Apple Photos to a flat directory structure, multiple images can share the same `original_name` (e.g., `DSCF1191.jpg`). This leads to filename collisions and confusion when we lose the original directory context. The initial solution was to prepend the date/time to the filename during post-export renaming steps. However, we must verify that this approach works completely and consistently before marking the issue as resolved.

### Current Approach (Under Testing)

- **Date/Time Prefix**: Prepending the date/time (`YYYYMMDD-HHMMSS`) to the filename to ensure uniqueness and chronological sorting by filename.
- **Collision Handling**: If two photos have the exact same timestamp and original name, append a counter (`-1`, `-2`, etc.) until a unique name is found.
- **Integration with `osxphotos`**: Instead of renaming after export, we've adjusted our approach to use `osxphotos` filename templates so that the exported files have the correct names right after export, ideally removing the need for a separate rename step. We need to confirm that our entire pipeline, including all references in our app, uses the correct filenames and that this approach truly resolves collisions.

### Action Items

- [ ] Verify that `osxphotos` filename templates work as intended and no collisions occur directly after export.
- [ ] Confirm that the rest of the application references the correct filenames consistently.
- [ ] Apply and test the fix in a real environment to confirm no collisions and that sorting by filename works as desired.

### Outcome

This issue remains open until:

1. The solution is applied by the real person managing the system.
2. Verification in a real environment confirms that the fix works as intended.

No premature marking of "Resolved" is allowed until these conditions are met.

---

# End of Issues Log
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application.

## Project Structure

- `backend/`: Contains the Express.js backend application.
- `frontend/`: Contains the Ember.js frontend application.
- `generate-overview.sh`: Script to generate the project overview.
- `DEVELOPMENT_PLAN.md`: Development plan and objectives.
- `ISSUES.md`: Log of issues and resolutions.
- `project-guidelines.md`: Guidelines for collaboration and development.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter
   ```

2. **Set Up the Backend**:

   ```bash
   cd backend
   npm install
   npm run setup
   npm run dev
   ```

3. **Set Up the Frontend**:

   Open a new terminal window:

   ```bash
   cd frontend/photo-filter-frontend
   npm install
   npm run start
   ```

4. **Access the Application**:

   - Visit [http://localhost:4200](http://localhost:4200) to access the Ember.js frontend.

## Features

- **Album Navigation**: Browse albums using a left navigation column.
- **Photo Display**: View photos within selected albums.
- **Expanded Sorting**: Sort photos by various attributes, including aesthetic scores.
- **Photo Selection**: Select photos by clicking; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Cache Invalidation

- **Automatic Updates**: The backend checks for changes in the Photos library and updates cached data accordingly.
- **Data Freshness**: Ensures users see the most recent albums and photos.
- **Performance Optimization**: Avoids unnecessary data regeneration.

## Development Notes

- **Nested Routes**: Utilizes Ember.js nested routes with `{{outlet}}` to render child templates.
- **Ember Services**: Uses a selection service to manage photo selection state.
- **JSON:API Compliance**: Backend APIs conform to the JSON:API specification for seamless integration with Ember Data.
- **Styling**: Basic responsive design implemented with CSS.

## Contributing

- **Git Commit Messages**: Include clear and descriptive commit messages with every change.
- **Issue Tracking**: Use `ISSUES.md` to log problems and track resolutions.
- **Collaboration Guidelines**: Refer to `project-guidelines.md` for best practices.

## Testing

- **Backend Tests**: Use Jest for testing backend code.
- **Frontend Tests**: Use Ember CLI's testing tools.

## License

This project is licensed under the MIT License.
```

### **./project-guidelines.md**
```
Project Guidelines

Table of Contents

- Project Philosophy
- Keeping Up with Dependencies
- Data Formats
- Data Synchronization and Caching
- Ensuring Complete Project Overviews
- Coding Standards
- Naming Conventions
- Directory Structure
- Documentation Practices
- Privacy and Data Handling
- Project State and Continuity
- Issue Tracking and Debugging
- Collaboration Guidelines
- Environment and Dependency Management
- Error Handling and Logging
- Security Best Practices
- Testing
- Deployment and Operations
- Performance Optimization

---

## Project Philosophy

- User-Centric Design, Interactivity, Clarity, Modularity, Consistency.
- Ember.js Conventions: Follow Ember.js patterns.
- Privacy, Security, Performance, Scalability.
- Embrace Iterative Understanding: Treat solutions as provisional and open to revision.

## Keeping Up with Dependencies

- Stay informed of the latest versions and updates.
- Test thoroughly after upgrading dependencies.
- Document changes and version notes.

## Data Formats

- Use JSON:API for backend/frontend integration.
- Utilize `jsonapi-serializer` on the backend.

## Data Synchronization and Caching

- Implement cache invalidation using timestamps.
- Balance data freshness with performance.

## Ensuring Complete Project Overviews

- Include all relevant files in generated overviews.
- Update `generate-overview.sh` as the project evolves.
- Regularly review project-overview.txt for accuracy.

## Coding Standards

- Consistent indentation (2 spaces).
- camelCase for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- Avoid globals; use modules.
- Follow Ember.js coding conventions where applicable.

## Naming Conventions

- Dasherized filenames (e.g., `photo-controller.js`).
- Descriptive and concise filenames.

## Directory Structure

- `backend/`: Express.js server and APIs
- `frontend/`: Ember.js app
- `data/`, `exports/`, `scripts/`, `utils/`, `tests/`
- Keep structure organized and consistent.

## Documentation Practices

- Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`.
- Use inline code comments and JSDoc.
- Maintain a changelog and consider `ARCHITECTURE.md` for big-picture decisions.
- Include “Questions to Consider” to highlight uncertainties.

## Privacy and Data Handling

- Do not store personal data in git.
- Be transparent about data processing.

## Project State and Continuity

- Self-contained documentation.
- Reflect current state, pending tasks, and future plans within the project files.

## Issue Tracking and Debugging

- Log issues in `ISSUES.md`.
- Document steps taken and current status.
- **Do Not Mark Issues as Resolved Until Verified**:  
  **No issue should be marked as "Resolved" until the fix is actually applied by the real person managing the system, and tested to confirm it works in reality.**
- Use "Uncertain" tags if needed to highlight unresolved aspects.
- Treat resolutions as provisional truths.

## Collaboration Guidelines

- Communicate clearly and concisely.
- Provide full file replacements for verifiable changes.
- Keep project composed of smaller files for easy copy-paste integration.
- Include clear commit messages.

## Environment and Dependency Management

- Use `.nvmrc` for Node.js versions.
- Keep dependencies updated and tested.
- Store config in environment variables.
- Adhere to JSON:API specs to ensure frontend-backend compatibility.

## Error Handling and Logging

- Implement robust error handling in async code.
- Provide meaningful error messages.
- Use logging for debugging and monitoring.

## Security Best Practices

- No sensitive info in version control.
- Validate/sanitize user inputs.
- Use environment variables for credentials.

## Testing

- Comprehensive test coverage: unit, integration, acceptance.
- Use Jest (backend) and Ember CLI testing tools (frontend).
- Mock external dependencies.
- Write tests alongside code changes.
- Keep tests reliable and maintainable.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configs.
- Monitor performance and errors in production.

## Performance Optimization

- Optimize large dataset handling.
- Use caching and lazy loading.
- Profile resource usage.

---
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/test_albums.json**
```
{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle 🎞️ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour — People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie ◍ Jamie": 4976, "Dominic ◍ Jamie": 4415, "Rosa Menkman ◍ Jamie Burkart": 2821, "Transfer ◍ Jamie Burkart": 2821, "Sondy ◍ Jamie": 2542, "Chad ◍ Jamie": 1830, "Lera Tarasenko ◍ Jamie Burkart": 1636, "Mir ◍ 196 Artists Residency": 1156, "Carper ◍ Burkart": 717, "Lydia ◍ Jamie": 380, "Jessi ◍ Mike ◍ Jamie": 347, "Jack ◍ Jamie": 332, "Lera Show ◍ Jamie Burkart": 310, "Patrick Weaver ◍ Jamie Burkart": 162, "Hayley ◍ Jamie": 149, "Claudette ◍ Jamie": 143, "Greta ◍ Shan ◍ Jamie": 137, "Zhen Li ◍ Jamie Burkart": 83, "Bobby ◍ Madeleine ◍ Jamie": 60, "Abby ◍ Jamie": 57, "Isabel Santos ◍ Jamie Burkart": 50, "Laura Mattingly ◍ Jamie Burkart": 45, "Thor ◍ Jamie": 35, "Stewart ◍ Jamie": 29, "Jessi ◍ Jamie Fashion Concepts &;-)": 26, "Gabi ◍ Michael ◍ Jamie": 17, "Melody ◍ Jamie": 13, "Michael ◍ Jamie": 9, "Em Gift ◍ Jamie Burkart": 1, "Bridget ◍ Jamie": 0}}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
```

### **./backend/utils/run-python-script.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
```

### **./backend/utils/exec-command.js**
```
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/utils/export-images.js**
```
// backend/utils/export-images.js

import fs from "fs-extra";
import path from "path";
import { execCommand } from "./exec-command.js";

/**
 * Export images using osxphotos for a given album.
 * @param {string} osxphotosPath - Path to the osxphotos executable in the virtualenv.
 * @param {string} albumUUID - The UUID of the album to export.
 * @param {string} imagesDir - The directory to which images will be exported.
 * @param {string} photosPath - The path to the photos.json file.
 */
export async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use a date/time prefix and original_name directly via osxphotos template:
  // {created.strftime,%Y%m%d-%H%M%S}-{original_name}
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{created.strftime,%Y%m%d-%H%M%S}-{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

/**
 * Safely get a nested property from an object.
 * @param {object} obj - The object to retrieve the property from.
 * @param {string} propertyPath - The dot-separated path (e.g. "score.overall").
 * @returns {*} - The property value or null if not found.
 */
export function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/models/photoModel.js**
```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

### **./backend/package-lock.json**
```json
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-backend",
      "version": "1.0.0",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "cors": "^2.8.5",
        "express": "^4.21.1",
        "fs-extra": "^11.2.0",
        "jsonapi-serializer": "^3.6.7"
      },
      "devDependencies": {
        "concurrently": "^9.0.1",
        "jest": "^29.7.0",
...
```

### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/setup.js**
```
// ./scripts/setup.js

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

(async () => {
  try {
    const venvDir = path.join(process.cwd(), "venv");
    const venvPython = path.join(venvDir, "bin", "python3");
    const venvPip = path.join(venvDir, "bin", "pip");

    // Use Python 3.11 explicitly
    const pythonExecutable = "python3.11";

    // Check if virtual environment exists
    const venvExists = await fs.pathExists(venvPython);

    if (!venvExists) {
      console.log(
        `Creating Python virtual environment with ${pythonExecutable}...`
      );
      await execAsync(`${pythonExecutable} -m venv venv`);
      console.log("Virtual environment created.");
    } else {
      console.log("Virtual environment already exists, ready to collaborate.");
    }

    // Install or upgrade osxphotos
    console.log(
      "Inviting osxphotos to join the project by installing or upgrading it..."
    );
    await execAsync(`"${venvPip}" install --upgrade osxphotos`);
    console.log("osxphotos is now part of the team.");

    console.log("Setup completed successfully, all components are in place.");
  } catch (error) {
    console.error("Setup encountered an issue:", error);
    process.exit(1);
  }
})();
```

### **./backend/controllers/api-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );

      // After exporting, rename files to prepend the photo's capture date
      await renameExportedImages(imagesDir, photosPath);
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Rename exported images with date-based filenames
async function renameExportedImages(imagesDir, photosPath) {
  const photosData = await fs.readJson(photosPath);

  for (const photo of photosData) {
    const originalName = path.parse(photo.original_filename).name; // e.g., DSCF1191
    const photoDate = new Date(photo.date); // Parse the photo’s date field
    const formattedDate = formatPhotoDate(photoDate); // YYYYMMDD-HHMMSS
    const oldPath = path.join(imagesDir, `${originalName}.jpg`);

    if (await fs.pathExists(oldPath)) {
      let newFilename = `${formattedDate}-${originalName}.jpg`;
      let finalPath = path.join(imagesDir, newFilename);

      // Check for collisions
      let counter = 1;
      while (await fs.pathExists(finalPath)) {
        newFilename = `${formattedDate}-${originalName}-${counter}.jpg`;
        finalPath = path.join(imagesDir, newFilename);
        counter++;
      }

      await fs.rename(oldPath, finalPath);
      console.log(`Renamed ${originalName}.jpg to ${newFilename}`);
    } else {
      console.warn(`File not found for rename: ${oldPath}`);
    }
  }
}

// Format the photo date as YYYYMMDD-HHMMSS
function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/people-legacy-controller.js**
```
// backend/controllers/people-legacy-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Helper to get nested property
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

// Show all people in an album
export const getPeopleInAlbumLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Gather all distinct people
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    const people = Array.from(allPersons).sort();

    // Render persons.hbs view
    res.render("persons", { albumUUID, people });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Show photos of a single person in the album
export const getPhotosByPersonLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by person
    const filteredPhotos = photosData.filter((photo) => {
      return Array.isArray(photo.persons) && photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      // No photos of this person
      return res.render("person", {
        albumUUID,
        personName,
        photos: [],
        scoreAttributes: [],
        sortAttribute,
        sortOrder,
      });
    }

    // Add original_name property
    filteredPhotos.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from the first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort photos based on the requested attribute
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Render person.hbs view
    res.render("person", {
      albumUUID,
      personName,
      photos: filteredPhotos,
      scoreAttributes,
      sortAttribute,
      sortOrder,
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
```

### **./backend/controllers/api/albums-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Change 'albums' to 'album' and set pluralizeType to false
const AlbumSerializer = new Serializer("album", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false, // Prevent automatic pluralization
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Serialize data
    const jsonApiData = AlbumSerializer.serialize(albumsData);

    // Send JSON response
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Function to get a single album by UUID
export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;

    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Find the album with the matching UUID
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    // Serialize data
    const jsonApiData = AlbumSerializer.serialize(album);

    // Send JSON response
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/index.js**
```
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/people-controller.js**
```
// backend/controllers/api/people-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// We'll reuse the PhotoSerializer from photos-controller or create a new one here.
const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
    "persons",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

// Helper function to safely get nested property
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

// List all people in an album
export const getPeopleInAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res
        .status(404)
        .json({
          errors: [{ detail: "Album not found or no photos available" }],
        });
    }

    const photosData = await fs.readJson(photosPath);

    // Extract all persons from all photos
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    // Return the list of people as a simple JSON structure
    // Not JSON:API, just a simple array for now (we could also do JSON:API if desired)
    res.json({ data: Array.from(allPersons) });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Get photos of a specific person in the album
export const getPhotosByPerson = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall"; // Default
    const sortOrder = req.query.order || "desc"; // Default

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res
        .status(404)
        .json({
          errors: [{ detail: "Album not found or no photos available" }],
        });
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by personName
    const filteredPhotos = photosData.filter((photo) => {
      if (!Array.isArray(photo.persons)) return false;
      return photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      return res.json({
        data: [],
        meta: {
          albumUUID,
          personName,
          sortAttribute,
          sortOrder,
          scoreAttributes: [],
        },
      });
    }

    // Add originalName property
    filteredPhotos.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort the photos
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    filteredPhotos.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(filteredPhotos);

    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        personName,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/photos-controller.js
import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";
import {
  runOsxphotosExportImages,
  getNestedProperty,
} from "../../utils/export-images.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "exportedFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // If photos.json doesn't exist, export metadata and images
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);

      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
      // If the filename template in osxphotos already includes a date/time prefix,
      // no additional rename step should be necessary.
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' and 'exportedFilename'
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
      photo.exportedFilename = generateExportedFilename(photo);
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(photosData);
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

/**
 * Generate the exported filename based on the photo's date and original filename.
 * If your osxphotos export command already includes a date/time prefix in the filename,
 * adjust this function accordingly or remove it if not needed.
 */
function generateExportedFilename(photo) {
  const dateObj = new Date(photo.date);
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  const originalName = path.parse(photo.original_filename).name;
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}-${originalName}.jpg`;
}
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import {
  runOsxphotosExportImages,
  getNestedProperty,
} from "../utils/export-images.js";
import plist from "plist";
import { exec } from "child_process";
import os from "os";
import { createRequire } from "module";
const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images with osxphotos (directly uses date/time prefix)
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property
    // Since images are now named with a prefix, original_filename should reflect that.
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 60;

    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    const photoTags = {};

    attributesToProcess.forEach(({ name, order, limit }) => {
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);
        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;
        return order === "asc" ? aValue - bValue : bValue - aValue;
      });

      const topPhotos = sortedPhotos.slice(0, limit);
      topPhotos.forEach((photo) => {
        if (!photoTags[photo.uuid]) {
          photoTags[photo.uuid] = [];
        }
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photo.uuid].includes(attributeDisplayName)) {
          photoTags[photo.uuid].push(attributeDisplayName);
        }
      });
    });

    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort the photos by requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);
      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;
      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

function capitalizeAttributeName(attributeName) {
  const nameParts = attributeName.split(".");
  const lastPart = nameParts[nameParts.length - 1];
  return lastPart
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];
    if (tags.length === 0) continue;

    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
```

### **./backend/data/albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums/6956E064-5A0E-4451-8A75-FC6724FED866/photos.json**
```json
[
    {
        "albums": [
            "2024-12-09",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res"
        ],
        "burst": false,
        "cloud_guid": "AbZe/Yx1gH5bPgoyi7FqXRZz8YrC",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 16:58:31.698262-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 11:03:56-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 320,
            "metering_mode": 5,
...
```

### **./backend/views/albums.hbs**
```
<!-- ./views/albums.hbs -->

<h1>Select an Album</h1>
<div class="album-list">
  {{#each albums}}
    <div class="album-item">
      <a href="/album/{{this.uuid}}">{{this.title}}</a>
    </div>
  {{/each}}
</div>```

### **./backend/views/index.hbs**
```
<!-- backend/views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a> | 
<a href="/album/{{albumUUID}}/persons">View People in this Album</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.exported_filename}}"
        alt="{{this.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.exported_filename}}

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/layouts/main.hbs -->


<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/views/person.hbs**
```
<!-- backend/views/person.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos of {{personName}} in Album</h1>
<a href="/album/{{albumUUID}}/persons">Back to People</a>

<form method="GET" action="/album/{{albumUUID}}/person/{{personName}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{photo.exported_filename}}"
        alt="{{photo.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{photo.exported_filename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property photo ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/persons.hbs**
```
<!-- ./views/persons.hbs -->

<h1>People in Album</h1>
<a href="/album/{{albumUUID}}">Back to Album</a>

<ul>
  {{#each people as |person|}}
    <li><a href="/album/{{../albumUUID}}/person/{{person}}">{{person}}</a></li>
  {{/each}}
</ul>```

### **./backend/routes/index.js**
```
// backend/routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";
import {
  getPeopleInAlbumLegacy,
  getPhotosByPersonLegacy,
} from "../controllers/people-legacy-controller.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// New legacy routes for persons
router.get("/album/:albumUUID/persons", getPeopleInAlbumLegacy);
router.get("/album/:albumUUID/person/:personName", getPhotosByPersonLegacy);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
// backend/routes/api.js

import express from "express";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";

// Import the new people controllers
import {
  getPeopleInAlbum,
  getPhotosByPerson,
} from "../controllers/api/people-controller.js";

const apiRouter = express.Router();

// API route to get all albums
apiRouter.get("/albums", getAlbumsData);

// API route to get a single album by UUID
apiRouter.get("/albums/:albumUUID", getAlbumById);

// API route to get photos by album UUID
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

// API routes for people in an album
apiRouter.get("/albums/:albumUUID/persons", getPeopleInAlbum);
apiRouter.get("/albums/:albumUUID/person/:personName", getPhotosByPerson);

export default apiRouter;
```

## Frontend Files

### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    // Add options here
    proxy: 'http://localhost:3000',
    sassOptions: {
      extension: 'scss',
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
// frontend/photo-filter-frontend/app/models/album.js

import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: true, inverse: 'album' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
// app/models/photo.js
import Model, { attr, belongsTo } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr('string') exportedFilename;
  @attr() score;
  @attr() exifInfo;
  @belongsTo('album', { async: true, inverse: 'photos' }) album;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```

### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/styles/app.scss**
```
.albums-layout {
  display: flex;
  flex-direction: row;
  min-height: 100vh;
}

.albums-sidebar {
  width: 250px;
  background: #f5f5f5;
  border-right: 1px solid #ddd;
  padding: 20px;
}

.albums-content {
  flex: 1;
  padding: 20px;
}

.albums-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.album-item {
  margin-bottom: 10px;
}

.smart-album-label {
  font-style: italic;
  color: gray;
}
```

### **./frontend/photo-filter-frontend/app/components/photo-grid.hbs**
```
<!-- app/components/photo-grid.hbs -->
{{#let (get (get-owner this).resolveRegistration('config:environment') 'APP.apiHost') as |apiHost|}}
<div class="photo-grid">
  {{#each @photos as |photo index|}}
    <div class="photo-item">
      <img
        src="{{apiHost}}/images/{{@albumUUID}}/{{photo.exportedFilename}}"
        alt="{{photo.exportedFilename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{index}} -</span>
        {{photo.exportedFilename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags as |tag|}}
              <span class="tag">{{tag}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace @sortAttribute "score." "")}}:
        {{get-nested-property photo @sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>
{{/let}}```

### **./frontend/photo-filter-frontend/app/components/photo-grid.js**
```
import Component from '@glimmer/component';

/**
 * PhotoGrid Component
 *
 * Arguments:
 * - @photos: An array of photo objects.
 * - @albumUUID: The album's UUID for constructing image URLs.
 * - @sortAttribute: The current sorting attribute to display values for.
 */
export default class PhotoGridComponent extends Component {}
```

### **./frontend/photo-filter-frontend/app/router.js**
```
// frontend/photo-filter-frontend/app/router.js

import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' }, function () {
      this.route('persons', function () {
        this.route('person', { path: '/:person_name' });
      });
    });
  });
});
```

### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
<h1>Select an Album</h1>

<!-- Wrap in a container with two columns: left for album list, right for content -->
<div class="albums-layout">
  <div class="albums-sidebar">
    <ul class="albums-list">
      {{#each this.model as |album|}}
        <li class="album-item">
          <LinkTo @route="albums.album" @model={{album.id}}>
            {{album.title}}
            {{#if album.isSmart}}
              <span class="smart-album-label">(Smart Album)</span>
            {{/if}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <div class="albums-content">
    {{! Nested routes (like albums.album, albums.album.persons) will render here }}
    {{outlet}}
  </div>
</div>```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
{{page-title "PhotoFilterFrontend"}}

{{outlet}}```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
<h1>{{this.model.album.title}}</h1>
<LinkTo @route="albums">Back to Albums</LinkTo>

<p>
  <LinkTo @route="albums.album.persons" @model={{this.model.album.id}}>
    View People in this Album
  </LinkTo>
</p>

<form {{on "submit" this.updateSort}}>
  <label for="sortAttribute">Sort by:</label>
  <select id="sortAttribute" {{on "change" this.selectSortAttribute}}>
    {{#each this.model.scoreAttributes as |attribute|}}
      <option
        value="score.{{attribute}}"
        selected={{eq this.sortAttribute (concat "score." attribute)}}
      >
        {{capitalize attribute}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select id="sortOrder" {{on "change" this.selectSortOrder}}>
    <option
      value="desc"
      selected={{eq this.sortOrder "desc"}}
    >Descending</option>
    <option value="asc" selected={{eq this.sortOrder "asc"}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<!-- Use the PhotoGrid component for displaying photos -->
<PhotoGrid
  @photos={{this.model.photos}}
  @albumUUID={{this.model.albumUUID}}
  @sortAttribute={{this.model.sortAttribute}}
/>```

### **./frontend/photo-filter-frontend/app/templates/albums/album/persons/person.hbs**
```
<h2>Photos of {{this.model.personName}} in {{this.model.album.title}}</h2>
<LinkTo @route="albums.album.persons" @model={{this.model.album.id}}>Back to
  People</LinkTo>

<form {{on "submit" (fn (mut (this.sortChanged)) true)}}>
  <label for="sortAttribute">Sort by:</label>
  <select id="sortAttribute" {{on "change" (fn this.selectSortAttribute)}}>
    {{#each this.model.scoreAttributes as |attribute|}}
      <option
        value="score.{{attribute}}"
        selected={{eq this.model.sortAttribute (concat "score." attribute)}}
      >
        {{capitalize attribute}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select id="sortOrder" {{on "change" (fn this.selectSortOrder)}}>
    <option
      value="desc"
      selected={{eq this.model.sortOrder "desc"}}
    >Descending</option>
    <option
      value="asc"
      selected={{eq this.model.sortOrder "asc"}}
    >Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<!-- Use the PhotoGrid component -->
<PhotoGrid
  @photos={{this.model.photos}}
  @albumUUID={{this.model.albumUUID}}
  @sortAttribute={{this.model.sortAttribute}}
/>```

### **./frontend/photo-filter-frontend/app/templates/albums/album/persons.hbs**
```
<h2>People in {{this.model.album.title}}</h2>
<ul>
  {{#each this.model.people as |person|}}
    <li>
      <LinkTo
        @route="albums.album.persons.person"
        @models={{array this.model.album.id person}}
      >
        {{person}}
      </LinkTo>
    </li>
  {{/each}}
</ul>

<LinkTo @route="albums.album" @model={{this.model.album.id}}>Back to Album</LinkTo>```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
// app/controllers/albums/album.js

import Controller from '@ember/controller';
import { action } from '@ember/object';

export default class AlbumsAlbumController extends Controller {
  queryParams = ['sort', 'order'];
  sort = 'score.overall';
  order = 'desc';

  @action
  updateSort(event) {
    event.preventDefault();
    // Properties are bound to query params; the model will refresh automatically
  }

  @action
  selectSortAttribute(event) {
    this.set('sort', event.target.value);
  }

  @action
  selectSortOrder(event) {
    this.set('order', event.target.value);
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/albums/album/persons/person.js**
```
// app/controllers/albums/album/persons/person.js

import Controller from '@ember/controller';
import { action } from '@ember/object';

export default class AlbumsAlbumPersonsPersonController extends Controller {
  queryParams = ['sort', 'order'];
  sort = 'score.overall';
  order = 'desc';

  @action
  selectSortAttribute(event) {
    this.set('sort', event.target.value);
  }

  @action
  selectSortOrder(event) {
    this.set('order', event.target.value);
  }

  @action
  updateSort(event) {
    event.preventDefault();
    // Trigger route refresh due to query param binding
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// app/routes/index.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service router;

  beforeModel() {
    this.router.replaceWith('albums');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
// app/routes/albums/album.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;

  queryParams = {
    sort: {
      refreshModel: true,
    },
    order: {
      refreshModel: true,
    },
  };

  async model(params) {
    const { album_id, sort = 'score.overall', order = 'desc' } = params;

    // Fetch the album without including photos
    const album = await this.store.findRecord('album', album_id);

    // Fetch photos associated with the album using store.query
    const photos = await this.store.query('photo', {
      album_id,
      sort,
      order,
    });

    // Get meta data from the photos response
    const meta = photos.meta || {};

    return {
      album,
      photos,
      albumUUID: meta.albumUUID || album_id,
      sortAttribute: meta.sortAttribute || sort,
      sortOrder: meta.sortOrder || order,
      scoreAttributes: meta.scoreAttributes || [],
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album/persons.js**
```
// app/routes/albums/album/persons.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import fetch from 'fetch';

export default class AlbumsAlbumPersonsRoute extends Route {
  @service store;

  async model(params) {
    const { album_id } = this.paramsFor('albums.album');
    // Fetch the list of people from the backend
    const response = await fetch(
      `${this.store.adapterFor('application').host}/api/albums/${album_id}/persons`,
    );
    const data = await response.json();

    return {
      album: await this.store.findRecord('album', album_id),
      people: data.data || [],
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album/persons/person.js**
```
// app/routes/albums/album/persons/person.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import fetch from 'fetch';

export default class AlbumsAlbumPersonsPersonRoute extends Route {
  @service store;

  queryParams = {
    sort: { refreshModel: true },
    order: { refreshModel: true },
  };

  async model(params) {
    const { album_id } = this.paramsFor('albums.album');
    const { person_name } = params;
    const sort = params.sort || 'score.overall';
    const order = params.order || 'desc';

    const url = `${this.store.adapterFor('application').host}/api/albums/${album_id}/person/${encodeURIComponent(person_name)}?sort=${sort}&order=${order}`;

    const response = await fetch(url);
    const data = await response.json();

    const photos = data.data || [];
    const meta = data.meta || {};

    return {
      album: await this.store.findRecord('album', album_id),
      personName: person_name,
      photos,
      albumUUID: meta.albumUUID || album_id,
      sortAttribute: meta.sortAttribute || sort,
      sortOrder: meta.sortOrder || order,
      scoreAttributes: meta.scoreAttributes || [],
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/eq.js**
```
// frontend/photo-filter-frontend/app/helpers/eq.js

import { helper } from '@ember/component/helper';

export default helper(function eq([a, b]) {
  return a === b;
});
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

### **./frontend/photo-filter-frontend/config/optional-features.json**
```
{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {
        // Here you can enable experimental features on an ember canary build
        // e.g. EMBER_NATIVE_DECORATOR_SUPPORT: true
      },
    },

    APP: {
      // Here you can pass flags/options to your application instance
      // when it is created
      apiHost: 'http://localhost:3000', // Add this line
    },
  };

  if (environment === 'development') {
    // ENV.APP.LOG_RESOLVER = true;
    // ENV.APP.LOG_ACTIVE_GENERATION = true;
    // ENV.APP.LOG_TRANSITIONS = true;
    // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
    // ENV.APP.LOG_VIEW_LOOKUPS = true;
  }

  if (environment === 'test') {
    // Testem prefers this...
    ENV.locationType = 'none';

    // keep test console output quieter
    ENV.APP.LOG_ACTIVE_GENERATION = false;
    ENV.APP.LOG_VIEW_LOOKUPS = false;

    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // here you can enable a production-specific feature
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": [
            "--ci-provider=github"
          ]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
// frontend/photo-filter-frontend/tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from '../helpers/index.js';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('visiting /albums and viewing an album', async function (assert) {
    await visit('/albums');

    assert.strictEqual(currentURL(), '/albums');
    assert.dom('h1').hasText('Select an Album');

    const albumLinks = findAll('a');
    assert.ok(albumLinks.length > 0, 'There are album links');

    // Click the first album link
    await click(albumLinks[0]);

    // The URL should change to the album route
    assert.ok(currentURL().startsWith('/albums/'), 'Navigated to album route');

    // Check that photos are displayed
    assert.dom('.photo-grid').exists('Photo grid is displayed');
    assert
      .dom('.photo-item')
      .exists({ count: 1 }, 'At least one photo is displayed');

    // Check that images have loaded
    assert.dom('.photo-item img').exists('Photo image is displayed');
  });
});
```

### **./frontend/photo-filter-frontend/tests/helpers/index.js**
```
import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file exists to provide wrappers around ember-qunit's
// test setup functions. This way, you can easily extend the setup that is
// needed per test type.

function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // Additional setup for application tests can be done here.
  //
  // For example, if you need an authenticated session for each
  // application test, you could do:
  //
  // hooks.beforeEach(async function () {
  //   await authenticateSession(); // ember-simple-auth
  // });
  //
  // This is also a good place to call test setup functions coming
  // from other addons:
  //
  // setupIntl(hooks, 'en-us'); // ember-intl
  // setupMirage(hooks); // ember-cli-mirage
}

function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);

  // Additional setup for rendering tests can be done here.
}

function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);

  // Additional setup for unit tests can be done here.
}

export { setupApplicationTest, setupRenderingTest, setupTest };
```

### **./frontend/photo-filter-frontend/README.md**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "license": "MIT",
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/string": "^4.0.0",
        "@ember/test-helpers": "^3.3.1",
        "@glimmer/component": "^1.1.2",
        "@glimmer/tracking": "^1.1.2",
        "broccoli-asset-rev": "^3.0.0",
...
```

### **./frontend/photo-filter-frontend/package.json**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Small description for photo-filter-frontend goes here",
  "repository": "",
  "license": "MIT",
  "author": "",
  "directories": {
    "doc": "doc",
    "test": "tests"
  },
  "scripts": {
    "build": "ember build --environment=production",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "start": "ember serve",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@ember/optional-features": "^2.1.0",
    "@ember/string": "^4.0.0",
    "@ember/test-helpers": "^3.3.1",
    "@glimmer/component": "^1.1.2",
    "@glimmer/tracking": "^1.1.2",
    "broccoli-asset-rev": "^3.0.0",
    "concurrently": "^8.2.2",
    "ember-auto-import": "^2.8.1",
    "ember-cli": "~5.12.0",
    "ember-cli-app-version": "^7.0.0",
    "ember-cli-babel": "^8.2.0",
    "ember-cli-clean-css": "^3.0.0",
    "ember-cli-dependency-checker": "^3.3.2",
    "ember-cli-htmlbars": "^6.3.0",
    "ember-cli-inject-live-reload": "^2.1.0",
    "ember-cli-sass": "^11.0.1",
    "ember-cli-sri": "^2.1.1",
    "ember-cli-terser": "^4.0.2",
    "ember-data": "~5.3.8",
    "ember-fetch": "^8.1.2",
    "ember-load-initializers": "^2.1.2",
    "ember-modifier": "^4.2.0",
    "ember-page-title": "^8.2.3",
    "ember-qunit": "^8.1.0",
    "ember-resolver": "^12.0.1",
    "ember-source": "~5.12.0",
    "ember-template-lint": "^6.0.0",
    "ember-welcome-page": "^7.0.2",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-ember": "^12.2.1",
    "eslint-plugin-n": "^16.6.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-qunit": "^8.1.2",
    "loader.js": "^4.7.0",
    "prettier": "^3.3.3",
    "qunit": "^2.22.0",
    "qunit-dom": "^3.2.1",
    "sass": "^1.80.6",
    "stylelint": "^15.11.0",
    "stylelint-config-standard": "^34.0.0",
    "stylelint-prettier": "^4.1.0",
    "tracked-built-ins": "^3.3.0",
    "webpack": "^5.95.0"
  },
  "engines": {
    "node": ">= 18"
  },
  "ember": {
    "edition": "octane"
  }
}
```

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
```

### **./frontend/photo-filter-frontend/.eslintrc.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
```

