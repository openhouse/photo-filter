# Project Overview: Photo Filter
-e 
Generated on: Sun Jan 12 11:25:03 EST 2025
Branch: feature/date-tree

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── ADVISORY_TEAM.md
├── COMPASSION.md
├── DEVELOPMENT_PLAN.md
├── ISSUES.md
├── README.md
├── backend
│   ├── .DS_Store
│   ├── .babelrc
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── dates-controller.js
│   │   │   ├── index.js
│   │   │   ├── people-controller.js
│   │   │   └── photos-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   ├── people-legacy-controller.js
│   │   └── photo-controller.js
│   ├── data
│   │   ├── ---albums.json
│   │   ├── --albums.json
│   │   ├── -albums.json
│   │   ├── .DS_Store
│   │   ├── albums
│   │   │   ├── --1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5
│   │   │   │   └── photos.json
│   │   │   ├── -1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5
│   │   │   │   └── photos.json
│   │   │   ├── .DS_Store
│   │   │   ├── 07B45549-D8E7-40E1-BBC2-AA6A8383054B
│   │   │   │   └── photos.json
│   │   │   ├── 16BC5397-4A87-49A1-8404-85D6473F3931
│   │   │   │   └── photos.json
│   │   │   ├── 1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5
│   │   │   │   └── photos.json
│   │   │   ├── 4CA23588-B72F-4807-8015-7ED9CABE44CB
│   │   │   │   └── photos.json
│   │   │   ├── 561CCDD4-26A7-4898-8514-ECE1AABF1409
│   │   │   │   └── photos.json
│   │   │   ├── 66B493A8-1AA2-42B1-8092-316B0B8B2EB4
│   │   │   │   └── photos.json
│   │   │   ├── 6956E064-5A0E-4451-8A75-FC6724FED866
│   │   │   │   └── photos.json
│   │   │   ├── 69865EDF-08F2-40B1-8E20-F802D6C4E6D3
│   │   │   │   └── photos.json
│   │   │   ├── 8F0E0536-45BB-4EED-A62B-B8F56D61412F
│   │   │   │   └── photos.json
│   │   │   ├── 918451EC-C6A5-416D-B919-D23AE46FEBBF
│   │   │   │   └── photos.json
│   │   │   ├── 9379D36A-15A0-4705-BFC1-23574AE145D8
│   │   │   │   └── photos.json
│   │   │   ├── 9D1ED02F-D8D1-43F9-ACE0-1D35B14DE195
│   │   │   │   └── photos.json
│   │   │   ├── A9641171-0398-46FC-B1EF-03B66D73BF32
│   │   │   │   └── photos.json
│   │   │   ├── C5170173-2B78-498D-AB6E-E29188933158
│   │   │   │   └── photos.json
│   │   │   ├── CCA9CBAC-2CE3-419B-BEB2-44A5F9B7854E
│   │   │   │   └── photos.json
│   │   │   ├── D3988A5F-8B66-464B-B18C-457EC672621A
│   │   │   │   └── photos.json
│   │   │   └── F3E7E679-D0C3-4442-9984-BA2C2B9DEA4C
│   │   │       └── photos.json
│   │   └── albums.json
│   ├── jest.config.js
│   ├── models
│   │   └── photoModel.js
│   ├── osxphotos_crash.log
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api
│   │   │   └── dates.js
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── test_albums.json
│   ├── tests
│   │   └── controllers
│   │       └── api
│   │           ├── albums-controller.test.js
│   │           └── photos-controller.test.js
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── export-images.js
│   │   ├── get-photos-library-last-modified.js
│   │   ├── helpers.js
│   │   └── run-python-script.js
│   ├── views
│   │   ├── albums.hbs
│   │   ├── index.hbs
│   │   ├── layouts
│   │   │   └── main.hbs
│   │   ├── person.hbs
│   │   └── persons.hbs
│   └── yarn.lock
├── cleanup-duplicates.sh
├── create-video.sh
├── frontend
│   ├── .DS_Store
│   └── photo-filter-frontend
│       ├── -package-lock.json
│       ├── .DS_Store
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── README.md
│       ├── app
│       │   ├── adapters
│       │   │   ├── application.js
│       │   │   └── photo.js
│       │   ├── app.js
│       │   ├── components
│       │   │   ├── .gitkeep
│       │   │   ├── date-nav.hbs
│       │   │   ├── date-nav.js
│       │   │   ├── photo-grid.hbs
│       │   │   └── photo-grid.js
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   ├── application.js
│       │   │   ├── dates
│       │   │   │   ├── year
│       │   │   │   │   ├── month
│       │   │   │   │   │   └── day.js
│       │   │   │   │   └── month.js
│       │   │   │   └── year.js
│       │   │   └── photo-collection.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── contains.js
│       │   │   ├── eq.js
│       │   │   ├── get-nested-property.js
│       │   │   └── replace.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   ├── person.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   ├── application.js
│       │   │   ├── dates
│       │   │   │   ├── index.js
│       │   │   │   ├── year
│       │   │   │   │   ├── month
│       │   │   │   │   │   └── day.js
│       │   │   │   │   └── month.js
│       │   │   │   └── year.js
│       │   │   ├── dates.js
│       │   │   └── index.js
│       │   ├── serializers
│       │   ├── services
│       │   │   ├── current-album.js
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.css
│       │   └── templates
│       │       ├── albums
│       │       │   ├── album
│       │       │   │   └── persons
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       ├── application.hbs
│       │       └── dates
│       │           ├── year
│       │           │   ├── month
│       │           │   │   └── day.hbs
│       │           │   └── month.hbs
│       │           └── year.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package-lock.json
│       ├── package.json
│       ├── postcss.config.js
│       ├── public
│       │   └── robots.txt
│       ├── tailwind.config.js
│       ├── testem.js
│       ├── tests
│       │   ├── acceptance
│       │   │   └── albums-test.js
│       │   ├── helpers
│       │   │   └── index.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       └── yarn.lock
├── generate-overview.sh
├── osxphotos_crash.log
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
└── top_photo_uuids.txt

85 directories, 171 files
```

---

## Root-Level Files

### **./ADVISORY_TEAM.md**
```
# Advisory Team

The following three individuals would form a dream advisory team for the Photo Filter Application. Their combined expertise spans Ember.js, Express.js, and the macOS Photos ecosystem, perfectly suiting the needs of this project.

---

## 1. Yehuda Katz

**Key Strengths**

- Co-creator of Ember.js and core contributor in the JavaScript ecosystem.
- Deep knowledge of Ember conventions, router patterns, and performance optimizations.
- Experienced mentor who can guide architectural decisions on large-scale Ember projects.

**Why This Matters for Photo Filter**

- Ember.js is your chosen frontend framework. Yehuda’s insider understanding of Ember can help you streamline routes, components, and data flows.
- He can advise on advanced patterns for query param–based filtering, performance, and future-proofing the Ember app.

---

## 2. Douglas Wilson

**Key Strengths**

- Longtime principal maintainer of Express.js.
- Expert in Node.js, HTTP request lifecycles, server performance, and middleware design.
- Skilled in diagnosing complex issues and optimizing for production-scale deployments.

**Why This Matters for Photo Filter**

- Your backend is built with Express.js. Douglas can help refine API endpoints, caching strategies, error handling, and security best practices.
- With the monorepo approach (Ember + Express), he’d ensure a robust Node foundation.

---

## 3. Rhet Turnbull

**Key Strengths**

- Creator and maintainer of [osxphotos](https://github.com/RhetTbull/osxphotos), the Python library for extracting and manipulating macOS Photos data.
- Specializes in reverse-engineering Apple Photos database structures.
- Active in responding to community needs around Apple Photos changes.

**Why This Matters for Photo Filter**

- Your pipeline uses Python scripts (osxphotos or a close variant) to export and process photos.
- Having Rhet’s insights ensures that your macOS Photos integration remains stable when Apple updates Photos’ schema or metadata.
- He can also recommend best practices for large-scale exports and metadata transformations.

---

## Summary

- **Yehuda Katz** → Ember.js guidance and future-proof front-end architecture.
- **Douglas Wilson** → Express.js expertise, server performance, and stable APIs.
- **Rhet Turnbull** → Deep Photos.app knowledge, ensuring your Python integration remains solid and up to date.

Collaborating with these three individuals would provide a near-ideal synergy across every major facet of your Photo Filter Application: front-end, backend, and macOS Photos integration.
```

### **./COMPASSION.md**
```
# COMPASSION.md

## **Compassion Software Principles**

This document outlines the foundational principles and guidelines for embedding compassion into the design, development, and lifecycle of software systems. Compassion Software is a framework for creating technology that prioritizes emotional intelligence, relational care, and ethical responsibility at every stage.

---

## **Core Principles**

1. **Self-Compassion**

   - Treat the development process, team members, and users with kindness.
   - Normalize imperfection and embrace failure as an opportunity for growth.
   - Embed affirmations and reminders throughout the documentation and system interface to encourage self-kindness for both users and developers.

2. **Radical Acceptance**

   - Recognize and work with reality as it is, without judgment or resistance.
   - Foster resilience by creating systems that adapt to complexity and uncertainty.

3. **Relational Intelligence**

   - Build tools that reflect and support healthy relational dynamics.
   - Use features like emotional mapping and communication templates to promote connection and understanding.
   - Ensure features evolve based on user stories and emotional data, creating a system that grows alongside its users.

4. **Trauma-Informed Design**

   - Prioritize safety and healing for users by avoiding re-traumatization.
   - Incorporate privacy, transparency, and options for user agency.

5. **Mindful Technology**

   - Encourage presence and intentional use of technology.
   - Avoid designs that exploit user attention or promote compulsive behaviors.
   - Include reflective prompts for developers to pause and approach their work with mindfulness.

6. **Collaborative Systems**
   - Treat every phase of development as an opportunity for deliberation and feedback.
   - Include diverse voices to ensure inclusivity and equity in design.
   - Institutionalize collaborative feedback mechanisms, such as structured discussions and user committees, to maintain a dynamic deliberative corpus.

---

## **Stations of the Software Apparatus**

Compassion Software recognizes specific stages in the software lifecycle as opportunities to embody compassion:

### **1. Design**

- Approach design with humility, curiosity, and an open mind.
- Use co-creation methods to include user perspectives early in the process.
- Reflect on ethical and relational implications of design choices.

### **2. Implementation**

- Write code that reflects transparency, modularity, and adaptability.
- Ensure the system can evolve alongside user needs and societal shifts.
- Encourage developers to engage in mindful coding practices, reflecting on the relational impact of their decisions.

### **3. Interaction**

- Craft user experiences that feel relational and empathetic.
- Include prompts for reflection and tools for emotional regulation.
- Use nonviolent communication templates that adapt dynamically to user needs, offering guidance while educating users about relational skills.

### **4. Iteration**

- Treat iteration as a space for learning and renewal.
- Integrate feedback loops to continuously improve functionality and relational impact.
- Develop metrics to measure how well the system fosters care, connection, and relational awareness.

---

## **Features to Prioritize**

- **Emotional Mapping**: Visualize user relationships and emotional dynamics, evolving over time based on user input and experiences.
- **Self-Compassion Toolkit**: Provide mindfulness prompts, stress cycle completion exercises, affirmations, and guidance for self-kindness.
- **Nonviolent Communication Templates**: Equip users to navigate conflict with empathy and understanding, adapting dynamically to user tone and context.
- **Safe Spaces**: Ensure privacy and user agency in all reflective or emotional features.
- **Gamified Acts of Kindness**: Encourage users to practice compassion in small, intentional ways.
- **Narrative Storytelling Features**: Allow users to co-create evolving emotional and relational stories with the system.

---

## **Ethical Commitments**

- **Privacy First**: Users retain ownership and control over their data.
- **Bias Awareness**: Actively identify and mitigate biases in design and algorithms.
- **Cultural Sensitivity**: Create inclusive systems that reflect diverse perspectives and needs.
- **Sustainability**: Prioritize resource-efficient technologies to minimize environmental impact.
- **Developer Accountability**: Establish processes to ensure developers adhere to ethical guidelines and relational goals.

---

## **Developer Guidelines**

1. **Collaborate with Empathy**

   - Approach teamwork with patience and understanding.
   - Foster psychological safety within the development environment.

2. **Document Decisions Thoughtfully**

   - Explain not just technical choices, but also ethical and relational considerations.
   - Use this document as a reference when evaluating the compassion impact of a feature.

3. **Test for Relational Impact**

   - Go beyond functionality to assess how features affect users emotionally and relationally.
   - Regularly gather user feedback to refine experiences.

4. **Iterate with Care**
   - Treat each iteration as an opportunity for growth, both for the system and the team.
   - Reflect on lessons learned and incorporate them into the next cycle.

---

## **Future Directions**

- Integrate AI tools to enhance relational insights while maintaining ethical standards.
- Partner with educators, therapists, and community leaders to expand use cases.
- Evolve the framework based on feedback from diverse user populations.

---

## **Closing Statement**

Compassion Software redefines how technology can serve humanity by embedding care, connection, and resilience at every stage. By following the principles outlined in this document, we aim to create systems that not only solve problems but also nurture the emotional and relational well-being of all who interact with them.
```

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

### December 14, 2024: Tailwind & DaisyUI Integration Update

**Decision & Implementation:**

- Removed `@import` of Tailwind CSS files in `app.scss` and replaced them with:
  ```scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  ```

### Update: Transition to Query-Param-Based Faceted Person Filtering

**Date:** December 12, 2024

**Decision:**

- Move from nested person-specific routes toward a unified album route that uses query parameters to filter by selected individuals.
- The UI will display a list of people in the left navigation under the currently active album. Users can toggle individuals on or off (via checkboxes or links), and the album’s displayed photos will filter to include only photos with all selected individuals.
- Remove the separate “View People in this Album” link and the “Back to Albums” link, as album navigation and person filtering are now integrated in the left nav.
- Eventually incorporate a front-end UI framework (like Bootstrap or Material Design) for a more cohesive look and feel.

**Rationale:**

- **Integrated Navigation:** Having all filtering (by album, by people) and sorting in one unified route simplifies the user experience.
- **Improved UX:** No need to navigate to a separate persons sub-route. People-based filtering is just another facet of the main album view.
- **Scalability:** Query params enable easy multi-person filtering. As the user selects multiple names, they appear in the URL’s query params, making the filtering state shareable and bookmarkable.
- **Future-Ready:** Paves the way to easily add other facets (like tags, locations, or events) as query-parameter-based filters.

**Implementation Steps:**

1. **Remove Person Sub-Routes:**
   - No longer need `albums/album/persons` or `albums/album/persons/person/:person_name`.
   - Instead, retrieve people from `GET /api/albums/:albumUUID/persons` and display them under the selected album in the left nav.
2. **Update Album Route to Use Query Params:**
   - Add a `people` query param to `albums.album`.
   - When a user toggles a person in the UI, update the `people` query param to reflect the currently selected individuals.
   - Filter photos based on the intersection of all selected individuals’ sets of photos.
3. **UI Updates:**
   - The left nav becomes scrollable and fixed in height, independent from the main content area.
   - Display the currently selected album title, below it a list of people. Each name toggles inclusion in the people filter.
   - No need for “Back to Albums” or “View People in This Album” links—navigation and filtering are seamlessly integrated.
4. **Backend:**
   - The backend remains largely the same. The frontend can still fetch all people via `GET /api/albums/:albumUUID/persons`.
   - For multiple individuals, the frontend will combine their names and request photos containing all of them, or request the full set and filter on the client side if needed. (Future optimization may be added on the backend.)
5. **Documentation:**
   - Update `DEVELOPMENT_PLAN.md`, `ISSUES.md`, and `README.md` to reflect the new approach.
   - Document how query parameters represent the filtering state.
6. **Testing and Validation:**
   - Ensure that selecting multiple individuals updates the displayed photos correctly.
   - Confirm that query params can be bookmarked and reloaded.
   - Test sorting combined with person-based filtering.

**Potential Challenges:**

- **Complex Filtering:** As multiple people are selected, performance could degrade for large albums. Consider caching or indexing if needed.
- **UI Complexity:** Need a clear indication of which people are currently selected and how to reset filters.
- **Backwards Compatibility:** Removing person sub-routes may require updating links or references.

**Previous Updates:**

- **December 7, 2024:** Initial person-level sub-routes conceived. _(Note: This approach is now evolving into a unified, query-param-based filter.)_
- **November 12, 2024:** Introduced nested routes, left nav, and sorting.
- **November 1, 2024:** Added cache invalidation for data freshness.
- **October 30, 2024:** Adopted JSON:API serializer.

**Project Goal:**
Create an intuitive, facet-based photo exploration tool integrated with macOS Photos data, enabling advanced sorting, selection, exporting, and multi-person filtering.

**Current State:**

- **Frontend:** Ember.js with album-level sorting and filtering now done fully on the frontend for improved performance.
- **Backend:** Express.js, JSON:API, data from `osxphotos`.
- **Data Handling:** `osxphotos` extracts metadata.
- **Selection & Export:** In progress.
- **Documentation & Styling:** Ongoing enhancements.

**Next Steps:**

1. **Implement Multi-Person Filtering with Query Params:**
   - Refactor UI to remove separate person routes (already done).
   - Add toggles in the left nav (done).
   - Update the album route’s model hook to factor in `people` query param (done).
2. **Improve Export Feature:**
   - Integrate actual export logic on the backend.
   - Show feedback to the user during export operations.
3. **UX and Performance:**
   - **Immediate Measure:** We have now implemented frontend-only sorting and filtering to avoid expensive re-fetches of large albums.
   - **Long-Term Vision:** Consider setting up an indexed database on the backend to handle large datasets more efficiently. Also develop a cache invalidation mechanism for Apple Photos library changes, so we know when our snapshot is stale and re-fetch only when necessary.
4. **Testing & Quality Assurance:**
   - Test multi-person filtering thoroughly.
   - Validate sorting and selection persistence with front-end-only filtering.
   - Confirm that no new network requests are made unnecessarily.
5. **Documentation & Cleanup:**
   - Keep all documentation updated.
   - Refactor code for maintainability.
```

### **./ISSUES.md**
```
# Issues and Resolutions

This file logs open issues and their statuses. Update it as new issues arise and existing ones progress.

---

## Issue 16: PostCSS "File not found: /app/styles/app.css" Error

**Opened By:** Jamie, Dec 14, 2024  
**Status:** In Progress

### Description

Encountered a build error because PostCSS didn’t find `app.css` after SCSS changes.

### Actions

- Installed `ember-cli-sass` to compile `app.scss` into `app.css`.
- Updated `app.scss` to use `@tailwind` directives instead of `@import`.
- (Alternative) Renamed `app.scss` to `app.css` and removed `ember-cli-sass`.

### Next Steps

- Verify build succeeds (`ember serve`).
- If successful, mark as Resolved after testing in production-like scenarios.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name], Nov 12, 2024  
**Status:** **Resolved**

### Description

`albums/album` route’s template not rendering correctly.

### Resolution

- Added `{{outlet}}` to `albums.hbs`.
- Verified proper rendering.

---

## Issue 14: 404 Error When Fetching Album Data

**Opened By:** [Your Name], Nov 10, 2024  
**Status:** **Resolved**

### Description

`GET /api/albums/:albumUUID` returned 404.

### Resolution

- Implemented `GET /api/albums/:albumUUID`.
- Confirmed endpoint now works as expected.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need multi-photo selection persistence across sorting and filtering changes.

### Actions

- Created `selection.js` service to manage selected photos.
- Selections persist when changing sort order or navigating within the album.

### Next Steps

- Integrate with multi-person filtering now that filtering is query-param-based.
- Ensure that selected photos remain selected as users toggle people filters.
- Write more comprehensive tests for selection persistence.

---

## Issue 9: Adding Actions for Selected Photos (Export Functionality)

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need to export selected photos from the backend once chosen on the frontend.

### Actions

- Created `/api/photos/export` endpoint.
- Frontend can send selected photo IDs to initiate export.
- Basic user alerts implemented to inform the user of export status.

### Next Steps

- Implement actual export logic on the backend.
- Add progress indicators (e.g., a progress bar) in the UI.
- Validate that exported filenames handle duplicates properly.

---

## Issue 16: Filename Collisions in Exports

**Opened By:** [Your Name], Dec 11, 2024  
**Status:** **Open** (Reopened Dec 12, 2024)

### Description

When exporting images, sometimes duplicate filenames occur.

### Current Approach

- Prepend date/time to filenames.
- Append counters for duplicates.

### Next Steps

- Confirm that this approach truly prevents collisions.
- Test extensively in a real environment before marking resolved.

---

## Newly Considered Issue: Replacing Person Sub-Routes with Query Params

**Opened By:** [Your Name], Dec 12, 2024  
**Status:** **In Planning**

### Description

We initially implemented `albums/album/persons` sub-routes. We now want to remove them in favor of query params on the main album route. This will unify navigation and filtering, removing the need for “Back” or “View People” links.

### Actions

- Update `DEVELOPMENT_PLAN.md` to reflect query-param-based person filtering.
- Adjust frontend UI to list people under the album in the left nav.
- Remove old person sub-route code once the new system is tested.

### Next Steps

- Implement toggles for people in the sidebar.
- Update the album route model hook to filter photos by selected people.
- Fully test the new approach.

---

## Issue 17: Persons Not Appearing in Album UI

**Opened By:** [Your Name], Dec 13, 2024  
**Status:** **Open**

### Description

Even though the backend returns `persons` as included data when fetching an album, they do not appear in the UI. In Ember Inspector, we see `album.persons` is present, but on the active controller, `persons` remains empty because the PromiseManyArray was not awaited before use.

### Actions

- In `app/routes/albums/album.js`, awaited `album.persons` before mapping/filtering.
- Once verified and tested, we can mark this issue resolved.

### Next Steps

- Verify persons now appear as expected.

---

## New Issue: `photoPersonNames` Always Empty in Controller

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** **Open**

### Description

We’re trying to filter photos by selected persons. However, `photoPersonNames` in `albums/album.js` controller logging always returns an empty array. The reason seems to be that `photo.persons` is not properly populated with Person model instances. Even though we have `@hasMany('person')` defined, the `persons` data might be coming in as raw strings rather than proper JSON:API relationships.

### Proposed Frontend-Only Fix

We can create a custom serializer for `photo` on the frontend that transforms the raw `persons` attribute into proper JSON:API relationships. This ensures Ember Data recognizes the `persons` as PersonModel instances.

### Next Steps

- Implement a `photo.js` serializer in `app/serializers/photo.js` that modifies the `normalize` response, converting `persons` strings into relationship objects and (optionally) included person records.
- Test if `photo.persons` now returns actual Person models.
- Confirm that `photoPersonNames` is no longer empty.

---

## Performance Impact from Re-Fetching Large Albums on Sort/Filter Changes

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** Open

### Description

Changing sorting/filtering previously caused large album re-fetches, leading to delays. We implemented front-end-only sorting and filtering to avoid unnecessary re-fetches.

### Actions

- Moved sorting and filtering logic to the frontend.
- Initial load might be slower, but subsequent operations are fast.

### Next Steps

- Consider indexed DB, cache invalidation strategies, pagination, or lazy loading for scalability.
- Monitor performance and refine as needed.

---

## Issue 19: Chrome "Aw, Snap!" Crash on Large Albums

**Opened By:** [Your Name], Dec 21, 2024  
**Status:** **Resolved**

### Description

When an album contains a very large number of photos (hundreds or thousands), Chrome sometimes crashes with an “Aw, Snap!” error code 5. This typically indicates the browser is running out of memory or hitting some resource limit.

### Resolution

- **Implemented a default limit (e.g., 200 photos) when requesting an album** to prevent the UI from trying to render or sort thousands of photos at once.
- Added a `limit` query param so advanced users can pull more photos if needed (with caution).

### Next Steps

- For truly large datasets, implement full pagination instead of a single “limit” slice.
- Monitor memory usage when increasing `limit`.

---

## Issue 20: Persistent "Cannot read properties of undefined (reading 'bind')" Error

**Opened By:** [Your Name], Jan 1, 2025  
**Status:** **Open**

### Description

We continue to see this console error in Chrome:

Uncaught (in promise) TypeError: Cannot read properties of undefined (reading ‘bind’)
at OnModifierState.updateListener (ember.js:6590:1)
…

Even after replacing `(on "click" ...)` with classic `{{action}}` in certain templates and removing potential `(fn)` usage, the error persists. Our attempts have included:

1. Converting to older style event handlers (i.e., `{{action "someMethod"}}`).
2. Removing or replacing `(on "eventName" this.someMethod)` wherever found.
3. Making sure all referenced actions are actually defined.

Yet the runtime error about `.bind` remains in the stack trace, pointing to `OnModifierState.updateListener` inside Ember’s internals.

### Steps We’ve Taken

- Searched for any leftover `(on ...)` usage in templates or angle-bracket components.
- Checked for `onsubmit`, `onclick`, or other direct event bindings that might be undefined.
- Ensured that each action or handler is defined (no `undefined` methods).
- Cleaned caches, restarted the Ember server, and done a hard browser reload.

### Next Steps / Open Questions

- **Is there a hidden or implicit usage of `{{on}}` in a third-party library or an addon** that is out of date?
- **Could a mismatch of Ember versions be causing `{{on}}` to fail** unexpectedly? We may need to confirm our app’s Ember version compatibility with the `on` or `fn` helpers.
- Investigate the Ember Inspector’s “Components” or “Routes” tabs to see if any components are auto-generated that might rely on `(on)`.
- If needed, log an Ember issue or check official Ember Slack for reports of `on` usage throwing `.bind` errors in certain versions.

### Action Items

1. **Search** the entire codebase for all `(on "` references (including `node_modules` if necessary).
2. **Verify** installed Ember version in `package.json` and ensure we don’t have conflicting addon versions that might break the built-in `on` modifier.
3. **Try** using a minimal reproduction app (create a fresh Ember project, replicate our steps) to see if the error occurs with our code or if the problem is project-specific.
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application. It enables browsing, filtering, and exporting photos from your macOS Photos library.

## Project Structure

- **backend/**: Express.js backend application.
- **frontend/**: Ember.js frontend application.
- **DEVELOPMENT_PLAN.md**: Roadmap and implementation details.
- **ISSUES.md**: Issues, debugging steps, and resolutions.
- **project-guidelines.md**: Collaboration and coding standards.

## Features

- **Album Navigation**: Browse albums via a left-side navigation column.
- **Photo Display**: View photos in selected albums with various sort options.
- **Faceted Person-Based Filtering**:  
  Under the currently active album, see a list of all recognized people.
  - **Single Person Filter**: Click one person’s name to display only photos with that individual.
  - **Multiple People Filter**: Select additional names to narrow photos down to those containing _all_ the chosen individuals, enabling powerful faceted search.
- **Sorting**: Sort photos by various attributes (e.g., aesthetic scores).
- **Photo Selection**: Select multiple photos; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Freshness

- The backend checks for changes in the Photos library.
- Cache invalidation ensures up-to-date album and photo data.

## Performance and Optimization

- JSON:API compliance for seamless Ember Data integration.
- Plans to implement lazy loading and indexing for improved performance.

## UI/UX

- Nested routes (`{{outlet}}`) for clarity.
- Future enhancements include more intuitive multi-person selection interfaces and better export feedback.

## Post-Photo-Filter Export Workflow: Preparing Photos for Video Editing

Once you have exported a directory of photos from the Photo Filter application, you may want to prepare them for video editing in Final Cut Pro X (FCPX) or another professional non-linear editor. The following steps outline how to normalize image orientation, generate a consistent file list, determine dimensions, and create a ProRes video file that preserves aspect ratios for all images.

**Prerequisites:**

- [ImageMagick](https://imagemagick.org/index.php)
- [FFmpeg](https://ffmpeg.org/) and its associated tools (e.g., \`ffprobe\`)
- A directory of \`.jpg\` images exported from the Photo Filter app

### 1. Ensure All Images Have the Correct Orientation

Use ImageMagick to apply rotation metadata directly to the pixel data. This ensures that downstream tools see the images correctly oriented:

\`\`\`bash
brew install imagemagick
mogrify -auto-orient \*.jpg
\`\`\`

### 2. Generate a File List for ffmpeg

First, list all \`.jpg\` images in the current directory:

\`\`\`bash
ls -1 \*.jpg > file_list.txt
\`\`\`

Then convert that listing into a format ffmpeg can parse:

\`\`\`bash
awk '{print "file \x27" $0 "\x27"}' file_list.txt > formatted_list.txt
\`\`\`

### 3. Determine the Dimensions of the First Image

Check the width and height of one of your images using ffprobe. Replace \`DSCF8482.jpg\` with an actual image filename from your directory:

\`\`\`bash
ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 DSCF8482.jpg
\`\`\`

Suppose this returns \`6240,4160\`. These will be your reference dimensions.

### 4. Convert Images to a Video with Preserved Aspect Ratios

Use ffmpeg to generate a ProRes \`.mov\` file. Scale and pad each image to fit the chosen dimensions (e.g., \`6240x4160\`) without distortion. Replace \`6240\` and \`4160\` with the values obtained above:

\`\`\`bash
ffmpeg -f concat -safe 0 -i formatted_list.txt \
-vf "scale='min(iw\*4160/ih,6240)':4160,setsar=1,pad=6240:4160:(6240-iw)/2:(4160-ih)/2" \
-framerate 16 -c:v prores -pix_fmt yuv422p output_preserved_aspect.mov
\`\`\`

**What This Does:**

- **Scale:** Adjusts each image so that it fits within the 6240x4160 frame, preserving its aspect ratio.
- **Pad:** Centers the scaled image by adding black bars if needed.
- **ProRes Encoding:** Outputs a high-quality \`.mov\` file suitable for editing in Final Cut Pro or other professional NLEs.
- **Framerate:** Sets the video to 16 frames per second, which you can adjust as desired.

### Additional Tips

- **Adjust the Frame Rate:**  
  Change \`-framerate 16\` to your desired frame rate (e.g., \`-framerate 24\`).

- **Change the Output Codec:**  
  Prefer a different codec (e.g., H.264 for smaller file sizes)? Replace \`-c:v prores -pix_fmt yuv422p\` with \`-c:v libx264 -crf 18\`.

- **Further Refinements:**  
  If you have specific creative requirements (e.g., adding transitions, stabilizing footage, or applying filters), you can incorporate those steps into your ffmpeg pipeline or perform them later in your video editing software.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter

   2.	Backend Setup:
   ```

cd backend
npm install
npm run setup
npm run dev

    3.	Frontend Setup:

Open a new terminal window:

cd frontend/photo-filter-frontend
npm install
npm run start

    4.	Access the Application:

Visit http://localhost:4200.

Contributing
• Use clear and descriptive commit messages.
• Track issues in ISSUES.md.
• Follow guidelines in project-guidelines.md.

Testing
• Backend: Use Jest for tests (npm run test in backend/).
• Frontend: Use Ember CLI testing (npm run test in frontend/).

License

This project is licensed under the MIT License.
```

### **./project-guidelines.md**
```
Project Guidelines

Table of Contents

- Project Philosophy
- Keeping Up with Dependencies
- Data Formats
- Data Synchronization and Caching
- Ensuring Complete Project Overviews
- Coding Standards
- Naming Conventions
- Directory Structure
- Documentation Practices
- Privacy and Data Handling
- Project State and Continuity
- Issue Tracking and Debugging
- Collaboration Guidelines
- Environment and Dependency Management
- Error Handling and Logging
- Security Best Practices
- Testing
- Deployment and Operations
- Performance Optimization

---

## Project Philosophy

- User-Centric Design, Interactivity, Clarity, Modularity, Consistency.
- Ember.js Conventions: Follow Ember.js patterns.
- Privacy, Security, Performance, Scalability.
- Embrace Iterative Understanding: Treat solutions as provisional and open to revision.

## Keeping Up with Dependencies

- Stay informed of the latest versions and updates.
- Test thoroughly after upgrading dependencies.
- Document changes and version notes.

## Data Formats

- Use JSON:API for backend/frontend integration.
- Utilize `jsonapi-serializer` on the backend.

## Data Synchronization and Caching

- Implement cache invalidation using timestamps.
- Balance data freshness with performance.

## Ensuring Complete Project Overviews

- Include all relevant files in generated overviews.
- Update `generate-overview.sh` as the project evolves.
- Regularly review project-overview.txt for accuracy.

## Coding Standards

- Consistent indentation (2 spaces).
- camelCase for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- Avoid globals; use modules.
- Follow Ember.js coding conventions where applicable.

## Naming Conventions

- Dasherized filenames (e.g., `photo-controller.js`).
- Descriptive and concise filenames.

## Directory Structure

- `backend/`: Express.js server and APIs
- `frontend/`: Ember.js app
- `data/`, `exports/`, `scripts/`, `utils/`, `tests/`
- Keep structure organized and consistent.

## Documentation Practices

- Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`.
- Use inline code comments and JSDoc.
- Maintain a changelog and consider `ARCHITECTURE.md` for big-picture decisions.
- Include “Questions to Consider” to highlight uncertainties.

## Privacy and Data Handling

- Do not store personal data in git.
- Be transparent about data processing.

## Project State and Continuity

- Self-contained documentation.
- Reflect current state, pending tasks, and future plans within the project files.

## Issue Tracking and Debugging

- Log issues in `ISSUES.md`.
- Document steps taken and current status.
- **Do Not Mark Issues as Resolved Until Verified**:  
  **No issue should be marked as "Resolved" until the fix is actually applied by the real person managing the system, and tested to confirm it works in reality.**
- Use "Uncertain" tags if needed to highlight unresolved aspects.
- Treat resolutions as provisional truths.

## Collaboration Guidelines

- Communicate clearly and concisely.
- Provide full file replacements for verifiable changes.
- Keep project composed of smaller files for easy copy-paste integration.
- Include clear commit messages.

## Environment and Dependency Management

- Use `.nvmrc` for Node.js versions.
- Keep dependencies updated and tested.
- Store config in environment variables.
- Adhere to JSON:API specs to ensure frontend-backend compatibility.

## Error Handling and Logging

- Implement robust error handling in async code.
- Provide meaningful error messages.
- Use logging for debugging and monitoring.

## Security Best Practices

- No sensitive info in version control.
- Validate/sanitize user inputs.
- Use environment variables for credentials.

## Testing

- Comprehensive test coverage: unit, integration, acceptance.
- Use Jest (backend) and Ember CLI testing tools (frontend).
- Mock external dependencies.
- Write tests alongside code changes.
- Keep tests reliable and maintainable.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configs.
- Monitor performance and errors in production.

## Performance Optimization

- Optimize large dataset handling.
- Use caching and lazy loading.
- Profile resource usage.
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/test_albums.json**
```
{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle 🎞️ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour — People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie ◍ Jamie": 4976, "Dominic ◍ Jamie": 4415, "Rosa Menkman ◍ Jamie Burkart": 2821, "Transfer ◍ Jamie Burkart": 2821, "Sondy ◍ Jamie": 2542, "Chad ◍ Jamie": 1830, "Lera Tarasenko ◍ Jamie Burkart": 1636, "Mir ◍ 196 Artists Residency": 1156, "Carper ◍ Burkart": 717, "Lydia ◍ Jamie": 380, "Jessi ◍ Mike ◍ Jamie": 347, "Jack ◍ Jamie": 332, "Lera Show ◍ Jamie Burkart": 310, "Patrick Weaver ◍ Jamie Burkart": 162, "Hayley ◍ Jamie": 149, "Claudette ◍ Jamie": 143, "Greta ◍ Shan ◍ Jamie": 137, "Zhen Li ◍ Jamie Burkart": 83, "Bobby ◍ Madeleine ◍ Jamie": 60, "Abby ◍ Jamie": 57, "Isabel Santos ◍ Jamie Burkart": 50, "Laura Mattingly ◍ Jamie Burkart": 45, "Thor ◍ Jamie": 35, "Stewart ◍ Jamie": 29, "Jessi ◍ Jamie Fashion Concepts &;-)": 26, "Gabi ◍ Michael ◍ Jamie": 17, "Melody ◍ Jamie": 13, "Michael ◍ Jamie": 9, "Em Gift ◍ Jamie Burkart": 1, "Bridget ◍ Jamie": 0}}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
```

### **./backend/utils/run-python-script.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
```

### **./backend/utils/exec-command.js**
```
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/utils/helpers.js**
```
// backend/utils/helpers.js

export function getNestedProperty(obj, propertyPath) {
  if (!propertyPath || typeof propertyPath !== "string") {
    return null;
  }
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

export function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

export function capitalizeAttributeName(attributeName) {
  const nameParts = attributeName.split(".");
  const lastPart = nameParts[nameParts.length - 1];
  return lastPart
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
```

### **./backend/utils/export-images.js**
```
// backend/utils/export-images.js

import fs from "fs-extra";
import path from "path";
import { execCommand } from "./exec-command.js";

/**
 * Export images using osxphotos for a given album.
 * @param {string} osxphotosPath - Path to the osxphotos executable in the virtualenv.
 * @param {string} albumUUID - The UUID of the album to export.
 * @param {string} imagesDir - The directory to which images will be exported.
 * @param {string} photosPath - The path to the photos.json file.
 */
export async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use a date/time prefix and original_name directly via osxphotos template:
  // {created.strftime,%Y%m%d-%H%M%S}-{original_name}
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{created.strftime,%Y%m%d-%H%M%S}-{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

/**
 * Safely get a nested property from an object.
 * @param {object} obj - The object to retrieve the property from.
 * @param {string} propertyPath - The dot-separated path (e.g. "score.overall").
 * @returns {*} - The property value or null if not found.
 */
export function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/models/photoModel.js**
```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

### **./backend/package-lock.json**
```json
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-backend",
      "version": "1.0.0",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "cors": "^2.8.5",
        "express": "^4.21.1",
        "fs-extra": "^11.2.0",
        "jsonapi-serializer": "^3.6.7"
      },
      "devDependencies": {
        "concurrently": "^9.0.1",
        "jest": "^29.7.0",
...
```

### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/setup.js**
```
// ./scripts/setup.js

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

(async () => {
  try {
    const venvDir = path.join(process.cwd(), "venv");
    const venvPython = path.join(venvDir, "bin", "python3");
    const venvPip = path.join(venvDir, "bin", "pip");

    // Use Python 3.11 explicitly
    const pythonExecutable = "python3.11";

    // Check if virtual environment exists
    const venvExists = await fs.pathExists(venvPython);

    if (!venvExists) {
      console.log(
        `Creating Python virtual environment with ${pythonExecutable}...`
      );
      await execAsync(`${pythonExecutable} -m venv venv`);
      console.log("Virtual environment created.");
    } else {
      console.log("Virtual environment already exists, ready to collaborate.");
    }

    // Install or upgrade osxphotos
    console.log(
      "Inviting osxphotos to join the project by installing or upgrading it..."
    );
    await execAsync(`"${venvPip}" install --upgrade osxphotos`);
    console.log("osxphotos is now part of the team.");

    console.log("Setup completed successfully, all components are in place.");
  } catch (error) {
    console.error("Setup encountered an issue:", error);
    process.exit(1);
  }
})();
```

### **./backend/controllers/api-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );

      // After exporting, rename files to prepend the photo's capture date
      await renameExportedImages(imagesDir, photosPath);
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Rename exported images with date-based filenames
async function renameExportedImages(imagesDir, photosPath) {
  const photosData = await fs.readJson(photosPath);

  for (const photo of photosData) {
    const originalName = path.parse(photo.original_filename).name; // e.g., DSCF1191
    const photoDate = new Date(photo.date); // Parse the photo’s date field
    const formattedDate = formatPhotoDate(photoDate); // YYYYMMDD-HHMMSS
    const oldPath = path.join(imagesDir, `${originalName}.jpg`);

    if (await fs.pathExists(oldPath)) {
      let newFilename = `${formattedDate}-${originalName}.jpg`;
      let finalPath = path.join(imagesDir, newFilename);

      // Check for collisions
      let counter = 1;
      while (await fs.pathExists(finalPath)) {
        newFilename = `${formattedDate}-${originalName}-${counter}.jpg`;
        finalPath = path.join(imagesDir, newFilename);
        counter++;
      }

      await fs.rename(oldPath, finalPath);
      console.log(`Renamed ${originalName}.jpg to ${newFilename}`);
    } else {
      console.warn(`File not found for rename: ${oldPath}`);
    }
  }
}

// Format the photo date as YYYYMMDD-HHMMSS
function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/people-legacy-controller.js**
```
// backend/controllers/people-legacy-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { getNestedProperty } from "../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Show all people in an album
export const getPeopleInAlbumLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Gather all distinct people
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    const people = Array.from(allPersons).sort();

    // Render persons.hbs view
    res.render("persons", { albumUUID, people });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Show photos of a single person in the album
export const getPhotosByPersonLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by person
    const filteredPhotos = photosData.filter((photo) => {
      return Array.isArray(photo.persons) && photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      // No photos of this person
      return res.render("person", {
        albumUUID,
        personName,
        photos: [],
        scoreAttributes: [],
        sortAttribute,
        sortOrder,
      });
    }

    // Add original_name property
    filteredPhotos.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from the first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort photos based on the requested attribute
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Render person.hbs view
    res.render("person", {
      albumUUID,
      personName,
      photos: filteredPhotos,
      scoreAttributes,
      sortAttribute,
      sortOrder,
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
```

### **./backend/controllers/api/albums-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const AlbumSerializer = new Serializer("album", {
  id: "uuid",
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
  relationships: {
    persons: {
      type: "person",
    },
  },
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    await fs.ensureDir(dataDir);

    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    const albumsData = await fs.readJson(albumsPath);
    const jsonApiData = AlbumSerializer.serialize(albumsData);
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    const albumsData = await fs.readJson(albumsPath);
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    let persons = [];
    if (await fs.pathExists(photosPath)) {
      const photosData = await fs.readJson(photosPath);
      const allPersons = new Set();
      photosData.forEach((photo) => {
        if (Array.isArray(photo.persons)) {
          photo.persons.forEach((name) => allPersons.add(name));
        }
      });
      persons = Array.from(allPersons).map((name) => {
        return {
          id: slugifyName(name),
          name: name,
        };
      });
    }

    const albumRecord = {
      uuid: album.uuid,
      title: album.title,
    };

    let albumJsonApi = AlbumSerializer.serialize(albumRecord);
    albumJsonApi.data.relationships = albumJsonApi.data.relationships || {};
    albumJsonApi.data.relationships.persons = {
      data: persons.map((p) => ({ type: "person", id: p.id })),
    };

    const personJsonApi = PersonSerializer.serialize(persons);

    const merged = {
      data: albumJsonApi.data,
      included: personJsonApi.data,
      meta: {},
    };

    res.json(merged);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/api/dates-controller.js**
```
// backend/controllers/api/dates-controller.js
import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Retrieve a hierarchical object of all photos grouped by [year][month][day].
 *
 * Example output shape:
 * {
 *   "2022": {
 *     "11": {
 *       "30": [ { photoObject }, { photoObject }, ... ],
 *       "31": [ ... ]
 *     },
 *     "12": { ... }
 *   },
 *   "2023": { ... },
 *   ...
 * }
 */
export async function getAllPhotosGroupedByDate() {
  const dataDir = path.join(__dirname, "..", "..", "data", "albums");
  if (!(await fs.pathExists(dataDir))) {
    // If there's no data at all, return empty
    return {};
  }

  const albumFolders = await fs.readdir(dataDir);
  const grouped = {};

  // Traverse each album folder to find `photos.json`. Merge all photos into one big set.
  for (const albumFolder of albumFolders) {
    const photosJsonPath = path.join(dataDir, albumFolder, "photos.json");
    const stat = await fs.stat(path.join(dataDir, albumFolder));
    if (stat.isDirectory() && (await fs.pathExists(photosJsonPath))) {
      const photosData = await fs.readJson(photosJsonPath);
      for (const photo of photosData) {
        // Parse the date field: e.g. "2024-12-09 21:54:43-05:00"
        let dateObj;
        try {
          dateObj = new Date(photo.date);
        } catch {
          continue; // skip if date is invalid
        }

        const year = String(dateObj.getFullYear());
        // getMonth() is 0-based, so add 1
        const month = String(dateObj.getMonth() + 1).padStart(2, "0");
        const day = String(dateObj.getDate()).padStart(2, "0");

        if (!grouped[year]) {
          grouped[year] = {};
        }
        if (!grouped[year][month]) {
          grouped[year][month] = {};
        }
        if (!grouped[year][month][day]) {
          grouped[year][month][day] = [];
        }
        grouped[year][month][day].push(photo);
      }
    }
  }

  return grouped;
}

/** GET /api/dates
 * Returns the entire year-month-day nested structure (without the actual photos array for every day).
 * Instead we return only counts at each node, so the frontend can build a collapsible tree
 * without fetching every single photo upfront.
 */
export async function listAllDates(req, res) {
  try {
    const grouped = await getAllPhotosGroupedByDate();
    // Build a minimal structure containing only {count: n, children} to keep the payload small
    const summary = {};

    for (const year of Object.keys(grouped)) {
      summary[year] = {
        count: 0,
        months: {},
      };
      for (const month of Object.keys(grouped[year])) {
        summary[year].months[month] = {
          count: 0,
          days: {},
        };
        for (const day of Object.keys(grouped[year][month])) {
          const dayPhotos = grouped[year][month][day];
          summary[year].months[month].days[day] = {
            count: dayPhotos.length,
          };
          // add to the parent's total
          summary[year].months[month].count += dayPhotos.length;
          summary[year].count += dayPhotos.length;
        }
      }
    }

    res.json({ data: summary });
  } catch (error) {
    console.error("Error listing all dates:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
}

/** GET /api/dates/:year
 * Return all photos for that entire year.
 */
export async function getPhotosByYear(req, res) {
  try {
    const year = req.params.year;
    const grouped = await getAllPhotosGroupedByDate();
    if (!grouped[year]) {
      return res.json({ data: [] });
    }
    // Flatten all months/days for that year
    let photos = [];
    for (const month of Object.keys(grouped[year])) {
      for (const day of Object.keys(grouped[year][month])) {
        photos = photos.concat(grouped[year][month][day]);
      }
    }
    res.json({ data: photos });
  } catch (error) {
    console.error("Error getting photos by year:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
}

/** GET /api/dates/:year/:month
 * Return all photos for that year+month.
 */
export async function getPhotosByYearMonth(req, res) {
  try {
    const { year, month } = req.params;
    const grouped = await getAllPhotosGroupedByDate();
    if (!grouped[year] || !grouped[year][month]) {
      return res.json({ data: [] });
    }
    let photos = [];
    for (const day of Object.keys(grouped[year][month])) {
      photos = photos.concat(grouped[year][month][day]);
    }
    res.json({ data: photos });
  } catch (error) {
    console.error("Error getting photos by year+month:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
}

/** GET /api/dates/:year/:month/:day
 * Return all photos for that specific day.
 */
export async function getPhotosByYearMonthDay(req, res) {
  try {
    const { year, month, day } = req.params;
    const grouped = await getAllPhotosGroupedByDate();
    if (!grouped[year] || !grouped[year][month] || !grouped[year][month][day]) {
      return res.json({ data: [] });
    }
    const photos = grouped[year][month][day];
    res.json({ data: photos });
  } catch (error) {
    console.error("Error getting photos by day:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
}
```

### **./backend/controllers/api/index.js**
```
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/people-controller.js**
```
// backend/controllers/api/people-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
    "persons",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

// List all people in an album
export const getPeopleInAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Extract all persons from all photos
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    res.json({ data: Array.from(allPersons) });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Get photos of a specific person in the album
export const getPhotosByPerson = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by personName
    const filteredPhotos = photosData.filter((photo) => {
      if (!Array.isArray(photo.persons)) return false;
      return photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      return res.json({
        data: [],
        meta: {
          albumUUID,
          personName,
          sortAttribute,
          sortOrder,
          scoreAttributes: [],
        },
      });
    }

    // Add originalName property
    filteredPhotos.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    filteredPhotos.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(filteredPhotos);

    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        personName,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/photos-controller.js
import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../../utils/export-images.js";
import { getNestedProperty } from "../../utils/helpers.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "exportedFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: { type: "album" },
    persons: { type: "person" },
  },
  pluralizeType: false,
  meta: {},
});

function formatPhotoDateWithOffset(dateString) {
  const match = dateString.match(
    /^(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2}(?:\.\d+)?)([\+\-]\d{2}:\d{2})$/
  );
  if (!match) {
    return fallbackFormat(new Date(dateString));
  }

  const datePart = match[1];
  const timePart = match[2];

  const [year, month, day] = datePart.split("-").map(Number);
  const [hour, minute, secondRaw] = timePart.split(":");
  const hourNum = Number(hour);
  const minuteNum = Number(minute);
  const secondNum = Math.floor(Number(secondRaw));

  const YYYY = String(year);
  const MM = String(month).padStart(2, "0");
  const DD = String(day).padStart(2, "0");
  const HH = String(hourNum).padStart(2, "0");
  const mm = String(minuteNum).padStart(2, "0");
  const ss = String(secondNum).padStart(2, "0");

  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

function fallbackFormat(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    let photosData = await fs.readJson(photosPath);

    // Deduplicate photos by (original_filename, date) if needed
    photosData = deduplicatePhotos(photosData);

    // Prepare each photo
    const uniquePersons = new Map();
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
      const prefix = formatPhotoDateWithOffset(photo.date);
      photo.exportedFilename = `${prefix}-${photo.originalName}.jpg`;

      // Ensure persons is an array; if empty or undefined, make it empty array
      if (!Array.isArray(photo.persons)) {
        photo.persons = [];
      }

      // Collect person slugs
      photo.personsData = photo.persons.map((name) => {
        const slug = slugifyName(name);
        if (!uniquePersons.has(slug)) {
          uniquePersons.set(slug, { id: slug, name });
        }
        return { type: "person", id: slug };
      });

      // Set the album relationship
      photo.album = albumUUID;
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Serialize photos
    const jsonApiPhotoData = PhotoSerializer.serialize(photosData);

    // Serialize persons
    const personsArray = Array.from(uniquePersons.values());
    const jsonApiPersonData = PersonSerializer.serialize(personsArray);

    // Merge included resources
    const merged = {
      data: jsonApiPhotoData.data,
      included: jsonApiPersonData.data,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    };

    // Assign relationships.persons to each photo in `merged.data`
    // This ensures each photo has a proper JSON:API relationship
    merged.data.forEach((photo) => {
      const originalPhoto = photosData.find((p) => p.uuid === photo.id);
      if (
        originalPhoto &&
        originalPhoto.personsData &&
        originalPhoto.personsData.length > 0
      ) {
        photo.relationships = photo.relationships || {};
        photo.relationships.persons = {
          data: originalPhoto.personsData,
        };
      } else {
        photo.relationships = photo.relationships || {};
        photo.relationships.persons = { data: [] };
      }
    });

    res.json(merged);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function deduplicatePhotos(photos) {
  const map = new Map();
  for (const photo of photos) {
    const key = `${photo.original_filename}-${photo.date}`;
    if (!map.has(key)) {
      map.set(key, { ...photo });
    } else {
      // Merge persons if there's a duplicate
      const existing = map.get(key);
      if (Array.isArray(photo.persons)) {
        const existingPersons = new Set(existing.persons || []);
        photo.persons.forEach((p) => existingPersons.add(p));
        existing.persons = Array.from(existingPersons);
      }
      map.set(key, existing);
    }
  }
  return Array.from(map.values());
}

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";
import plist from "plist";
import { exec } from "child_process";
import os from "os";
import { createRequire } from "module";
import {
  getNestedProperty,
  capitalizeAttributeName,
} from "../utils/helpers.js";

const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images with osxphotos (directly uses date/time prefix)
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 60;

    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    const photoTags = {};

    attributesToProcess.forEach(({ name, order, limit }) => {
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);
        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;
        return order === "asc" ? aValue - bValue : bValue - aValue;
      });

      const topPhotos = sortedPhotos.slice(0, limit);
      topPhotos.forEach((photo) => {
        if (!photoTags[photo.uuid]) {
          photoTags[photo.uuid] = [];
        }
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photo.uuid].includes(attributeDisplayName)) {
          photoTags[photo.uuid].push(attributeDisplayName);
        }
      });
    });

    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort the photos by requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);
      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;
      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];
    if (tags.length === 0) continue;

    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
```

### **./backend/data/--albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/---albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/-albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums/A9641171-0398-46FC-B1EF-03B66D73BF32/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Grace Beana Burkart"
        ],
        "burst": false,
        "cloud_guid": "AR32fGDeh6iwMqLM9P5veibjAKgk",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-20 21:18:23.937434-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-20 17:42:02-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 3200,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/918451EC-C6A5-416D-B919-D23AE46FEBBF/photos.json**
```json
[
    {
        "albums": [
            "Sheep"
        ],
        "burst": false,
        "cloud_guid": "AbkiIdG7V0IzR4NfC4f4B8JslwNm",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2022-11-06 11:52:19.752600-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2022-11-06 17:52:18.936800+01:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1600,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/69865EDF-08F2-40B1-8E20-F802D6C4E6D3/photos.json**
```json
[
    {
        "albums": [
            "2024-12-11-Last Month",
            "Anna Pompermaier",
            "Austria",
            "Cenk G\u00fczelis",
            "FujiFilm x100v: All, Full Res",
            "Innsbruck, Austria",
            "Recent Month",
            "Recent Week",
            "Studio3",
            "Studio3 Symposium",
            "Studio3 Symposium \u2014\u00a0IRL"
        ],
        "burst": false,
        "cloud_guid": "AYxUYDskCQ/gPyKyTSQOsTKDO0qz",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-15 11:48:30.564913-05:00",
...
```

### **./backend/data/albums/1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Stefania"
        ],
        "burst": false,
        "cloud_guid": "AUf+djE+jaJNIaz2xEN31IC7yKg+",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-01 20:27:27.985500-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-01 19:29:14-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/66B493A8-1AA2-42B1-8092-316B0B8B2EB4/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V",
            "Jamie Burkart Portraits"
        ],
        "burst": false,
        "cloud_guid": "AXcMiG1MSUL3SVk2F2qOUqtpRNBS",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-28 19:23:39.381971-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-28 19:20:46-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/9379D36A-15A0-4705-BFC1-23574AE145D8/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Snow"
        ],
        "burst": false,
        "cloud_guid": "AeXFxa+Ga0PHwnMCmCZZC+qJZli9",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-06 14:55:41.022275-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-06 13:58:42-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 160,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/8F0E0536-45BB-4EED-A62B-B8F56D61412F/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "With Stefania"
        ],
        "burst": false,
        "cloud_guid": "Ae1jAv2u3zZVfKq8TJccL1BVavdL",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-07 18:34:44.419988-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-07 16:26:42-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 500,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/4CA23588-B72F-4807-8015-7ED9CABE44CB/photos.json**
```json
[
    {
        "albums": [
            "Dominic Antoine 2024",
            "FUJIFILM X100V-02"
        ],
        "burst": false,
        "cloud_guid": "Aep68bd5MWDZRzijvX3EiaHDQ5zX",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-23 17:38:23.356118-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-23 14:32:41-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/-1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Stefania"
        ],
        "burst": false,
        "cloud_guid": "AUf+djE+jaJNIaz2xEN31IC7yKg+",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-01 20:27:27.985500-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-01 19:29:14-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/16BC5397-4A87-49A1-8404-85D6473F3931/photos.json**
```json
[
    {
        "albums": [
            "2024-12-11-Last Month"
        ],
        "burst": false,
        "cloud_guid": "AUe3MMiGEMSXiJQFq+RdRUZ6gohE",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 21:54:44.122153-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 21:54:43.398000-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 2000,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/--1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Stefania"
        ],
        "burst": false,
        "cloud_guid": "AUf+djE+jaJNIaz2xEN31IC7yKg+",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-01 20:27:27.985500-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-01 19:29:14-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/F3E7E679-D0C3-4442-9984-BA2C2B9DEA4C/photos.json**
```json
[
    {
        "albums": [
            "Dominic Antoine Family Visit",
            "FujiFilm x100v: All, Full Res"
        ],
        "burst": false,
        "cloud_guid": "ASVx5Ac1sLyomOfpmIfrjujWXi0n",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-18 03:53:17.829920-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-17 17:53:36-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 3200,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/561CCDD4-26A7-4898-8514-ECE1AABF1409/photos.json**
```json
[
    {
        "albums": [
            "2024-12-01-day",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res",
            "Max & Jamie",
            "Mir & Max",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AcSEPiuXBZgwpoiypBMP7q0DWUTt",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-30 20:35:09.211243-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 19:07:52-05:00",
        "description": null,
        "exif_info": {
...
```

### **./backend/data/albums/9D1ED02F-D8D1-43F9-ACE0-1D35B14DE195/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V",
            "Kendell + Mandy",
            "Sold the building"
        ],
        "burst": false,
        "cloud_guid": "AbKvwshLoD5UVXKZ2eDVsCSnrfVk",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-03-20 23:52:55.841168-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-03-20 21:24:15-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 640,
            "metering_mode": 5,
...
```

### **./backend/data/albums/6956E064-5A0E-4451-8A75-FC6724FED866/photos.json**
```json
[
    {
        "albums": [
            "2024-12-09",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res"
        ],
        "burst": false,
        "cloud_guid": "AbZe/Yx1gH5bPgoyi7FqXRZz8YrC",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 16:58:31.698262-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 11:03:56-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 320,
            "metering_mode": 5,
...
```

### **./backend/data/albums/D3988A5F-8B66-464B-B18C-457EC672621A/photos.json**
```json
[
    {
        "albums": [
            "2024-12-01-day",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res",
            "Max & Jamie",
            "Mir & Max",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AQucx0r2Z1j5VHamAkpTY4+F+3fP",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-30 20:35:09.221502-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 19:07:52-05:00",
        "description": null,
        "exif_info": {
...
```

### **./backend/data/albums/C5170173-2B78-498D-AB6E-E29188933158/photos.json**
```json
[
    {
        "albums": [
            "Emily Sphere"
        ],
        "burst": false,
        "cloud_guid": "AZriFwpx5Ic8GtYQ/tSX84mN620u",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2023-09-30 17:32:49.434345-04:00",
        "date_modified": "2024-06-13 16:54:23.792595-04:00",
        "date_trashed": null,
        "date": "2023-09-30 17:32:49.300000-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 640,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/CCA9CBAC-2CE3-419B-BEB2-44A5F9B7854E/photos.json**
```json
[
    {
        "albums": [
            "Charlie - We Might See"
        ],
        "burst": false,
        "cloud_guid": "AQp/d2GQnkiwJcHCYwLF41QqJ+1A",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2023-05-16 20:30:31.319333-04:00",
        "date_modified": "2024-06-14 09:39:48.291821-04:00",
        "date_trashed": null,
        "date": "2023-05-16 20:17:17-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": null,
            "metering_mode": null,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/07B45549-D8E7-40E1-BBC2-AA6A8383054B/photos.json**
```json
[
    {
        "albums": [
            "196 Bulbs \ud83d\udca1 2024",
            "2024-12-11-Last Month",
            "A Great Day",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AYb8yeUxUYOD4yxwAvDh0b3UBV7l",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-01 10:30:41.023814-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 21:52:27-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 2500,
...
```

### **./backend/views/albums.hbs**
```
<h1 class="text-3xl font-bold mb-4">Select an Album</h1>

<div class="flex flex-row h-screen">
  <!-- Sidebar -->
  <div
    class="w-64 bg-base-100 border-r border-base-300 h-full overflow-y-auto p-4"
  >
    <ul class="menu w-full">
      {{#each this.model as |album|}}
        <li class="mb-1">
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-base-300"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <div class="flex-1 p-6">
    {{outlet}}
  </div>
</div>```

### **./backend/views/index.hbs**
```
<!-- backend/views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a> | 
<a href="/album/{{albumUUID}}/persons">View People in this Album</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.exported_filename}}"
        alt="{{this.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.exported_filename}}

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/layouts/main.hbs -->

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/views/person.hbs**
```
<!-- ./views/person.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos of {{personName}} in Album</h1>
<a href="/album/{{albumUUID}}/persons">Back to People</a>

<form method="GET" action="/album/{{albumUUID}}/person/{{personName}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{photo.exported_filename}}"
        alt="{{photo.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{photo.exported_filename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property photo ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/persons.hbs**
```
<!-- ./views/persons.hbs -->

<h1>People in Album</h1>
<a href="/album/{{albumUUID}}">Back to Album</a>

<ul>
  {{#each people as |person|}}
    <li><a href="/album/{{../albumUUID}}/person/{{person}}">{{person}}</a></li>
  {{/each}}
</ul>```

### **./backend/routes/index.js**
```
// backend/routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";
import {
  getPeopleInAlbumLegacy,
  getPhotosByPersonLegacy,
} from "../controllers/people-legacy-controller.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// New legacy routes for persons
router.get("/album/:albumUUID/persons", getPeopleInAlbumLegacy);
router.get("/album/:albumUUID/person/:personName", getPhotosByPersonLegacy);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api/dates.js**
```
// backend/routes/api/dates.js
import express from "express";
import {
  listAllDates,
  getPhotosByYear,
  getPhotosByYearMonth,
  getPhotosByYearMonthDay,
} from "../../controllers/api/dates-controller.js";

const datesRouter = express.Router();

// GET /api/dates
datesRouter.get("/", listAllDates);
// GET /api/dates/:year
datesRouter.get("/:year", getPhotosByYear);
// GET /api/dates/:year/:month
datesRouter.get("/:year/:month", getPhotosByYearMonth);
// GET /api/dates/:year/:month/:day
datesRouter.get("/:year/:month/:day", getPhotosByYearMonthDay);

export default datesRouter;
```

### **./backend/routes/api.js**
```
// backend/routes/api.js

import express from "express";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";
import {
  getPeopleInAlbum,
  getPhotosByPerson,
} from "../controllers/api/people-controller.js";

// IMPORTANT: Fixed import path to include the "api/" subfolder
import datesRouter from "./api/dates.js";

const apiRouter = express.Router();

// API route to get all albums
apiRouter.get("/albums", getAlbumsData);

// API route to get a single album by UUID
apiRouter.get("/albums/:albumUUID", getAlbumById);

// API route to get photos by album UUID
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

// API routes for people in an album
apiRouter.get("/albums/:albumUUID/persons", getPeopleInAlbum);
apiRouter.get("/albums/:albumUUID/person/:personName", getPhotosByPerson);

// ====== NEW: MOUNT /api/dates ======
apiRouter.use("/dates", datesRouter);

export default apiRouter;
```

## Frontend Files

### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  let app = new EmberApp(defaults, {
    postcssOptions: {
      compile: {
        enabled: true,
        plugins: [
          require('tailwindcss')('./tailwind.config.js'),
          require('autoprefixer'),
        ],
      },
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/tailwind.config.js**
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.hbs',
    './app/**/*.js',
    './app/**/*.ts',
    './app/**/*.gjs',
    './app/**/*.gts',
  ],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
};
```

### **./frontend/photo-filter-frontend/app/models/person.js**
```
// frontend/photo-filter-frontend/app/models/person.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class PersonModel extends Model {
  @attr('string') name;
  @hasMany('photo', { async: true, inverse: 'persons' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
// frontend/photo-filter-frontend/app/models/album.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: false, inverse: 'album' }) photos;
  // Change persons to async: false since we include all data and don't want extra requests
  @hasMany('person', { async: false, inverse: null }) persons;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
// frontend/photo-filter-frontend/app/models/photo.js
import Model, { attr, belongsTo, hasMany } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr('string') exportedFilename;
  @attr() score;
  @attr() exifInfo;

  @belongsTo('album', { async: false, inverse: 'photos' }) album;
  // Set async: false since we include all persons in the payload
  @hasMany('person', { async: false, inverse: 'photos' }) persons;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```

### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/components/photo-grid.hbs**
```
<div class="grid gap-6 sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-2">
  {{#each @photos as |photo index|}}
    <div class="card bg-base-100 shadow-lg">
      <figure>
        <img
          src="{{this.apiHost}}/images/{{@albumUUID}}/{{photo.exportedFilename}}"
          alt="{{photo.exportedFilename}}"
          class="max-w-full h-auto"
        />
      </figure>
      <div class="card-body">
        <h2 class="card-title text-sm">
          <span class="opacity-50">{{index}} -</span>
          {{photo.exportedFilename}}
        </h2>

        {{#if photo.tags}}
          <div class="mt-2 flex flex-wrap gap-2">
            {{#each photo.tags as |tag|}}
              <span class="badge badge-accent badge-outline">{{tag}}</span>
            {{/each}}
          </div>
        {{/if}}

        <p class="mt-2">
          {{capitalize (replace @sortAttribute "score." "")}}:
          {{get-nested-property photo @sortAttribute}}
        </p>
      </div>
    </div>
  {{/each}}
</div>```

### **./frontend/photo-filter-frontend/app/components/date-nav.hbs**
```
{{! app/components/date-nav.hbs }}

<ul class="menu p-0 w-full">
  {{! Top-level: list each year }}
  {{#each @datesDataSorted as |yearObj|}}
    <li>
      <div class="flex flex-row items-center justify-between">
        <button
          class="rounded px-2 py-1 w-full text-left"
          {{on "click" (fn this.toggleYear yearObj.year)}}
        >
          {{yearObj.year}}
          ({{yearObj.count}}
          photos)
        </button>
        {{! Just a small indicator to show expanded/collapsed }}
        <span>
          {{if (contains yearObj.year this.expandedYears) "➖" "➕"}}
        </span>
      </div>

      {{#if (contains yearObj.year this.expandedYears)}}
        {{! Show months }}
        <ul class="ml-4 mt-1">
          {{#each yearObj.monthsSorted as |monthObj|}}
            <li>
              <div class="flex flex-row items-center justify-between">
                <button
                  class="rounded px-2 py-1 w-full text-left"
                  {{on
                    "click"
                    (fn this.toggleMonth yearObj.year monthObj.month)
                  }}
                >
                  {{monthObj.monthName}}
                  ({{monthObj.count}})
                </button>
                <span>
                  {{if
                    (contains
                      (concat yearObj.year "-" monthObj.month)
                      this.expandedMonths
                    )
                    "➖"
                    "➕"
                  }}
                </span>
                {{! If clicked, jump directly to the route for all photos in this month }}
                <a
                  class="text-blue-700 underline ml-2"
                  {{on
                    "click"
                    (fn this.goToYearMonth yearObj.year monthObj.month)
                  }}
                  title="View entire month"
                >
                  View
                </a>
              </div>
              {{#if
                (contains
                  (concat yearObj.year "-" monthObj.month) this.expandedMonths
                )
              }}
                {{! Show days }}
                <ul class="ml-4 mt-1">
                  {{#each monthObj.daysSorted as |dayObj|}}
                    <li class="flex flex-row items-center justify-between">
                      <button
                        class="rounded px-2 py-1 w-full text-left"
                        {{on
                          "click"
                          (fn
                            this.goToYearMonthDay
                            yearObj.year
                            monthObj.month
                            dayObj.day
                          )
                        }}
                      >
                        {{dayObj.day}}
                        ({{dayObj.count}})
                      </button>
                    </li>
                  {{/each}}
                </ul>
              {{/if}}
            </li>
          {{/each}}
        </ul>
      {{/if}}
    </li>
  {{/each}}
</ul>```

### **./frontend/photo-filter-frontend/app/components/date-nav.js**
```
// app/components/date-nav.js
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';
import { inject as service } from '@ember/service';
import dayjs from 'dayjs'; // (Optional) If you want fancy month names

/**
 * date-nav
 *
 * Takes @datesData (the summary from /api/dates) and displays
 * a nested tree of years → months → days. Allows toggling each node.
 */
export default class DateNavComponent extends Component {
  @service router;

  // Arrays of expanded IDs
  @tracked expandedYears = [];
  @tracked expandedMonths = [];

  // By default, expand the current day (today)
  constructor() {
    super(...arguments);

    // If you want to auto-expand "today" in the tree:
    const now = new Date();
    const thisYear = String(now.getFullYear());
    const thisMonth = String(now.getMonth() + 1).padStart(2, '0');
    this.expandedYears = [thisYear];
    this.expandedMonths = [`${thisYear}-${thisMonth}`];
  }

  /**
   * Convert the @datesData object into an array of objects for easier iteration/sorting.
   * The shape from the server is { "2024": { count, months: { "12": {...} } }, ... }
   */
  get datesDataSorted() {
    if (!this.args.datesData) return [];

    // We transform:
    // {
    //   "2024": { count: 123, months: { "01": { count: 40, days: {"01": {count: 5}, ...} } }, ... }
    //   "2023": ...
    // }
    // into an array of { year, count, months: [...] } sorted descending by year
    const result = Object.keys(this.args.datesData)
      .map((yearStr) => {
        const yearBlock = this.args.datesData[yearStr];
        return {
          year: yearStr,
          count: yearBlock.count,
          months: yearBlock.months,
        };
      })
      .sort((a, b) => Number(b.year) - Number(a.year)); // newest year first

    return result.map((yearObj) => {
      const monthsSorted = Object.keys(yearObj.months)
        .map((m) => {
          const monthData = yearObj.months[m];
          return {
            month: m,
            monthName: this.monthName(m), // optional human-friendly name
            count: monthData.count,
            days: monthData.days,
          };
        })
        // sort numeric descending or ascending
        .sort((a, b) => Number(a.month) - Number(b.month));

      const monthsWithDays = monthsSorted.map((m) => {
        const daysSorted = Object.keys(m.days)
          .map((d) => {
            return { day: d, count: m.days[d].count };
          })
          .sort((a, b) => Number(a.day) - Number(b.day));
        return { ...m, daysSorted };
      });

      return {
        ...yearObj,
        monthsSorted: monthsWithDays,
      };
    });
  }

  monthName(monthStr) {
    // monthStr is "01", "02", ...
    // If you want a short label, or dayjs, or a custom table:
    const m = Number(monthStr);
    // Here we just do a simple table:
    const names = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ];
    return names[m - 1] || monthStr;
  }

  // Expand/collapse years
  @action
  toggleYear(year) {
    if (this.expandedYears.includes(year)) {
      this.expandedYears = this.expandedYears.filter((y) => y !== year);
    } else {
      this.expandedYears = [...this.expandedYears, year];
    }
  }

  // Expand/collapse a specific month
  @action
  toggleMonth(year, month) {
    const id = `${year}-${month}`;
    if (this.expandedMonths.includes(id)) {
      this.expandedMonths = this.expandedMonths.filter((x) => x !== id);
    } else {
      this.expandedMonths = [...this.expandedMonths, id];
    }
  }

  // When user clicks “View entire month”
  @action
  goToYearMonth(year, month) {
    this.router.transitionTo('dates.year.month', year, month);
  }

  // When user clicks on a day
  @action
  goToYearMonthDay(year, month, day) {
    this.router.transitionTo('dates.year.month.day', year, month, day);
  }

  // Utility used in the template to see if an array includes a value
  contains(val, arr) {
    return arr.includes(val);
  }
}
```

### **./frontend/photo-filter-frontend/app/components/photo-grid.js**
```
import Component from '@glimmer/component';
import config from 'photo-filter-frontend/config/environment';

/**
 * PhotoGrid Component
 *
 * Arguments:
 * - @photos: An array of photo objects.
 * - @albumUUID: The album's UUID for constructing image URLs.
 * - @sortAttribute: The current sorting attribute to display values for.
 */
export default class PhotoGridComponent extends Component {
  get apiHost() {
    return config.APP.apiHost;
  }
}
```

### **./frontend/photo-filter-frontend/app/router.js**
```
// app/router.js
import EmberRouter from '@ember/routing/router';
import config from './config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  // Existing route for albums
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });

  // NEW date-based routes
  this.route('dates', function () {
    this.route('year', { path: '/:year' }, function () {
      this.route('month', { path: '/:month' }, function () {
        this.route('day', { path: '/:day' });
      });
    });
  });
});
```

### **./frontend/photo-filter-frontend/app/templates/dates/year/month/day.hbs**
```
<!-- app/templates/dates/year/month/day.hbs -->
<h2 class="text-xl font-bold mb-2">
  Photos from
  {{@model.year}}-{{this.padMonth @model.month}}-{{@model.day}}
</h2>

<!-- People Filter UI -->
<div class="mb-4 space-x-2">
  {{#each this.model.persons as |personName|}}
    <button
      type="button"
      class="btn btn-xs
        {{if (contains personName this.persons) 'btn-primary' 'btn-outline'}}"
      {{on "click" (fn this.togglePerson personName)}}
    >
      {{personName}}
    </button>
  {{/each}}
</div>

<!-- Sorting UI -->
<div class="flex items-center space-x-4 mb-4">
  <div>
    <label>Sort by:</label>
    <select {{on "change" this.updateSortAttribute}} value={{this.sort}}>
      {{#each this.model.scoreAttributes as |attr|}}
        <option
          value={{concat "score." attr}}
          selected={{eq (concat "score." attr) this.sort}}
        >
          {{attr}}
        </option>
      {{/each}}
    </select>
  </div>

  <div>
    <label>Order:</label>
    <select {{on "change" this.updateSortOrder}} value={{this.order}}>
      <option value="desc" selected={{eq this.order "desc"}}>Desc</option>
      <option value="asc" selected={{eq this.order "asc"}}>Asc</option>
    </select>
  </div>
</div>

<!-- Photo Grid -->
<PhotoGrid
  @photos={{this.visiblePhotos}}
  @albumUUID={{null}}
  @sortAttribute={{this.sort}}
/>

{{#if (gt (this.filteredSortedPhotos.length) (this.visiblePhotos.length))}}
  <button class="btn btn-secondary mt-4" {{on "click" this.loadMore}}>
    Load More
  </button>
{{/if}}```

### **./frontend/photo-filter-frontend/app/templates/dates/year/month.hbs**
```
<h2 class="text-xl font-bold mb-2">
  Photos from
  {{@model.year}}-{{this.padMonth @model.month}}
</h2>
<PhotoGrid
  @photos={{@model.photos}}
  @albumUUID={{null}}
  @sortAttribute="score.overall"
/>```

### **./frontend/photo-filter-frontend/app/templates/dates/year.hbs**
```
<!-- app/templates/dates/year.hbs -->
<h2 class="text-xl font-bold mb-2">Photos from {{@model.year}}</h2>

<!-- People Filter UI (optional) -->
<div class="mb-4 space-x-2">
  {{#each this.model.persons as |personName|}}
    <button
      type="button"
      class="btn btn-xs
        {{if (contains personName this.persons) 'btn-primary' 'btn-outline'}}"
      {{on "click" (fn this.togglePerson personName)}}
    >
      {{personName}}
    </button>
  {{/each}}
</div>

<!-- Sorting UI -->
<div class="flex items-center space-x-4 mb-4">
  <div>
    <label>Sort by:</label>
    <select {{on "change" this.updateSortAttribute}} value={{this.sort}}>
      {{#each this.model.scoreAttributes as |attr|}}
        <option
          value={{concat "score." attr}}
          selected={{eq (concat "score." attr) this.sort}}
        >
          {{attr}}
        </option>
      {{/each}}
    </select>
  </div>

  <div>
    <label>Order:</label>
    <select {{on "change" this.updateSortOrder}} value={{this.order}}>
      <option value="desc" selected={{eq this.order "desc"}}>Desc</option>
      <option value="asc" selected={{eq this.order "asc"}}>Asc</option>
    </select>
  </div>
</div>

<!-- Photo Grid -->
<PhotoGrid
  @photos={{this.visiblePhotos}}
  @albumUUID={{null}}
  @sortAttribute={{this.sort}}
/>

<!-- "Load More" if you want pagination -->
{{#if (gt (this.filteredSortedPhotos.length) (this.visiblePhotos.length))}}
  <button class="btn btn-secondary mt-4" {{on "click" this.loadMore}}>
    Load More
  </button>
{{/if}}```

### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
{{! app/templates/albums/album.hbs }}
<h2 class="text-xl font-bold mb-2">Photos in {{this.model.album.title}}</h2>

{{! Person toggles (already in your code) }}
<div class="flex justify-center mb-4 flex-wrap gap-2">
  {{#each this.model.persons as |person|}}
    <button
      type="button"
      class="btn btn-xs
        {{if (contains person this.persons) 'btn-primary' 'btn-outline'}}"
      {{on "click" (fn this.togglePerson person)}}
    >
      {{person}}
    </button>
  {{/each}}
</div>

{{! Add a section for Sorting }}
<div class="flex items-center gap-4 mb-4">
  <div>
    <label for="sortSelect">Sort by:</label>
    <select
      id="sortSelect"
      {{on "change" this.updateSortAttribute}}
      value={{this.sort}}
    >
      {{#each this.model.scoreAttributes as |attr|}}
        <option
          value={{concat "score." attr}}
          selected={{eq (concat "score." attr) this.sort}}
        >
          {{attr}}
        </option>
      {{/each}}
    </select>
  </div>

  <div>
    <label for="orderSelect">Order:</label>
    <select
      id="orderSelect"
      {{on "change" this.updateSortOrder}}
      value={{this.order}}
    >
      <option value="desc" selected={{eq this.order "desc"}}>Desc</option>
      <option value="asc" selected={{eq this.order "asc"}}>Asc</option>
    </select>
  </div>
</div>

<PhotoGrid
  @photos={{this.visiblePhotos}}
  @albumUUID={{this.model.albumUUID}}
  @sortAttribute={{this.sort}}
/>```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
{{! app/templates/application.hbs }}
{{page-title "PhotoFilterFrontend"}}

<div
  class="h-screen w-screen overflow-hidden bg-base-200 text-base-content relative"
>
  <!-- In a production app, you might place a top nav here or hide it -->

  <div class="flex h-full pt-16">
    {{! Single left sidebar, Apple Photos–style }}
    <aside
      class="w-64 bg-gray-100 border-r border-gray-300 h-full overflow-y-auto p-4"
    >
      <h2 class="text-lg font-bold mb-4">Photo Filter</h2>

      {{! Albums Section }}
      <h3
        class="menu-title text-sm font-semibold uppercase tracking-wide text-gray-500 mb-2"
      >
        Albums
      </h3>
      <ul class="menu p-0 w-full mb-6">
        {{#each this.albums as |album|}}
          <li>
            <LinkTo
              @route="albums.album"
              @model={{album.id}}
              class="hover:bg-gray-200 px-2 py-1 rounded"
            >
              {{album.title}}
            </LinkTo>
          </li>
        {{/each}}
      </ul>

      {{! Dates Section }}
      <h3
        class="menu-title text-sm font-semibold uppercase tracking-wide text-gray-500 mb-2"
      >
        Dates
      </h3>
      <DateNav @datesData={{this.dateTree}} />

      {{! Future expansions: People, Places, Shared Albums, etc. }}
      {{!
      <h3 class="menu-title">People</h3>
      <ul> ... </ul>
      <h3 class="menu-title">Places</h3>
      <ul> ... </ul>
      }}
    </aside>

    {{! Main content area }}
    <main id="main-content-area" class="flex-1 overflow-auto p-4">
      {{outlet}}
    </main>
  </div>
</div>```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
{{! BEGIN: app/templates/albums/album.hbs }}

<h2 class="text-xl font-bold mb-2">Photos in {{this.model.album.title}}</h2>

{{! Person toggles }}
<div class="flex justify-center mb-4 flex-wrap gap-2">
  {{#each this.model.persons as |person|}}
    <button
      type="button"
      class="btn btn-xs
        {{if (contains person this.persons) 'btn-primary' 'btn-outline'}}"
      {{action "togglePerson" person}}
    >
      {{person}}
    </button>
  {{/each}}
</div>

{{! Sorting UI }}
<div class="flex items-center gap-4 mb-4">
  <div>
    <label for="sortSelect">Sort by:</label>
    <select
      id="sortSelect"
      onchange={{action "updateSortAttribute"}}
      value={{this.sort}}
    >
      {{#each this.model.scoreAttributes as |attr|}}
        <option
          value={{concat "score." attr}}
          selected={{eq (concat "score." attr) this.sort}}
        >
          {{attr}}
        </option>
      {{/each}}
    </select>
  </div>

  <div>
    <label for="orderSelect">Order:</label>
    <select
      id="orderSelect"
      onchange={{action "updateSortOrder"}}
      value={{this.order}}
    >
      <option value="desc" selected={{eq this.order "desc"}}>Desc</option>
      <option value="asc" selected={{eq this.order "asc"}}>Asc</option>
    </select>
  </div>
</div>

{{! Photo grid component }}
<PhotoGrid
  @photos={{this.visiblePhotos}}
  @albumUUID={{this.model.albumUUID}}
  @sortAttribute={{this.sort}}
/>

{{! END: app/templates/albums/album.hbs }}```

### **./frontend/photo-filter-frontend/app/controllers/dates/year.js**
```
// app/controllers/dates/year.js
import { inject as service } from '@ember/service';
import PhotoCollectionController from 'photo-filter-frontend/controllers/photo-collection';

export default class DatesYearController extends PhotoCollectionController {
  @service router;

  queryParams = [
    'sort',
    'order',
    {
      persons: {
        serialize(value) {
          return JSON.stringify(value);
        },
        deserialize(value) {
          if (typeof value === 'string') {
            try {
              return JSON.parse(value);
            } catch {
              return [];
            }
          }
          return value || [];
        },
      },
    },
  ];

  /**
   * Called whenever we change sorting or person filters. We then re-transition
   * to the same route, with updated query params in the URL.
   */
  _updateRouteQueryParams(params) {
    const { year } = this.router.currentRoute.params;
    this.router.transitionTo('dates.year', year, {
      queryParams: params,
    });
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/dates/year/month/day.js**
```
// app/controllers/dates/year/month/day.js
import { inject as service } from '@ember/service';
import PhotoCollectionController from 'photo-filter-frontend/controllers/photo-collection';

export default class DatesYearMonthDayController extends PhotoCollectionController {
  @service router;

  queryParams = [
    'sort',
    'order',
    {
      persons: {
        serialize(value) {
          return JSON.stringify(value);
        },
        deserialize(value) {
          if (typeof value === 'string') {
            try {
              return JSON.parse(value);
            } catch {
              return [];
            }
          }
          return value || [];
        },
      },
    },
  ];

  /**
   * Called whenever we change sorting or person filters. We then re-transition
   * to the same route, with updated query params in the URL.
   */
  _updateRouteQueryParams(params) {
    const { year, month, day } = this.router.currentRoute.params;
    this.router.transitionTo('dates.year.month.day', year, month, day, {
      queryParams: params,
    });
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/dates/year/month.js**
```
// app/controllers/dates/year/month.js
import { inject as service } from '@ember/service';
import PhotoCollectionController from 'photo-filter-frontend/controllers/photo-collection';

export default class DatesYearMonthController extends PhotoCollectionController {
  @service router;

  queryParams = [
    'sort',
    'order',
    {
      persons: {
        serialize(value) {
          return JSON.stringify(value);
        },
        deserialize(value) {
          if (typeof value === 'string') {
            try {
              return JSON.parse(value);
            } catch {
              return [];
            }
          }
          return value || [];
        },
      },
    },
  ];

  /**
   * Called whenever we change sorting or person filters. We then re-transition
   * to the same route, with updated query params in the URL.
   */
  _updateRouteQueryParams(params) {
    const { year, month } = this.router.currentRoute.params;
    this.router.transitionTo('dates.year.month', year, month, {
      queryParams: params,
    });
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/photo-collection.js**
```
// app/controllers/photo-collection.js
import Controller from '@ember/controller';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';

/**
 * A reusable base controller for any "collection of photos" route.
 * It handles:
 *  - sorting (sort=score.overall or whatever)
 *  - ordering (asc/desc)
 *  - person filtering
 *  - pagination
 *
 * Subclasses must:
 *  1) Provide a `this.model.photos` array in route model
 *  2) Provide `this.model.persons` (if you want person toggles)
 *  3) Implement `_updateRouteQueryParams(params)` to call router.transitionTo
 */
export default class PhotoCollectionController extends Controller {
  // QueryParam-like states:
  @tracked sort = 'score.overall';
  @tracked order = 'desc';
  @tracked persons = [];

  @tracked page = 1;
  pageSize = 50;

  get allPhotos() {
    // model should have: { photos, isDataReady, persons, scoreAttributes }
    if (!this.model?.isDataReady || !Array.isArray(this.model.photos)) {
      return [];
    }
    return this.model.photos;
  }

  get filteredSortedPhotos() {
    let photos = this.allPhotos.slice();

    // Person filtering
    if (this.persons.length > 0) {
      photos = photos.filter((photo) => {
        // photo.persons is an array of either strings or {name: string}
        const names = photo.persons.map((p) => p.name ?? p);
        return this.persons.every((selectedName) =>
          names.includes(selectedName),
        );
      });
    }

    // Sorting
    photos.sort((a, b) => {
      const aVal = this.getNested(a, this.sort);
      const bVal = this.getNested(b, this.sort);
      if (aVal == null) return 1;
      if (bVal == null) return -1;
      return this.order === 'asc' ? aVal - bVal : bVal - aVal;
    });

    return photos;
  }

  get visiblePhotos() {
    const start = (this.page - 1) * this.pageSize;
    const end = this.page * this.pageSize;
    return this.filteredSortedPhotos.slice(start, end);
  }

  getNested(obj, path) {
    if (!obj || !path) return null;
    return path.split('.').reduce((acc, key) => acc?.[key], obj);
  }

  @action
  togglePerson(personName) {
    let selected = [...this.persons];
    if (selected.includes(personName)) {
      selected = selected.filter((p) => p !== personName);
    } else {
      selected.push(personName);
    }
    this.persons = selected;
    this.page = 1;

    this._updateRouteQueryParams({
      sort: this.sort,
      order: this.order,
      persons: this.persons,
    });
  }

  @action
  updateSortAttribute(event) {
    this.sort = event.target.value;
    this.page = 1;

    this._updateRouteQueryParams({
      sort: this.sort,
      order: this.order,
      persons: this.persons,
    });
  }

  @action
  updateSortOrder(event) {
    this.order = event.target.value;
    this.page = 1;

    this._updateRouteQueryParams({
      sort: this.sort,
      order: this.order,
      persons: this.persons,
    });
  }

  @action
  loadMore() {
    if (this.visiblePhotos.length < this.filteredSortedPhotos.length) {
      this.page++;
    }
  }

  /**
   * Subclasses implement how to do the route transition.
   * E.g. in albums, we do:
   *   this.router.transitionTo('albums.album', albumId, { queryParams: {...} });
   * In dates, we do:
   *   this.router.transitionTo('dates.year', year, { queryParams: {...} });
   */
  _updateRouteQueryParams(_params) {
    // no-op by default
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/application.js**
```
// app/controllers/application.js
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';

export default class ApplicationController extends Controller {
  @service router;
  @service currentAlbum;

  // New tracked properties to store fetched data
  @tracked albums = [];
  @tracked dateTree = {};

  // Keep your existing code
  @action
  updateSortAttribute(event) {
    const newSort = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: newSort,
              order: this.currentAlbum.sortOrder,
            },
          },
        );
      }
    }
  }

  @action
  updateSortOrder(event) {
    const newOrder = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: this.currentAlbum.sortAttribute,
              order: newOrder,
            },
          },
        );
      }
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
// app/controllers/albums/album.js

import { inject as service } from '@ember/service';
import Controller from '@ember/controller';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';
import { A } from '@ember/array'; // for array handling if needed

export default class AlbumsAlbumController extends Controller {
  @service router;

  // Query params
  queryParams = [
    'sort',
    'order',
    {
      persons: {
        serialize(value) {
          return JSON.stringify(value);
        },
        deserialize(value) {
          if (typeof value === 'string') {
            try {
              return JSON.parse(value);
            } catch {
              return [];
            }
          }
          return value || [];
        },
      },
    },
  ];

  // Tracked properties for sort/order/persons
  @tracked sort = 'score.overall';
  @tracked order = 'desc';
  @tracked persons = A([]);

  page = 1;
  pageSize = 50;

  get allPhotos() {
    const photos = this.model?.photos || [];
    return photos;
  }

  get filteredSortedPhotos() {
    // Person filtering
    let results = this.allPhotos.slice();
    if (this.persons.length > 0) {
      results = results.filter((photo) => {
        const names = photo.persons.map((p) => p.name ?? p);
        return this.persons.every((selectedName) =>
          names.includes(selectedName),
        );
      });
    }
    // Sorting
    results.sort((a, b) => {
      const aVal = this._getNested(a, this.sort);
      const bVal = this._getNested(b, this.sort);
      if (aVal == null) return 1;
      if (bVal == null) return -1;
      return this.order === 'asc' ? aVal - bVal : bVal - aVal;
    });
    return results;
  }

  get visiblePhotos() {
    const start = (this.page - 1) * this.pageSize;
    const end = this.page * this.pageSize;
    return this.filteredSortedPhotos.slice(start, end);
  }

  // Classic actions hash:
  actions = {
    togglePerson(personName) {
      let selected = this.persons.slice();
      if (selected.includes(personName)) {
        selected = selected.filter((p) => p !== personName);
      } else {
        selected.push(personName);
      }
      this.persons = A(selected);
      this.page = 1;
      this._updateRouteQueryParams();
    },

    updateSortAttribute(event) {
      this.sort = event.target.value;
      this.page = 1;
      this._updateRouteQueryParams();
    },

    updateSortOrder(event) {
      this.order = event.target.value;
      this.page = 1;
      this._updateRouteQueryParams();
    },
  };

  // Let’s keep the route transition logic separate
  _updateRouteQueryParams() {
    this.router.transitionTo(
      'albums.album',
      this.router.currentRoute.params.album_id,
      {
        queryParams: {
          sort: this.sort,
          order: this.order,
          persons: this.persons,
        },
      },
    );
  }

  _getNested(obj, path) {
    if (!obj || !path) return null;
    return path.split('.').reduce((acc, key) => acc?.[key], obj);
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/dates/index.js**
```
// app/routes/dates/index.js
import Route from '@ember/routing/route';

/**
 * If user goes to /dates with no further segments,
 * we could redirect them somewhere (e.g., the current year),
 * or just show an empty “Choose a year” message.
 */
export default class DatesIndexRoute extends Route {}
```

### **./frontend/photo-filter-frontend/app/routes/dates/year.js**
```
// app/routes/dates/year.js
import Route from '@ember/routing/route';
import fetch from 'fetch';

export default class DatesYearRoute extends Route {
  async model(params) {
    const {
      year,
      sort = 'score.overall',
      order = 'desc',
      persons = [],
    } = params;

    const response = await fetch(`http://localhost:3000/api/dates/${year}`);
    const json = await response.json();
    const photos = json.data || [];

    // Figure out scoreAttributes by checking the first photo
    let scoreAttributes = [];
    if (photos.length > 0 && photos[0].score) {
      scoreAttributes = Object.keys(photos[0].score);
    }

    // Figure out all distinct person names
    const allPersons = new Set();
    for (let photo of photos) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p.name ?? p));
      }
    }
    // Sort them if you like
    const sortedAllPersons = Array.from(allPersons).sort();

    return {
      year,
      photos,
      scoreAttributes,
      persons: sortedAllPersons,
      isDataReady: true,
    };
  }

  // Then define queryParams in a dedicated controller/dates/year.js as shown above
}
```

### **./frontend/photo-filter-frontend/app/routes/dates/year/month/day.js**
```
// app/routes/dates/year/month/day.js
import Route from '@ember/routing/route';
import fetch from 'fetch';

/**
 * /dates/:year/:month/:day => show all photos for that exact day
 */
export default class DatesYearMonthDayRoute extends Route {
  async model(params) {
    const { year, month, day } = params;
    const response = await fetch(
      `http://localhost:3000/api/dates/${year}/${month}/${day}`,
    );
    const json = await response.json();
    return {
      year,
      month,
      day,
      photos: json.data || [],
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/dates/year/month.js**
```
// app/routes/dates/year/month.js
import Route from '@ember/routing/route';
import fetch from 'fetch';

export default class DatesYearMonthRoute extends Route {
  queryParams = {
    sort: { refreshModel: true },
    order: { refreshModel: true },
    persons: { refreshModel: true },
  };

  async model(params) {
    const { year, month } = params;

    const response = await fetch(
      `http://localhost:3000/api/dates/${year}/${month}`,
    );
    const json = await response.json();
    const photos = json.data || [];

    let scoreAttributes = [];
    if (photos.length > 0 && photos[0].score) {
      scoreAttributes = Object.keys(photos[0].score);
    }

    const allPersons = new Set();
    for (let photo of photos) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p.name ?? p));
      }
    }
    const sortedAllPersons = Array.from(allPersons).sort();

    return {
      year,
      month,
      photos,
      scoreAttributes,
      persons: sortedAllPersons,
      isDataReady: true,
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// app/routes/index.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service router;

  beforeModel() {
    this.router.replaceWith('albums');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/dates.js**
```
// app/routes/dates.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';
import fetch from 'fetch';

/**
 * The top-level /dates route fetches the summary from /api/dates,
 * so we can build the collapsible nav. This route *does not* fetch actual photos.
 */
export default class DatesRoute extends Route {
  @service store;

  async model() {
    // fetch the year→month→day summary from the backend
    const response = await fetch('http://localhost:3000/api/dates');
    const json = await response.json();
    return json.data; // e.g. { "2024": {count:..., months:{...}}, ... }
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/application.js**
```
// app/routes/application.js
import Route from '@ember/routing/route';
import fetch from 'fetch';

export default class ApplicationRoute extends Route {
  async model() {
    // 1. Fetch Albums from our backend
    let albumsResponse = await fetch('http://localhost:3000/api/albums');
    let albumsJson = await albumsResponse.json();

    // 2. Fetch Date Tree (year→month→day summary)
    let datesResponse = await fetch('http://localhost:3000/api/dates');
    let datesJson = await datesResponse.json();

    return {
      // JSON:API usually has an array in albumsJson.data
      albums: albumsJson.data || [],
      // The date summary is in datesJson.data
      dateTree: datesJson.data || {},
    };
  }

  setupController(controller, model) {
    super.setupController(controller, model);
    // Push these arrays/objects onto the application controller’s tracked properties
    controller.albums = model.albums; // => this.albums in template
    controller.dateTree = model.dateTree; // => this.dateTree in template
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
// frontend/photo-filter-frontend/app/routes/albums/album.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;
  @service currentAlbum;

  queryParams = {
    sort: {},
    order: {},
    persons: {
      // Custom serialize/deserialize so persons is always an array
      serialize(value) {
        return JSON.stringify(value);
      },
      deserialize(value) {
        if (typeof value === 'string') {
          try {
            const arr = JSON.parse(value);
            return arr;
          } catch (e) {
            return [];
          }
        }
        return value || [];
      },
    },
  };

  async model(params) {
    const {
      album_id,
      sort = 'score.overall',
      order = 'desc',
      persons = [],
    } = params;

    // Fetch the album record and persons in one go (async: false means all included data is ready)
    const album = await this.store.findRecord('album', album_id, {
      include: 'persons', // This ensures persons are included in the album payload
      reload: true,
    });

    const loadedPersons = album.persons;
    const allPersons = loadedPersons.map((person) => person.name);

    // Fetch all photos once, including included persons
    const allPhotos = await this.store.query('photo', {
      album_id,
    });

    // Since async: false is set on photo.persons and album.persons, we have all data now.
    // No need to reload anything. The included payload gave us all persons upfront.

    // Determine score attributes
    let scoreAttributes = [];
    if (allPhotos.meta && allPhotos.meta.scoreAttributes) {
      scoreAttributes = allPhotos.meta.scoreAttributes;
    } else if (allPhotos.length > 0 && allPhotos.firstObject.score) {
      scoreAttributes = Object.keys(allPhotos.firstObject.score);
    }

    // Sort persons by how many times they appear in the photos
    const personCountMap = {};
    allPhotos.forEach((photo) => {
      // photo.persons is already resolved since async: false
      photo.persons.forEach((p) => {
        personCountMap[p.name] = (personCountMap[p.name] || 0) + 1;
      });
    });

    const sortedAllPersons = allPersons.sort((a, b) => {
      const countA = personCountMap[a] || 0;
      const countB = personCountMap[b] || 0;
      if (countB !== countA) return countB - countA;
      return a.localeCompare(b);
    });

    // Update currentAlbum service
    this.currentAlbum.isAlbumRoute = true;
    this.currentAlbum.albumTitle = album.title;
    this.currentAlbum.scoreAttributes = scoreAttributes;
    this.currentAlbum.sortAttribute = sort;
    this.currentAlbum.sortOrder = order;

    // Data is fully ready, no reload needed
    const isDataReady = true;

    return {
      album,
      photos: allPhotos,
      albumUUID: allPhotos.meta?.albumUUID || album_id,
      sortAttribute: sort,
      sortOrder: order,
      scoreAttributes,
      persons: sortedAllPersons,
      selectedPersons: persons,
      isDataReady,
    };
  }

  resetController(controller, isExiting) {
    super.resetController(...arguments);
    if (isExiting) {
      // Reset currentAlbum service when leaving the album route
      this.currentAlbum.isAlbumRoute = false;
      this.currentAlbum.albumTitle = null;
      this.currentAlbum.scoreAttributes = [];
      this.currentAlbum.sortAttribute = 'score.overall';
      this.currentAlbum.sortOrder = 'desc';
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/eq.js**
```
// frontend/photo-filter-frontend/app/helpers/eq.js

import { helper } from '@ember/component/helper';

export default helper(function eq([a, b]) {
  return a === b;
});
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/contains.js**
```
import { helper } from '@ember/component/helper';

export default helper(function contains([item, array]) {
  return array.includes(item);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/current-album.js**
```
import Service from '@ember/service';
import { tracked } from '@glimmer/tracking';

export default class CurrentAlbumService extends Service {
  @tracked isAlbumRoute = false;
  @tracked albumTitle = null;
  @tracked scoreAttributes = [];
  @tracked sortAttribute = 'score.overall';
  @tracked sortOrder = 'desc';
  @tracked persons = [];
}
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

### **./frontend/photo-filter-frontend/config/optional-features.json**
```
{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    historySupportMiddleware: true, // enable for ember-router-scroll
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {},
    },

    APP: {
      apiHost: 'http://localhost:3000',
    },

    // Add routerScroll configuration here
    routerScroll: {
      targetElement: '#main-content-area',
    },
  };

  if (environment === 'development') {
    // ...
  }

  if (environment === 'test') {
    ENV.locationType = 'none';
    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // ...
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": ["--ci-provider=github"]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/-package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "dependencies": {
        "postcss": "^8.4.49"
      },
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/string": "^4.0.0",
        "@ember/test-helpers": "^3.3.1",
        "@glimmer/component": "^1.1.2",
...
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
// frontend/photo-filter-frontend/tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from '../helpers/index.js';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('visiting /albums and viewing an album', async function (assert) {
    await visit('/albums');

    assert.strictEqual(currentURL(), '/albums');
    assert.dom('h1').hasText('Select an Album');

    const albumLinks = findAll('a');
    assert.ok(albumLinks.length > 0, 'There are album links');

    // Click the first album link
    await click(albumLinks[0]);

    // The URL should change to the album route
    assert.ok(currentURL().startsWith('/albums/'), 'Navigated to album route');

    // Check that photos are displayed
    assert.dom('.photo-grid').exists('Photo grid is displayed');
    assert
      .dom('.photo-item')
      .exists({ count: 1 }, 'At least one photo is displayed');

    // Check that images have loaded
    assert.dom('.photo-item img').exists('Photo image is displayed');
  });
});
```

### **./frontend/photo-filter-frontend/tests/helpers/index.js**
```
import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file exists to provide wrappers around ember-qunit's
// test setup functions. This way, you can easily extend the setup that is
// needed per test type.

function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // Additional setup for application tests can be done here.
  //
  // For example, if you need an authenticated session for each
  // application test, you could do:
  //
  // hooks.beforeEach(async function () {
  //   await authenticateSession(); // ember-simple-auth
  // });
  //
  // This is also a good place to call test setup functions coming
  // from other addons:
  //
  // setupIntl(hooks, 'en-us'); // ember-intl
  // setupMirage(hooks); // ember-cli-mirage
}

function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);

  // Additional setup for rendering tests can be done here.
}

function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);

  // Additional setup for unit tests can be done here.
}

export { setupApplicationTest, setupRenderingTest, setupTest };
```

### **./frontend/photo-filter-frontend/README.md**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "dependencies": {
        "dayjs": "^1.11.13",
        "postcss": "^8.4.49"
      },
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/render-modifiers": "^2.1.0",
        "@ember/string": "^4.0.0",
...
```

### **./frontend/photo-filter-frontend/package.json**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Photo Filter Frontend",
  "scripts": {
    "build": "ember build --environment=production",
    "start": "ember serve",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "dependencies": {
    "dayjs": "^1.11.13",
    "postcss": "^8.4.49"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@ember/optional-features": "^2.1.0",
    "@ember/render-modifiers": "^2.1.0",
    "@ember/string": "^4.0.0",
    "@ember/test-helpers": "^3.3.1",
    "@glimmer/component": "^1.1.2",
    "@glimmer/tracking": "^1.1.2",
    "@html-next/vertical-collection": "^4.0.2",
    "autoprefixer": "^10.4.20",
    "broccoli-asset-rev": "^3.0.0",
    "concurrently": "^8.2.2",
    "daisyui": "^4.12.22",
    "ember-auto-import": "^2.8.1",
    "ember-cli": "~5.12.0",
    "ember-cli-app-version": "^7.0.0",
    "ember-cli-babel": "^8.2.0",
    "ember-cli-clean-css": "^3.0.0",
    "ember-cli-dependency-checker": "^3.3.2",
    "ember-cli-htmlbars": "^6.3.0",
    "ember-cli-inject-live-reload": "^2.1.0",
    "ember-cli-postcss": "^8.2.0",
    "ember-cli-sri": "^2.1.1",
    "ember-cli-terser": "^4.0.2",
    "ember-data": "~5.3.8",
    "ember-fetch": "^8.1.2",
    "ember-load-initializers": "^2.1.2",
    "ember-modifier": "^4.2.0",
    "ember-page-title": "^8.2.3",
    "ember-qunit": "^8.1.0",
    "ember-resolver": "^12.0.1",
    "ember-router-scroll": "^4.1.2",
    "ember-source": "~5.12.0",
    "ember-template-lint": "^6.0.0",
    "ember-welcome-page": "^7.0.2",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-ember": "^12.2.1",
    "eslint-plugin-n": "^16.6.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-qunit": "^8.1.2",
    "loader.js": "^4.7.0",
    "prettier": "^3.3.3",
    "qunit": "^2.22.0",
    "qunit-dom": "^3.2.1",
    "sass": "^1.83.0",
    "stylelint": "^15.11.0",
    "stylelint-config-standard": "^34.0.0",
    "stylelint-prettier": "^4.1.0",
    "tailwindcss": "^3.4.16",
    "tracked-built-ins": "^3.3.0",
    "webpack": "^5.95.0"
  },
  "engines": {
    "node": ">= 18"
  },
  "ember": {
    "edition": "octane"
  }
}
```

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
```

### **./frontend/photo-filter-frontend/.eslintrc.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
```

### **./frontend/photo-filter-frontend/postcss.config.js**
```
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

