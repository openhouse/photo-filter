# Project Overview: Photo Filter
-e 
Generated on: Sat Dec 14 15:37:59 EST 2024

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── DEVELOPMENT_PLAN.md
├── ISSUES.md
├── README.md
├── backend
│   ├── .DS_Store
│   ├── .babelrc
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── index.js
│   │   │   ├── people-controller.js
│   │   │   └── photos-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   ├── people-legacy-controller.js
│   │   └── photo-controller.js
│   ├── data
│   │   ├── albums
│   │   │   ├── .DS_Store
│   │   │   ├── 16BC5397-4A87-49A1-8404-85D6473F3931
│   │   │   │   └── photos.json
│   │   │   ├── 6956E064-5A0E-4451-8A75-FC6724FED866
│   │   │   │   └── photos.json
│   │   │   ├── 69865EDF-08F2-40B1-8E20-F802D6C4E6D3
│   │   │   │   └── photos.json
│   │   │   ├── 918451EC-C6A5-416D-B919-D23AE46FEBBF
│   │   │   │   └── photos.json
│   │   │   └── D3988A5F-8B66-464B-B18C-457EC672621A
│   │   │       └── photos.json
│   │   └── albums.json
│   ├── jest.config.js
│   ├── models
│   │   └── photoModel.js
│   ├── osxphotos_crash.log
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── test_albums.json
│   ├── tests
│   │   └── controllers
│   │       └── api
│   │           ├── albums-controller.test.js
│   │           └── photos-controller.test.js
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── export-images.js
│   │   ├── get-photos-library-last-modified.js
│   │   ├── helpers.js
│   │   └── run-python-script.js
│   ├── views
│   │   ├── albums.hbs
│   │   ├── index.hbs
│   │   ├── layouts
│   │   │   └── main.hbs
│   │   ├── person.hbs
│   │   └── persons.hbs
│   └── yarn.lock
├── frontend
│   └── photo-filter-frontend
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── README.md
│       ├── app
│       │   ├── adapters
│       │   │   ├── application.js
│       │   │   └── photo.js
│       │   ├── app.js
│       │   ├── components
│       │   │   ├── .gitkeep
│       │   │   ├── photo-grid.hbs
│       │   │   └── photo-grid.js
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   └── albums
│       │   │       ├── album
│       │   │       │   └── persons
│       │   │       └── album.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── contains.js
│       │   │   ├── eq.js
│       │   │   ├── get-nested-property.js
│       │   │   └── replace.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   ├── person.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   └── index.js
│       │   ├── services
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.css
│       │   └── templates
│       │       ├── albums
│       │       │   ├── album
│       │       │   │   └── persons
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       └── application.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package-lock.json
│       ├── package.json
│       ├── postcss.config.js
│       ├── public
│       │   └── robots.txt
│       ├── tailwind.config.js
│       ├── testem.js
│       ├── tests
│       │   ├── acceptance
│       │   │   └── albums-test.js
│       │   ├── helpers
│       │   │   └── index.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       └── yarn.lock
├── generate-overview.sh
├── osxphotos_crash.log
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
└── top_photo_uuids.txt

60 directories, 127 files
```

---

## Root-Level Files

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

### December 14, 2024: Tailwind & DaisyUI Integration Update

**Decision & Implementation:**

- Removed `@import` of Tailwind CSS files in `app.scss` and replaced them with:
  ```scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  ```

## Update: Transition to Query-Param-Based Faceted Person Filtering

**Date:** December 12, 2024

### Decision

- Move from nested person-specific routes toward a unified album route that uses query parameters to filter by selected individuals.
- The UI will display a list of people in the left navigation under the currently active album. Users can toggle individuals on or off (via checkboxes or links), and the album’s displayed photos will filter to include only photos with all selected individuals.
- Remove the separate "View People in this Album" link and the “Back to Albums” link, as album navigation and person filtering are now integrated in the left nav.
- Eventually incorporate a front-end UI framework (like Bootstrap or Material Design) for a more cohesive look and feel.

### Rationale

- **Integrated Navigation**: Having all filtering (by album, by people) and sorting in one unified route simplifies the user experience.
- **Improved UX**: No need to navigate to a separate persons sub-route. People-based filtering is just another facet of the main album view.
- **Scalability**: Query params enable easy multi-person filtering. As the user selects multiple names, they appear in the URL’s query params, making the filtering state shareable and bookmarkable.
- **Future-Ready**: Paves the way to easily add other facets (like tags, locations, or events) as query-parameter-based filters.

### Implementation Steps

1. **Remove Person Sub-Routes**:

   - No longer need `albums/album/persons` or `albums/album/persons/person/:person_name`.
   - Instead, retrieve people from `GET /api/albums/:albumUUID/persons` and display them under the selected album in the left nav.

2. **Update Album Route to Use Query Params**:

   - Add a `people` query param to `albums.album`.
   - When a user toggles a person in the UI, update the `people` query param to reflect the currently selected individuals.
   - Filter photos based on the intersection of all selected individuals’ sets of photos.

3. **UI Updates**:

   - The left nav becomes scrollable and fixed in height, independent from the main content area.
   - Display the currently selected album title, below it a list of people. Each name toggles inclusion in the `people` filter.
   - No need for “Back to Albums” or “View People in This Album” links—navigation and filtering are seamlessly integrated.

4. **Backend**:

   - The backend remains largely the same. The frontend can still fetch all people via `GET /api/albums/:albumUUID/persons`.
   - For multiple individuals, the frontend will combine their names and request photos containing all of them, or request the full set and filter on the client side if needed. (Future optimization may be added on the backend.)

5. **Documentation**:

   - Update `DEVELOPMENT_PLAN.md`, `ISSUES.md`, and `README.md` to reflect the new approach.
   - Document how query parameters represent the filtering state.

6. **Testing and Validation**:
   - Ensure that selecting multiple individuals updates the displayed photos correctly.
   - Confirm that query params can be bookmarked and reloaded.
   - Test sorting combined with person-based filtering.

### Potential Challenges

- **Complex Filtering**: As multiple people are selected, performance could degrade for large albums. Consider caching or indexing if needed.
- **UI Complexity**: Need a clear indication of which people are currently selected and how to reset filters.
- **Backwards Compatibility**: Removing person sub-routes may require updating links or references.

---

## Previous Updates

- **December 7, 2024**: Initial person-level sub-routes conceived.  
  _Note:_ This approach is now evolving into a unified, query-param-based filter.
- **November 12, 2024**: Introduced nested routes, left nav, and sorting.
- **November 1, 2024**: Added cache invalidation for data freshness.
- **October 30, 2024**: Adopted JSON:API serializer.

---

## Project Goal

Create an intuitive, facet-based photo exploration tool integrated with macOS Photos data, enabling advanced sorting, selection, exporting, and multi-person filtering.

## Current State

- **Frontend**: Ember.js with album-level sorting, person-based filters pending refinement.
- **Backend**: Express.js, JSON:API, data from `osxphotos`.
- **Data Handling**: `osxphotos` extracts metadata.
- **Selection & Export**: In progress.
- **Documentation & Styling**: Ongoing enhancements.

## Next Steps

1. **Implement Multi-Person Filtering with Query Params**:

   - Refactor UI to remove separate person routes.
   - Add toggles in the left nav.
   - Update the album route’s model hook to factor in `people` query param.

2. **Improve Export Feature**:

   - Integrate actual export logic on the backend.
   - Show feedback to the user during export operations.

3. **UX and Performance**:

   - Consider a UI framework for styling.
   - Explore caching large album queries.

4. **Testing & Quality Assurance**:

   - Test multi-person filtering thoroughly.
   - Validate sorting and selection persistence.

5. **Documentation & Cleanup**:
   - Keep all documentation updated.
   - Refactor code for maintainability.

---
```

### **./ISSUES.md**
```
# Issues and Resolutions

This file logs open issues and their statuses. Update it as new issues arise and existing ones progress.

---

## Issue 16: PostCSS "File not found: /app/styles/app.css" Error

**Opened By:** Jamie, Dec 14, 2024  
**Status:** In Progress

### Description

Encountered a build error because PostCSS didn’t find `app.css` after SCSS changes.

### Actions

- Installed `ember-cli-sass` to compile `app.scss` into `app.css`.
- Updated `app.scss` to use `@tailwind` directives instead of `@import`.
- (Alternative) Renamed `app.scss` to `app.css` and removed `ember-cli-sass`.

### Next Steps

- Verify build succeeds (`ember serve`).
- If successful, mark as Resolved after testing in production-like scenarios.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name], Nov 12, 2024  
**Status:** **Resolved**

### Description

`albums/album` route’s template not rendering correctly.

### Resolution

- Added `{{outlet}}` to `albums.hbs`.
- Verified proper rendering.

---

## Issue 14: 404 Error When Fetching Album Data

**Opened By:** [Your Name], Nov 10, 2024  
**Status:** **Resolved**

### Description

`GET /api/albums/:albumUUID` returned 404.

### Resolution

- Implemented `GET /api/albums/:albumUUID`.
- Confirmed endpoint now works as expected.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need multi-photo selection persistence across sorting and filtering changes.

### Actions

- Created `selection.js` service to manage selected photos.
- Selections persist when changing sort order or navigating within the album.

### Next Steps

- Integrate with multi-person filtering now that filtering is query-param-based.
- Ensure that selected photos remain selected as users toggle people filters.
- Write more comprehensive tests for selection persistence.

---

## Issue 9: Adding Actions for Selected Photos (Export Functionality)

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need to export selected photos from the backend once chosen on the frontend.

### Actions

- Created `/api/photos/export` endpoint.
- Frontend can send selected photo IDs to initiate export.
- Basic user alerts implemented to inform the user of export status.

### Next Steps

- Implement actual export logic on the backend.
- Add progress indicators (e.g., a progress bar) in the UI.
- Validate that exported filenames handle duplicates properly.

---

## Issue 16: Filename Collisions in Exports

**Opened By:** [Your Name], Dec 11, 2024  
**Status:** **Open** (Reopened Dec 12, 2024)

### Description

When exporting images, sometimes duplicate filenames occur.

### Current Approach

- Prepend date/time to filenames.
- Append counters for duplicates.

### Next Steps

- Confirm that this approach truly prevents collisions.
- Test extensively in a real environment before marking resolved.

---

## Newly Considered Issue: Replacing Person Sub-Routes with Query Params

**Opened By:** [Your Name], Dec 12, 2024  
**Status:** **In Planning**

### Description

We initially implemented `albums/album/persons` sub-routes. We now want to remove them in favor of query params on the main album route. This will unify navigation and filtering, removing the need for “Back” or “View People” links.

### Actions

- Update `DEVELOPMENT_PLAN.md` to reflect query-param-based person filtering.
- Adjust frontend UI to list people under the album in the left nav.
- Remove old person sub-route code once the new system is tested.

### Next Steps

- Implement toggles for people in the sidebar.
- Update the album route model hook to filter photos by selected people.
- Fully test the new approach.

---

## Issue 17: Persons Not Appearing in Album UI

**Opened By:** [Your Name], Dec 13, 2024  
**Status:** **Open**

### Description

Even though the backend returns `persons` as included data when fetching an album, they do not appear in the UI. In Ember Inspector, we see that `album.persons` is present, but on the active controller, `persons` remains empty. This occurs because `album.persons` is a PromiseManyArray and must be awaited before using its data. Without awaiting, the code tries to read `persons` before they are fully loaded, resulting in an empty array being used for the UI.

### Actions

- In `app/routes/albums/album.js`, await the `album.persons` before mapping or filtering.
  For example:
  ```js
  const loadedPersons = await album.persons;
  const allPersons = loadedPersons.map((person) => person.name);
  ```

Next Steps
• Make this code change and verify that persons now appear in the UI as expected.
• Once verified and tested in reality, mark this issue as resolved.

End of Issues Log

Note: No issue should be marked resolved until verified in reality. Keep documenting any uncertainties or performance concerns.
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application. It enables browsing, filtering, and exporting photos from your macOS Photos library.

## Project Structure

- **backend/**: Express.js backend application.
- **frontend/**: Ember.js frontend application.
- **DEVELOPMENT_PLAN.md**: Roadmap and implementation details.
- **ISSUES.md**: Issues, debugging steps, and resolutions.
- **project-guidelines.md**: Collaboration and coding standards.

## Features

- **Album Navigation**: Browse albums via a left-side navigation column.
- **Photo Display**: View photos in selected albums with various sort options.
- **Faceted Person-Based Filtering**:  
  Under the currently active album, see a list of all recognized people.
  - **Single Person Filter**: Click one person’s name to display only photos with that individual.
  - **Multiple People Filter**: Select additional names to narrow photos down to those containing _all_ the chosen individuals, enabling powerful faceted search.
- **Sorting**: Sort photos by various attributes (e.g., aesthetic scores).
- **Photo Selection**: Select multiple photos; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Freshness

- The backend checks for changes in the Photos library.
- Cache invalidation ensures up-to-date album and photo data.

## Performance and Optimization

- JSON:API compliance for seamless Ember Data integration.
- Plans to implement lazy loading and indexing for improved performance.

## UI/UX

- Nested routes (`{{outlet}}`) for clarity.
- Future enhancements include more intuitive multi-person selection interfaces and better export feedback.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter

   2.	Backend Setup:
   ```

cd backend
npm install
npm run setup
npm run dev

    3.	Frontend Setup:

Open a new terminal window:

cd frontend/photo-filter-frontend
npm install
npm run start

    4.	Access the Application:

Visit http://localhost:4200.

Contributing
• Use clear and descriptive commit messages.
• Track issues in ISSUES.md.
• Follow guidelines in project-guidelines.md.

Testing
• Backend: Use Jest for tests (npm run test in backend/).
• Frontend: Use Ember CLI testing (npm run test in frontend/).

License

This project is licensed under the MIT License.
```

### **./project-guidelines.md**
```
Project Guidelines

Table of Contents

- Project Philosophy
- Keeping Up with Dependencies
- Data Formats
- Data Synchronization and Caching
- Ensuring Complete Project Overviews
- Coding Standards
- Naming Conventions
- Directory Structure
- Documentation Practices
- Privacy and Data Handling
- Project State and Continuity
- Issue Tracking and Debugging
- Collaboration Guidelines
- Environment and Dependency Management
- Error Handling and Logging
- Security Best Practices
- Testing
- Deployment and Operations
- Performance Optimization

---

## Project Philosophy

- User-Centric Design, Interactivity, Clarity, Modularity, Consistency.
- Ember.js Conventions: Follow Ember.js patterns.
- Privacy, Security, Performance, Scalability.
- Embrace Iterative Understanding: Treat solutions as provisional and open to revision.

## Keeping Up with Dependencies

- Stay informed of the latest versions and updates.
- Test thoroughly after upgrading dependencies.
- Document changes and version notes.

## Data Formats

- Use JSON:API for backend/frontend integration.
- Utilize `jsonapi-serializer` on the backend.

## Data Synchronization and Caching

- Implement cache invalidation using timestamps.
- Balance data freshness with performance.

## Ensuring Complete Project Overviews

- Include all relevant files in generated overviews.
- Update `generate-overview.sh` as the project evolves.
- Regularly review project-overview.txt for accuracy.

## Coding Standards

- Consistent indentation (2 spaces).
- camelCase for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- Avoid globals; use modules.
- Follow Ember.js coding conventions where applicable.

## Naming Conventions

- Dasherized filenames (e.g., `photo-controller.js`).
- Descriptive and concise filenames.

## Directory Structure

- `backend/`: Express.js server and APIs
- `frontend/`: Ember.js app
- `data/`, `exports/`, `scripts/`, `utils/`, `tests/`
- Keep structure organized and consistent.

## Documentation Practices

- Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`.
- Use inline code comments and JSDoc.
- Maintain a changelog and consider `ARCHITECTURE.md` for big-picture decisions.
- Include “Questions to Consider” to highlight uncertainties.

## Privacy and Data Handling

- Do not store personal data in git.
- Be transparent about data processing.

## Project State and Continuity

- Self-contained documentation.
- Reflect current state, pending tasks, and future plans within the project files.

## Issue Tracking and Debugging

- Log issues in `ISSUES.md`.
- Document steps taken and current status.
- **Do Not Mark Issues as Resolved Until Verified**:  
  **No issue should be marked as "Resolved" until the fix is actually applied by the real person managing the system, and tested to confirm it works in reality.**
- Use "Uncertain" tags if needed to highlight unresolved aspects.
- Treat resolutions as provisional truths.

## Collaboration Guidelines

- Communicate clearly and concisely.
- Provide full file replacements for verifiable changes.
- Keep project composed of smaller files for easy copy-paste integration.
- Include clear commit messages.

## Environment and Dependency Management

- Use `.nvmrc` for Node.js versions.
- Keep dependencies updated and tested.
- Store config in environment variables.
- Adhere to JSON:API specs to ensure frontend-backend compatibility.

## Error Handling and Logging

- Implement robust error handling in async code.
- Provide meaningful error messages.
- Use logging for debugging and monitoring.

## Security Best Practices

- No sensitive info in version control.
- Validate/sanitize user inputs.
- Use environment variables for credentials.

## Testing

- Comprehensive test coverage: unit, integration, acceptance.
- Use Jest (backend) and Ember CLI testing tools (frontend).
- Mock external dependencies.
- Write tests alongside code changes.
- Keep tests reliable and maintainable.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configs.
- Monitor performance and errors in production.

## Performance Optimization

- Optimize large dataset handling.
- Use caching and lazy loading.
- Profile resource usage.
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/test_albums.json**
```
{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle 🎞️ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour — People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie ◍ Jamie": 4976, "Dominic ◍ Jamie": 4415, "Rosa Menkman ◍ Jamie Burkart": 2821, "Transfer ◍ Jamie Burkart": 2821, "Sondy ◍ Jamie": 2542, "Chad ◍ Jamie": 1830, "Lera Tarasenko ◍ Jamie Burkart": 1636, "Mir ◍ 196 Artists Residency": 1156, "Carper ◍ Burkart": 717, "Lydia ◍ Jamie": 380, "Jessi ◍ Mike ◍ Jamie": 347, "Jack ◍ Jamie": 332, "Lera Show ◍ Jamie Burkart": 310, "Patrick Weaver ◍ Jamie Burkart": 162, "Hayley ◍ Jamie": 149, "Claudette ◍ Jamie": 143, "Greta ◍ Shan ◍ Jamie": 137, "Zhen Li ◍ Jamie Burkart": 83, "Bobby ◍ Madeleine ◍ Jamie": 60, "Abby ◍ Jamie": 57, "Isabel Santos ◍ Jamie Burkart": 50, "Laura Mattingly ◍ Jamie Burkart": 45, "Thor ◍ Jamie": 35, "Stewart ◍ Jamie": 29, "Jessi ◍ Jamie Fashion Concepts &;-)": 26, "Gabi ◍ Michael ◍ Jamie": 17, "Melody ◍ Jamie": 13, "Michael ◍ Jamie": 9, "Em Gift ◍ Jamie Burkart": 1, "Bridget ◍ Jamie": 0}}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
```

### **./backend/utils/run-python-script.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
```

### **./backend/utils/exec-command.js**
```
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/utils/helpers.js**
```
// backend/utils/helpers.js

export function getNestedProperty(obj, propertyPath) {
  if (!propertyPath || typeof propertyPath !== "string") {
    return null;
  }
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

export function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

export function capitalizeAttributeName(attributeName) {
  const nameParts = attributeName.split(".");
  const lastPart = nameParts[nameParts.length - 1];
  return lastPart
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
```

### **./backend/utils/export-images.js**
```
// backend/utils/export-images.js

import fs from "fs-extra";
import path from "path";
import { execCommand } from "./exec-command.js";

/**
 * Export images using osxphotos for a given album.
 * @param {string} osxphotosPath - Path to the osxphotos executable in the virtualenv.
 * @param {string} albumUUID - The UUID of the album to export.
 * @param {string} imagesDir - The directory to which images will be exported.
 * @param {string} photosPath - The path to the photos.json file.
 */
export async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use a date/time prefix and original_name directly via osxphotos template:
  // {created.strftime,%Y%m%d-%H%M%S}-{original_name}
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{created.strftime,%Y%m%d-%H%M%S}-{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

/**
 * Safely get a nested property from an object.
 * @param {object} obj - The object to retrieve the property from.
 * @param {string} propertyPath - The dot-separated path (e.g. "score.overall").
 * @returns {*} - The property value or null if not found.
 */
export function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/models/photoModel.js**
```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

### **./backend/package-lock.json**
```json
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-backend",
      "version": "1.0.0",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "cors": "^2.8.5",
        "express": "^4.21.1",
        "fs-extra": "^11.2.0",
        "jsonapi-serializer": "^3.6.7"
      },
      "devDependencies": {
        "concurrently": "^9.0.1",
        "jest": "^29.7.0",
...
```

### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/setup.js**
```
// ./scripts/setup.js

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

(async () => {
  try {
    const venvDir = path.join(process.cwd(), "venv");
    const venvPython = path.join(venvDir, "bin", "python3");
    const venvPip = path.join(venvDir, "bin", "pip");

    // Use Python 3.11 explicitly
    const pythonExecutable = "python3.11";

    // Check if virtual environment exists
    const venvExists = await fs.pathExists(venvPython);

    if (!venvExists) {
      console.log(
        `Creating Python virtual environment with ${pythonExecutable}...`
      );
      await execAsync(`${pythonExecutable} -m venv venv`);
      console.log("Virtual environment created.");
    } else {
      console.log("Virtual environment already exists, ready to collaborate.");
    }

    // Install or upgrade osxphotos
    console.log(
      "Inviting osxphotos to join the project by installing or upgrading it..."
    );
    await execAsync(`"${venvPip}" install --upgrade osxphotos`);
    console.log("osxphotos is now part of the team.");

    console.log("Setup completed successfully, all components are in place.");
  } catch (error) {
    console.error("Setup encountered an issue:", error);
    process.exit(1);
  }
})();
```

### **./backend/controllers/api-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );

      // After exporting, rename files to prepend the photo's capture date
      await renameExportedImages(imagesDir, photosPath);
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Rename exported images with date-based filenames
async function renameExportedImages(imagesDir, photosPath) {
  const photosData = await fs.readJson(photosPath);

  for (const photo of photosData) {
    const originalName = path.parse(photo.original_filename).name; // e.g., DSCF1191
    const photoDate = new Date(photo.date); // Parse the photo’s date field
    const formattedDate = formatPhotoDate(photoDate); // YYYYMMDD-HHMMSS
    const oldPath = path.join(imagesDir, `${originalName}.jpg`);

    if (await fs.pathExists(oldPath)) {
      let newFilename = `${formattedDate}-${originalName}.jpg`;
      let finalPath = path.join(imagesDir, newFilename);

      // Check for collisions
      let counter = 1;
      while (await fs.pathExists(finalPath)) {
        newFilename = `${formattedDate}-${originalName}-${counter}.jpg`;
        finalPath = path.join(imagesDir, newFilename);
        counter++;
      }

      await fs.rename(oldPath, finalPath);
      console.log(`Renamed ${originalName}.jpg to ${newFilename}`);
    } else {
      console.warn(`File not found for rename: ${oldPath}`);
    }
  }
}

// Format the photo date as YYYYMMDD-HHMMSS
function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/people-legacy-controller.js**
```
// backend/controllers/people-legacy-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { getNestedProperty } from "../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Show all people in an album
export const getPeopleInAlbumLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Gather all distinct people
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    const people = Array.from(allPersons).sort();

    // Render persons.hbs view
    res.render("persons", { albumUUID, people });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Show photos of a single person in the album
export const getPhotosByPersonLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by person
    const filteredPhotos = photosData.filter((photo) => {
      return Array.isArray(photo.persons) && photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      // No photos of this person
      return res.render("person", {
        albumUUID,
        personName,
        photos: [],
        scoreAttributes: [],
        sortAttribute,
        sortOrder,
      });
    }

    // Add original_name property
    filteredPhotos.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from the first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort photos based on the requested attribute
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Render person.hbs view
    res.render("person", {
      albumUUID,
      personName,
      photos: filteredPhotos,
      scoreAttributes,
      sortAttribute,
      sortOrder,
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
```

### **./backend/controllers/api/albums-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const AlbumSerializer = new Serializer("album", {
  id: "uuid",
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
  relationships: {
    persons: {
      type: "person",
    },
  },
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    await fs.ensureDir(dataDir);

    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    const albumsData = await fs.readJson(albumsPath);
    const jsonApiData = AlbumSerializer.serialize(albumsData);
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    const albumsData = await fs.readJson(albumsPath);
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    let persons = [];
    if (await fs.pathExists(photosPath)) {
      const photosData = await fs.readJson(photosPath);
      const allPersons = new Set();
      photosData.forEach((photo) => {
        if (Array.isArray(photo.persons)) {
          photo.persons.forEach((name) => allPersons.add(name));
        }
      });
      persons = Array.from(allPersons).map((name) => {
        return {
          id: slugifyName(name),
          name: name,
        };
      });
    }

    const albumRecord = {
      uuid: album.uuid,
      title: album.title,
    };

    let albumJsonApi = AlbumSerializer.serialize(albumRecord);
    albumJsonApi.data.relationships = albumJsonApi.data.relationships || {};
    albumJsonApi.data.relationships.persons = {
      data: persons.map((p) => ({ type: "person", id: p.id })),
    };

    const personJsonApi = PersonSerializer.serialize(persons);

    const merged = {
      data: albumJsonApi.data,
      included: personJsonApi.data,
      meta: {},
    };

    res.json(merged);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/api/index.js**
```
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/people-controller.js**
```
// backend/controllers/api/people-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
    "persons",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

// List all people in an album
export const getPeopleInAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Extract all persons from all photos
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    res.json({ data: Array.from(allPersons) });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Get photos of a specific person in the album
export const getPhotosByPerson = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by personName
    const filteredPhotos = photosData.filter((photo) => {
      if (!Array.isArray(photo.persons)) return false;
      return photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      return res.json({
        data: [],
        meta: {
          albumUUID,
          personName,
          sortAttribute,
          sortOrder,
          scoreAttributes: [],
        },
      });
    }

    // Add originalName property
    filteredPhotos.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    filteredPhotos.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(filteredPhotos);

    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        personName,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";
import { runOsxphotosExportImages } from "../../utils/export-images.js";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// We'll define two serializers: one for person and one for photo.
const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "exportedFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
    persons: {
      type: "person",
    },
  },
  pluralizeType: false,
  meta: {}, // We'll add meta later
});

function formatPhotoDateWithOffset(dateString) {
  const match = dateString.match(
    /^(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2}(?:\.\d+)?)([\+\-]\d{2}:\d{2})$/
  );
  if (!match) {
    return fallbackFormat(new Date(dateString));
  }

  const datePart = match[1];
  const timePart = match[2];

  const [year, month, day] = datePart.split("-").map(Number);
  const [hour, minute, secondRaw] = timePart.split(":");
  const hourNum = Number(hour);
  const minuteNum = Number(minute);
  const secondNum = Math.floor(Number(secondRaw));

  const YYYY = String(year);
  const MM = String(month).padStart(2, "0");
  const DD = String(day).padStart(2, "0");
  const HH = String(hourNum).padStart(2, "0");
  const mm = String(minuteNum).padStart(2, "0");
  const ss = String(secondNum).padStart(2, "0");

  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

function fallbackFormat(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' and 'exportedFilename'
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
      const prefix = formatPhotoDateWithOffset(photo.date);
      photo.exportedFilename = `${prefix}-${photo.originalName}.jpg`;
      if (!Array.isArray(photo.persons)) {
        photo.persons = [];
      }
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Handle person relationships
    const uniquePersons = new Map();
    function slugifyName(name) {
      return name
        .toLowerCase()
        .replace(/[\s+]/g, "-")
        .replace(/[^a-z0-9-]/g, "");
    }

    photosData.forEach((photo) => {
      photo.personsData = [];
      photo.persons.forEach((name) => {
        const slug = slugifyName(name);
        if (!uniquePersons.has(slug)) {
          uniquePersons.set(slug, { id: slug, name });
        }
        photo.personsData.push({ type: "person", id: slug });
      });
    });

    // Serialize photos
    const jsonApiPhotoData = PhotoSerializer.serialize(photosData);

    // Serialize persons
    const personsArray = Array.from(uniquePersons.values());
    const jsonApiPersonData = PersonSerializer.serialize(personsArray);

    // Merge included resources
    const merged = {
      data: jsonApiPhotoData.data,
      included: jsonApiPersonData.data,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    };

    // Link persons to photos
    merged.data.forEach((photo) => {
      const originalPhoto = photosData.find((p) => p.uuid === photo.id);
      if (
        originalPhoto &&
        originalPhoto.personsData &&
        originalPhoto.personsData.length > 0
      ) {
        if (!photo.relationships) {
          photo.relationships = {};
        }
        photo.relationships.persons = {
          data: originalPhoto.personsData,
        };
      } else {
        if (photo.relationships && photo.relationships.persons) {
          photo.relationships.persons = { data: [] };
        }
      }
    });

    res.json(merged);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";
import plist from "plist";
import { exec } from "child_process";
import os from "os";
import { createRequire } from "module";
import {
  getNestedProperty,
  capitalizeAttributeName,
} from "../utils/helpers.js";

const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images with osxphotos (directly uses date/time prefix)
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 60;

    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    const photoTags = {};

    attributesToProcess.forEach(({ name, order, limit }) => {
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);
        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;
        return order === "asc" ? aValue - bValue : bValue - aValue;
      });

      const topPhotos = sortedPhotos.slice(0, limit);
      topPhotos.forEach((photo) => {
        if (!photoTags[photo.uuid]) {
          photoTags[photo.uuid] = [];
        }
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photo.uuid].includes(attributeDisplayName)) {
          photoTags[photo.uuid].push(attributeDisplayName);
        }
      });
    });

    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort the photos by requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);
      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;
      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];
    if (tags.length === 0) continue;

    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
```

### **./backend/data/albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums/918451EC-C6A5-416D-B919-D23AE46FEBBF/photos.json**
```json
[
    {
        "albums": [
            "Sheep"
        ],
        "burst": false,
        "cloud_guid": "AbkiIdG7V0IzR4NfC4f4B8JslwNm",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2022-11-06 11:52:19.752600-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2022-11-06 17:52:18.936800+01:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1600,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/69865EDF-08F2-40B1-8E20-F802D6C4E6D3/photos.json**
```json
[
    {
        "albums": [
            "2024-12-11-Last Month",
            "Anna Pompermaier",
            "Austria",
            "Cenk G\u00fczelis",
            "FujiFilm x100v: All, Full Res",
            "Innsbruck, Austria",
            "Recent Month",
            "Recent Week",
            "Studio3",
            "Studio3 Symposium",
            "Studio3 Symposium \u2014\u00a0IRL"
        ],
        "burst": false,
        "cloud_guid": "AYxUYDskCQ/gPyKyTSQOsTKDO0qz",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-15 11:48:30.564913-05:00",
...
```

### **./backend/data/albums/16BC5397-4A87-49A1-8404-85D6473F3931/photos.json**
```json
[
    {
        "albums": [
            "2024-12-11-Last Month"
        ],
        "burst": false,
        "cloud_guid": "AUe3MMiGEMSXiJQFq+RdRUZ6gohE",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 21:54:44.122153-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 21:54:43.398000-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 2000,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/6956E064-5A0E-4451-8A75-FC6724FED866/photos.json**
```json
[
    {
        "albums": [
            "2024-12-09",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res"
        ],
        "burst": false,
        "cloud_guid": "AbZe/Yx1gH5bPgoyi7FqXRZz8YrC",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 16:58:31.698262-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 11:03:56-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 320,
            "metering_mode": 5,
...
```

### **./backend/data/albums/D3988A5F-8B66-464B-B18C-457EC672621A/photos.json**
```json
[
    {
        "albums": [
            "2024-12-01-day",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res",
            "Max & Jamie",
            "Mir & Max",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AQucx0r2Z1j5VHamAkpTY4+F+3fP",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-30 20:35:09.221502-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 19:07:52-05:00",
        "description": null,
        "exif_info": {
...
```

### **./backend/views/albums.hbs**
```
<h1 class="text-3xl font-bold mb-4">Select an Album</h1>

<div class="flex flex-row h-screen">
  <!-- Sidebar -->
  <div
    class="w-64 bg-base-100 border-r border-base-300 h-full overflow-y-auto p-4"
  >
    <ul class="menu w-full">
      {{#each this.model as |album|}}
        <li class="mb-1">
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-base-300"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <div class="flex-1 p-6">
    {{outlet}}
  </div>
</div>```

### **./backend/views/index.hbs**
```
<!-- backend/views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a> | 
<a href="/album/{{albumUUID}}/persons">View People in this Album</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.exported_filename}}"
        alt="{{this.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.exported_filename}}

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/layouts/main.hbs -->


<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/views/person.hbs**
```
<!-- ./views/person.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos of {{personName}} in Album</h1>
<a href="/album/{{albumUUID}}/persons">Back to People</a>

<form method="GET" action="/album/{{albumUUID}}/person/{{personName}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{photo.exported_filename}}"
        alt="{{photo.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{photo.exported_filename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property photo ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/persons.hbs**
```
<!-- ./views/persons.hbs -->

<h1>People in Album</h1>
<a href="/album/{{albumUUID}}">Back to Album</a>

<ul>
  {{#each people as |person|}}
    <li><a href="/album/{{../albumUUID}}/person/{{person}}">{{person}}</a></li>
  {{/each}}
</ul>```

### **./backend/routes/index.js**
```
// backend/routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";
import {
  getPeopleInAlbumLegacy,
  getPhotosByPersonLegacy,
} from "../controllers/people-legacy-controller.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// New legacy routes for persons
router.get("/album/:albumUUID/persons", getPeopleInAlbumLegacy);
router.get("/album/:albumUUID/person/:personName", getPhotosByPersonLegacy);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
// backend/routes/api.js

import express from "express";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";

// Import the new people controllers
import {
  getPeopleInAlbum,
  getPhotosByPerson,
} from "../controllers/api/people-controller.js";

const apiRouter = express.Router();

// API route to get all albums
apiRouter.get("/albums", getAlbumsData);

// API route to get a single album by UUID
apiRouter.get("/albums/:albumUUID", getAlbumById);

// API route to get photos by album UUID
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

// API routes for people in an album
apiRouter.get("/albums/:albumUUID/persons", getPeopleInAlbum);
apiRouter.get("/albums/:albumUUID/person/:personName", getPhotosByPerson);

export default apiRouter;
```

## Frontend Files

### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  let app = new EmberApp(defaults, {
    postcssOptions: {
      compile: {
        enabled: true,
        plugins: [
          require('tailwindcss')('./tailwind.config.js'),
          require('autoprefixer'),
        ],
      },
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/tailwind.config.js**
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.hbs',
    './app/**/*.js',
    './app/**/*.ts',
    './app/**/*.gjs',
    './app/**/*.gts',
  ],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
};
```

### **./frontend/photo-filter-frontend/app/models/person.js**
```
// frontend/photo-filter-frontend/app/models/person.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class PersonModel extends Model {
  @attr('string') name;
  @hasMany('photo', { async: true, inverse: 'persons' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
// frontend/photo-filter-frontend/app/models/album.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: true, inverse: 'album' }) photos;
  @hasMany('person', { async: true, inverse: null }) persons; // persons now included, inverse set to null
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
// frontend/photo-filter-frontend/app/models/photo.js
import Model, { attr, belongsTo, hasMany } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr('string') exportedFilename;
  @attr() score;
  @attr() exifInfo;

  @belongsTo('album', { async: true, inverse: 'photos' }) album;
  @hasMany('person', { async: true, inverse: 'photos' }) persons;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```

### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/components/photo-grid.hbs**
```
<div class="grid gap-6 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
  {{#each @photos as |photo index|}}
    <div class="card bg-base-100 shadow-lg">
      <figure>
        <img
          src="{{this.apiHost}}/images/{{@albumUUID}}/{{photo.exportedFilename}}"
          alt="{{photo.exportedFilename}}"
          class="max-w-full h-auto"
        />
      </figure>
      <div class="card-body">
        <h2 class="card-title text-sm">
          <span class="opacity-50">{{index}} -</span>
          {{photo.exportedFilename}}
        </h2>

        {{#if photo.tags}}
          <div class="mt-2 flex flex-wrap gap-2">
            {{#each photo.tags as |tag|}}
              <span class="badge badge-accent badge-outline">{{tag}}</span>
            {{/each}}
          </div>
        {{/if}}

        <p class="mt-2">
          {{capitalize (replace @sortAttribute "score." "")}}:
          {{get-nested-property photo @sortAttribute}}
        </p>
      </div>
    </div>
  {{/each}}
</div>```

### **./frontend/photo-filter-frontend/app/components/photo-grid.js**
```
import Component from '@glimmer/component';
import config from 'photo-filter-frontend/config/environment';

/**
 * PhotoGrid Component
 *
 * Arguments:
 * - @photos: An array of photo objects.
 * - @albumUUID: The album's UUID for constructing image URLs.
 * - @sortAttribute: The current sorting attribute to display values for.
 */
export default class PhotoGridComponent extends Component {
  get apiHost() {
    return config.APP.apiHost;
  }
}
```

### **./frontend/photo-filter-frontend/app/router.js**
```
import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });
});
```

### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
<div class="flex h-screen">

  <!-- Sidebar -->
  <div
    class="fixed top-0 left-0 w-64 bg-base-100 border-r border-base-300 h-screen overflow-y-auto p-4"
  >
    <ul class="menu p-0 w-full">
      {{#each this.model as |album|}}
        <li>
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-base-300 px-2 py-1"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <!-- Main content area -->
  <div class="flex-1 ml-64 p-6">
    {{outlet}}
  </div>

</div>```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
{{page-title "PhotoFilterFrontend"}}

<div class="min-h-screen flex flex-col bg-base-200 text-base-content">
  <nav class="navbar bg-base-100 shadow mb-4">
    <div class="flex-1">
      <a class="btn btn-ghost normal-case text-xl" href="/">Photo Filter</a>
    </div>
    <div class="flex-none">
      <!-- Future nav items could go here -->
    </div>
  </nav>

  <div class="container mx-auto px-4 flex-1">
    {{outlet}}
  </div>
</div>```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
<h1 class="text-2xl font-bold mb-4">{{this.model.album.title}}</h1>

<div class="flex items-center justify-between mb-4">
  <div class="text-lg font-semibold">{{this.model.album.title}}</div>
  <div class="flex items-center space-x-4">

    <!-- Sort by attribute -->
    <div class="form-control">
      <label class="label text-sm font-semibold">Sort by</label>
      <select
        id="sortAttribute"
        class="select select-bordered select-sm"
        {{on "change" this.selectSortAttribute}}
      >
        {{#each this.model.scoreAttributes as |attribute|}}
          <option
            value="score.{{attribute}}"
            selected={{eq this.sort (concat "score." attribute)}}
          >
            {{capitalize attribute}}
          </option>
        {{/each}}
      </select>
    </div>

    <!-- Order (asc/desc) -->
    <div class="form-control">
      <label class="label text-sm font-semibold">Order</label>
      <select
        id="sortOrder"
        class="select select-bordered select-sm"
        {{on "change" this.selectSortOrder}}
      >
        <option
          value="desc"
          selected={{eq this.order "desc"}}
        >Descending</option>
        <option value="asc" selected={{eq this.order "asc"}}>Ascending</option>
      </select>
    </div>
  </div>
</div>

<!-- Person filters -->
<div class="flex justify-center mb-6 flex-wrap gap-2">
  {{#each this.model.persons as |person|}}
    <button
      type="button"
      class="btn btn-sm rounded-full px-4 normal-case
        {{if
          (contains person this.persons)
          'btn-accent text-white'
          'btn-outline'
        }}"
      {{on "click" (fn this.togglePerson person)}}
    >
      {{person}}
    </button>
  {{/each}}
</div>

<PhotoGrid
  @photos={{this.model.photos}}
  @albumUUID={{this.model.albumUUID}}
  @sortAttribute={{this.model.sortAttribute}}
/>```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
// frontend/photo-filter-frontend/app/controllers/albums/album.js
import Controller from '@ember/controller';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';

export default class AlbumsAlbumController extends Controller {
  queryParams = ['sort', 'order', 'persons'];

  @tracked sort = 'score.overall';
  @tracked order = 'desc';
  @tracked persons = [];

  @action
  selectSortAttribute(event) {
    this.sort = event.target.value;
  }

  @action
  selectSortOrder(event) {
    this.order = event.target.value;
  }

  @action
  togglePerson(personName) {
    let selected = [...this.persons];
    if (selected.includes(personName)) {
      selected = selected.filter((p) => p !== personName);
    } else {
      selected.push(personName);
    }
    this.persons = selected;
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// app/routes/index.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service router;

  beforeModel() {
    this.router.replaceWith('albums');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
// frontend/photo-filter-frontend/app/routes/albums/album.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;

  queryParams = {
    sort: { refreshModel: true },
    order: { refreshModel: true },
    persons: { refreshModel: true },
  };

  async model(params) {
    const {
      album_id,
      sort = 'score.overall',
      order = 'desc',
      persons = [],
    } = params;

    // Fetch the album with included persons
    const album = await this.store.findRecord('album', album_id, {
      include: 'persons',
    });

    // Fetch photos
    const photos = await this.store.query('photo', {
      album_id,
      sort,
      order,
    });

    const loadedPersons = await album.persons;
    const allPersons = loadedPersons.map((person) => person.name);

    // Filter photos by selected persons
    let filteredPhotos = photos;
    if (persons.length > 0) {
      filteredPhotos = filteredPhotos.filter((photo) =>
        persons.every((personName) => photo.persons.includes(personName)),
      );
    }

    return {
      album,
      photos: filteredPhotos,
      albumUUID: photos.meta?.albumUUID || album_id,
      sortAttribute: photos.meta?.sortAttribute || sort,
      sortOrder: photos.meta?.sortOrder || order,
      scoreAttributes: photos.meta?.scoreAttributes || [],
      persons: allPersons,
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/eq.js**
```
// frontend/photo-filter-frontend/app/helpers/eq.js

import { helper } from '@ember/component/helper';

export default helper(function eq([a, b]) {
  return a === b;
});
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/contains.js**
```
import { helper } from '@ember/component/helper';

export default helper(function contains([item, array]) {
  return array.includes(item);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

### **./frontend/photo-filter-frontend/config/optional-features.json**
```
{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {
        // Here you can enable experimental features on an ember canary build
        // e.g. EMBER_NATIVE_DECORATOR_SUPPORT: true
      },
    },

    APP: {
      // Here you can pass flags/options to your application instance
      // when it is created
      apiHost: 'http://localhost:3000', // Add this line
    },
  };

  if (environment === 'development') {
    // ENV.APP.LOG_RESOLVER = true;
    // ENV.APP.LOG_ACTIVE_GENERATION = true;
    // ENV.APP.LOG_TRANSITIONS = true;
    // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
    // ENV.APP.LOG_VIEW_LOOKUPS = true;
  }

  if (environment === 'test') {
    // Testem prefers this...
    ENV.locationType = 'none';

    // keep test console output quieter
    ENV.APP.LOG_ACTIVE_GENERATION = false;
    ENV.APP.LOG_VIEW_LOOKUPS = false;

    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // here you can enable a production-specific feature
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": [
            "--ci-provider=github"
          ]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
// frontend/photo-filter-frontend/tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from '../helpers/index.js';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('visiting /albums and viewing an album', async function (assert) {
    await visit('/albums');

    assert.strictEqual(currentURL(), '/albums');
    assert.dom('h1').hasText('Select an Album');

    const albumLinks = findAll('a');
    assert.ok(albumLinks.length > 0, 'There are album links');

    // Click the first album link
    await click(albumLinks[0]);

    // The URL should change to the album route
    assert.ok(currentURL().startsWith('/albums/'), 'Navigated to album route');

    // Check that photos are displayed
    assert.dom('.photo-grid').exists('Photo grid is displayed');
    assert
      .dom('.photo-item')
      .exists({ count: 1 }, 'At least one photo is displayed');

    // Check that images have loaded
    assert.dom('.photo-item img').exists('Photo image is displayed');
  });
});
```

### **./frontend/photo-filter-frontend/tests/helpers/index.js**
```
import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file exists to provide wrappers around ember-qunit's
// test setup functions. This way, you can easily extend the setup that is
// needed per test type.

function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // Additional setup for application tests can be done here.
  //
  // For example, if you need an authenticated session for each
  // application test, you could do:
  //
  // hooks.beforeEach(async function () {
  //   await authenticateSession(); // ember-simple-auth
  // });
  //
  // This is also a good place to call test setup functions coming
  // from other addons:
  //
  // setupIntl(hooks, 'en-us'); // ember-intl
  // setupMirage(hooks); // ember-cli-mirage
}

function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);

  // Additional setup for rendering tests can be done here.
}

function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);

  // Additional setup for unit tests can be done here.
}

export { setupApplicationTest, setupRenderingTest, setupTest };
```

### **./frontend/photo-filter-frontend/README.md**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "dependencies": {
        "postcss": "^8.4.49"
      },
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/string": "^4.0.0",
        "@ember/test-helpers": "^3.3.1",
        "@glimmer/component": "^1.1.2",
...
```

### **./frontend/photo-filter-frontend/package.json**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Photo Filter Frontend",
  "scripts": {
    "build": "ember build --environment=production",
    "start": "ember serve",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "dependencies": {
    "postcss": "^8.4.49"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@ember/optional-features": "^2.1.0",
    "@ember/string": "^4.0.0",
    "@ember/test-helpers": "^3.3.1",
    "@glimmer/component": "^1.1.2",
    "@glimmer/tracking": "^1.1.2",
    "autoprefixer": "^10.4.20",
    "broccoli-asset-rev": "^3.0.0",
    "concurrently": "^8.2.2",
    "daisyui": "^4.12.22",
    "ember-auto-import": "^2.8.1",
    "ember-cli": "~5.12.0",
    "ember-cli-app-version": "^7.0.0",
    "ember-cli-babel": "^8.2.0",
    "ember-cli-clean-css": "^3.0.0",
    "ember-cli-dependency-checker": "^3.3.2",
    "ember-cli-htmlbars": "^6.3.0",
    "ember-cli-inject-live-reload": "^2.1.0",
    "ember-cli-postcss": "^8.2.0",
    "ember-cli-sri": "^2.1.1",
    "ember-cli-terser": "^4.0.2",
    "ember-data": "~5.3.8",
    "ember-fetch": "^8.1.2",
    "ember-load-initializers": "^2.1.2",
    "ember-modifier": "^4.2.0",
    "ember-page-title": "^8.2.3",
    "ember-qunit": "^8.1.0",
    "ember-resolver": "^12.0.1",
    "ember-source": "~5.12.0",
    "ember-template-lint": "^6.0.0",
    "ember-welcome-page": "^7.0.2",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-ember": "^12.2.1",
    "eslint-plugin-n": "^16.6.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-qunit": "^8.1.2",
    "loader.js": "^4.7.0",
    "prettier": "^3.3.3",
    "qunit": "^2.22.0",
    "qunit-dom": "^3.2.1",
    "sass": "^1.83.0",
    "stylelint": "^15.11.0",
    "stylelint-config-standard": "^34.0.0",
    "stylelint-prettier": "^4.1.0",
    "tailwindcss": "^3.4.16",
    "tracked-built-ins": "^3.3.0",
    "webpack": "^5.95.0"
  },
  "engines": {
    "node": ">= 18"
  },
  "ember": {
    "edition": "octane"
  }
}
```

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
```

### **./frontend/photo-filter-frontend/.eslintrc.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
```

### **./frontend/photo-filter-frontend/postcss.config.js**
```
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

