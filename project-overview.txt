# Project Overview: Photo Filter
-e 
Generated on: Sun Jan 12 11:07:02 EST 2025
Branch: develop

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
â”œâ”€â”€ .DS_Store
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .nvmrc
â”œâ”€â”€ COMPASSION.md
â”œâ”€â”€ DEVELOPMENT_PLAN.md
â”œâ”€â”€ ISSUES.md
â”œâ”€â”€ README.md
â”œâ”€â”€ backend
â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â”œâ”€â”€ .babelrc
â”‚Â Â  â”œâ”€â”€ .nvmrc
â”‚Â Â  â”œâ”€â”€ controllers
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ api
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ albums-controller.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ people-controller.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos-controller.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ api-controller.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ get-albums.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ get-photos-by-album.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ people-legacy-controller.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ photo-controller.js
â”‚Â Â  â”œâ”€â”€ data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ---albums.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ --albums.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ -albums.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ albums
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ --1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ -1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 07B45549-D8E7-40E1-BBC2-AA6A8383054B
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 16BC5397-4A87-49A1-8404-85D6473F3931
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 4CA23588-B72F-4807-8015-7ED9CABE44CB
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 561CCDD4-26A7-4898-8514-ECE1AABF1409
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 66B493A8-1AA2-42B1-8092-316B0B8B2EB4
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 6956E064-5A0E-4451-8A75-FC6724FED866
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 69865EDF-08F2-40B1-8E20-F802D6C4E6D3
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 8F0E0536-45BB-4EED-A62B-B8F56D61412F
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 918451EC-C6A5-416D-B919-D23AE46FEBBF
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 9379D36A-15A0-4705-BFC1-23574AE145D8
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 9D1ED02F-D8D1-43F9-ACE0-1D35B14DE195
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ A9641171-0398-46FC-B1EF-03B66D73BF32
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ C5170173-2B78-498D-AB6E-E29188933158
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CCA9CBAC-2CE3-419B-BEB2-44A5F9B7854E
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ D3988A5F-8B66-464B-B18C-457EC672621A
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ F3E7E679-D0C3-4442-9984-BA2C2B9DEA4C
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ photos.json
â”‚Â Â  â”‚Â Â  â””â”€â”€ albums.json
â”‚Â Â  â”œâ”€â”€ jest.config.js
â”‚Â Â  â”œâ”€â”€ models
â”‚Â Â  â”‚Â Â  â””â”€â”€ photoModel.js
â”‚Â Â  â”œâ”€â”€ osxphotos_crash.log
â”‚Â Â  â”œâ”€â”€ package-lock.json
â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â”œâ”€â”€ public
â”‚Â Â  â”‚Â Â  â””â”€â”€ stylesheets
â”‚Â Â  â”‚Â Â      â””â”€â”€ scss
â”‚Â Â  â”‚Â Â          â””â”€â”€ style.scss
â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ api.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.js
â”‚Â Â  â”œâ”€â”€ scripts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ export_albums.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ export_photos_in_album.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ setup.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ template_functions.py
â”‚Â Â  â”œâ”€â”€ server.js
â”‚Â Â  â”œâ”€â”€ test_albums.json
â”‚Â Â  â”œâ”€â”€ tests
â”‚Â Â  â”‚Â Â  â””â”€â”€ controllers
â”‚Â Â  â”‚Â Â      â””â”€â”€ api
â”‚Â Â  â”‚Â Â          â”œâ”€â”€ albums-controller.test.js
â”‚Â Â  â”‚Â Â          â””â”€â”€ photos-controller.test.js
â”‚Â Â  â”œâ”€â”€ utils
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ exec-command.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ export-images.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ get-photos-library-last-modified.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ helpers.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ run-python-script.js
â”‚Â Â  â”œâ”€â”€ views
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ albums.hbs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.hbs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ layouts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ main.hbs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ person.hbs
â”‚Â Â  â”‚Â Â  â””â”€â”€ persons.hbs
â”‚Â Â  â””â”€â”€ yarn.lock
â”œâ”€â”€ frontend
â”‚Â Â  â”œâ”€â”€ .DS_Store
â”‚Â Â  â””â”€â”€ photo-filter-frontend
â”‚Â Â      â”œâ”€â”€ -package-lock.json
â”‚Â Â      â”œâ”€â”€ .DS_Store
â”‚Â Â      â”œâ”€â”€ .editorconfig
â”‚Â Â      â”œâ”€â”€ .ember-cli
â”‚Â Â      â”œâ”€â”€ .eslintignore
â”‚Â Â      â”œâ”€â”€ .eslintrc.js
â”‚Â Â      â”œâ”€â”€ .github
â”‚Â Â      â”‚Â Â  â””â”€â”€ workflows
â”‚Â Â      â”‚Â Â      â””â”€â”€ ci.yml
â”‚Â Â      â”œâ”€â”€ .gitignore
â”‚Â Â      â”œâ”€â”€ .prettierignore
â”‚Â Â      â”œâ”€â”€ .prettierrc.js
â”‚Â Â      â”œâ”€â”€ .stylelintignore
â”‚Â Â      â”œâ”€â”€ .stylelintrc.js
â”‚Â Â      â”œâ”€â”€ .template-lintrc.js
â”‚Â Â      â”œâ”€â”€ .watchmanconfig
â”‚Â Â      â”œâ”€â”€ README.md
â”‚Â Â      â”œâ”€â”€ app
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ adapters
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ application.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ photo.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ app.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ photo-grid.hbs
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ photo-grid.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ controllers
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ albums
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ album
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ persons
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ album.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ application.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ helpers
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ capitalize.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ contains.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ eq.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ get-nested-property.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ replace.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ index.html
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ models
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ album.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ person.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ photo.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ router.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ albums
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ album
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ persons
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ album.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ albums.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ index.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ serializers
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ services
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ current-album.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ store.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ styles
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ app.css
â”‚Â Â      â”‚Â Â  â””â”€â”€ templates
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ albums
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ album
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ persons
â”‚Â Â      â”‚Â Â      â”‚Â Â  â””â”€â”€ album.hbs
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ albums.hbs
â”‚Â Â      â”‚Â Â      â””â”€â”€ application.hbs
â”‚Â Â      â”œâ”€â”€ config
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ ember-cli-update.json
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ environment.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ optional-features.json
â”‚Â Â      â”‚Â Â  â””â”€â”€ targets.js
â”‚Â Â      â”œâ”€â”€ ember-cli-build.js
â”‚Â Â      â”œâ”€â”€ package.json
â”‚Â Â      â”œâ”€â”€ postcss.config.js
â”‚Â Â      â”œâ”€â”€ public
â”‚Â Â      â”‚Â Â  â””â”€â”€ robots.txt
â”‚Â Â      â”œâ”€â”€ tailwind.config.js
â”‚Â Â      â”œâ”€â”€ testem.js
â”‚Â Â      â”œâ”€â”€ tests
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ acceptance
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ albums-test.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ helpers
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ index.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ index.html
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ integration
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ test-helper.js
â”‚Â Â      â”‚Â Â  â””â”€â”€ unit
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ .gitkeep
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ models
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ album-test.js
â”‚Â Â      â”‚Â Â      â”‚Â Â  â””â”€â”€ photo-test.js
â”‚Â Â      â”‚Â Â      â”œâ”€â”€ routes
â”‚Â Â      â”‚Â Â      â”‚Â Â  â”œâ”€â”€ album-test.js
â”‚Â Â      â”‚Â Â      â”‚Â Â  â””â”€â”€ albums-test.js
â”‚Â Â      â”‚Â Â      â””â”€â”€ services
â”‚Â Â      â”‚Â Â          â””â”€â”€ store-test.js
â”‚Â Â      â””â”€â”€ yarn.lock
â”œâ”€â”€ generate-overview.sh
â”œâ”€â”€ osxphotos_crash.log
â”œâ”€â”€ project-guidelines.md
â”œâ”€â”€ project-overview.txt
â”œâ”€â”€ public
â”‚Â Â  â””â”€â”€ stylesheets
â”‚Â Â      â””â”€â”€ css
â”‚Â Â          â””â”€â”€ style.css
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ cleanup-duplicates.sh
â”‚Â Â  â””â”€â”€ create-video.sh
â”œâ”€â”€ test-images
â”‚Â Â  â”œâ”€â”€ .osxphotos_export.db
â”‚Â Â  â”œâ”€â”€ IMG_0743.HEIC
â”‚Â Â  â””â”€â”€ uuids.txt
â”œâ”€â”€ test-osxphotos.js
â””â”€â”€ top_photo_uuids.txt

76 directories, 152 files
```

---

## Root-Level Files

### **./COMPASSION.md**
```
# COMPASSION.md

## **Compassion Software Principles**

This document outlines the foundational principles and guidelines for embedding compassion into the design, development, and lifecycle of software systems. Compassion Software is a framework for creating technology that prioritizes emotional intelligence, relational care, and ethical responsibility at every stage.

---

## **Core Principles**

1. **Self-Compassion**

   - Treat the development process, team members, and users with kindness.
   - Normalize imperfection and embrace failure as an opportunity for growth.
   - Embed affirmations and reminders throughout the documentation and system interface to encourage self-kindness for both users and developers.

2. **Radical Acceptance**

   - Recognize and work with reality as it is, without judgment or resistance.
   - Foster resilience by creating systems that adapt to complexity and uncertainty.

3. **Relational Intelligence**

   - Build tools that reflect and support healthy relational dynamics.
   - Use features like emotional mapping and communication templates to promote connection and understanding.
   - Ensure features evolve based on user stories and emotional data, creating a system that grows alongside its users.

4. **Trauma-Informed Design**

   - Prioritize safety and healing for users by avoiding re-traumatization.
   - Incorporate privacy, transparency, and options for user agency.

5. **Mindful Technology**

   - Encourage presence and intentional use of technology.
   - Avoid designs that exploit user attention or promote compulsive behaviors.
   - Include reflective prompts for developers to pause and approach their work with mindfulness.

6. **Collaborative Systems**
   - Treat every phase of development as an opportunity for deliberation and feedback.
   - Include diverse voices to ensure inclusivity and equity in design.
   - Institutionalize collaborative feedback mechanisms, such as structured discussions and user committees, to maintain a dynamic deliberative corpus.

---

## **Stations of the Software Apparatus**

Compassion Software recognizes specific stages in the software lifecycle as opportunities to embody compassion:

### **1. Design**

- Approach design with humility, curiosity, and an open mind.
- Use co-creation methods to include user perspectives early in the process.
- Reflect on ethical and relational implications of design choices.

### **2. Implementation**

- Write code that reflects transparency, modularity, and adaptability.
- Ensure the system can evolve alongside user needs and societal shifts.
- Encourage developers to engage in mindful coding practices, reflecting on the relational impact of their decisions.

### **3. Interaction**

- Craft user experiences that feel relational and empathetic.
- Include prompts for reflection and tools for emotional regulation.
- Use nonviolent communication templates that adapt dynamically to user needs, offering guidance while educating users about relational skills.

### **4. Iteration**

- Treat iteration as a space for learning and renewal.
- Integrate feedback loops to continuously improve functionality and relational impact.
- Develop metrics to measure how well the system fosters care, connection, and relational awareness.

---

## **Features to Prioritize**

- **Emotional Mapping**: Visualize user relationships and emotional dynamics, evolving over time based on user input and experiences.
- **Self-Compassion Toolkit**: Provide mindfulness prompts, stress cycle completion exercises, affirmations, and guidance for self-kindness.
- **Nonviolent Communication Templates**: Equip users to navigate conflict with empathy and understanding, adapting dynamically to user tone and context.
- **Safe Spaces**: Ensure privacy and user agency in all reflective or emotional features.
- **Gamified Acts of Kindness**: Encourage users to practice compassion in small, intentional ways.
- **Narrative Storytelling Features**: Allow users to co-create evolving emotional and relational stories with the system.

---

## **Ethical Commitments**

- **Privacy First**: Users retain ownership and control over their data.
- **Bias Awareness**: Actively identify and mitigate biases in design and algorithms.
- **Cultural Sensitivity**: Create inclusive systems that reflect diverse perspectives and needs.
- **Sustainability**: Prioritize resource-efficient technologies to minimize environmental impact.
- **Developer Accountability**: Establish processes to ensure developers adhere to ethical guidelines and relational goals.

---

## **Developer Guidelines**

1. **Collaborate with Empathy**

   - Approach teamwork with patience and understanding.
   - Foster psychological safety within the development environment.

2. **Document Decisions Thoughtfully**

   - Explain not just technical choices, but also ethical and relational considerations.
   - Use this document as a reference when evaluating the compassion impact of a feature.

3. **Test for Relational Impact**

   - Go beyond functionality to assess how features affect users emotionally and relationally.
   - Regularly gather user feedback to refine experiences.

4. **Iterate with Care**
   - Treat each iteration as an opportunity for growth, both for the system and the team.
   - Reflect on lessons learned and incorporate them into the next cycle.

---

## **Future Directions**

- Integrate AI tools to enhance relational insights while maintaining ethical standards.
- Partner with educators, therapists, and community leaders to expand use cases.
- Evolve the framework based on feedback from diverse user populations.

---

## **Closing Statement**

Compassion Software redefines how technology can serve humanity by embedding care, connection, and resilience at every stage. By following the principles outlined in this document, we aim to create systems that not only solve problems but also nurture the emotional and relational well-being of all who interact with them.
```

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

### December 14, 2024: Tailwind & DaisyUI Integration Update

**Decision & Implementation:**

- Removed `@import` of Tailwind CSS files in `app.scss` and replaced them with:
  ```scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  ```

### Update: Transition to Query-Param-Based Faceted Person Filtering

**Date:** December 12, 2024

**Decision:**

- Move from nested person-specific routes toward a unified album route that uses query parameters to filter by selected individuals.
- The UI will display a list of people in the left navigation under the currently active album. Users can toggle individuals on or off (via checkboxes or links), and the albumâ€™s displayed photos will filter to include only photos with all selected individuals.
- Remove the separate â€œView People in this Albumâ€ link and the â€œBack to Albumsâ€ link, as album navigation and person filtering are now integrated in the left nav.
- Eventually incorporate a front-end UI framework (like Bootstrap or Material Design) for a more cohesive look and feel.

**Rationale:**

- **Integrated Navigation:** Having all filtering (by album, by people) and sorting in one unified route simplifies the user experience.
- **Improved UX:** No need to navigate to a separate persons sub-route. People-based filtering is just another facet of the main album view.
- **Scalability:** Query params enable easy multi-person filtering. As the user selects multiple names, they appear in the URLâ€™s query params, making the filtering state shareable and bookmarkable.
- **Future-Ready:** Paves the way to easily add other facets (like tags, locations, or events) as query-parameter-based filters.

**Implementation Steps:**

1. **Remove Person Sub-Routes:**
   - No longer need `albums/album/persons` or `albums/album/persons/person/:person_name`.
   - Instead, retrieve people from `GET /api/albums/:albumUUID/persons` and display them under the selected album in the left nav.
2. **Update Album Route to Use Query Params:**
   - Add a `people` query param to `albums.album`.
   - When a user toggles a person in the UI, update the `people` query param to reflect the currently selected individuals.
   - Filter photos based on the intersection of all selected individualsâ€™ sets of photos.
3. **UI Updates:**
   - The left nav becomes scrollable and fixed in height, independent from the main content area.
   - Display the currently selected album title, below it a list of people. Each name toggles inclusion in the people filter.
   - No need for â€œBack to Albumsâ€ or â€œView People in This Albumâ€ linksâ€”navigation and filtering are seamlessly integrated.
4. **Backend:**
   - The backend remains largely the same. The frontend can still fetch all people via `GET /api/albums/:albumUUID/persons`.
   - For multiple individuals, the frontend will combine their names and request photos containing all of them, or request the full set and filter on the client side if needed. (Future optimization may be added on the backend.)
5. **Documentation:**
   - Update `DEVELOPMENT_PLAN.md`, `ISSUES.md`, and `README.md` to reflect the new approach.
   - Document how query parameters represent the filtering state.
6. **Testing and Validation:**
   - Ensure that selecting multiple individuals updates the displayed photos correctly.
   - Confirm that query params can be bookmarked and reloaded.
   - Test sorting combined with person-based filtering.

**Potential Challenges:**

- **Complex Filtering:** As multiple people are selected, performance could degrade for large albums. Consider caching or indexing if needed.
- **UI Complexity:** Need a clear indication of which people are currently selected and how to reset filters.
- **Backwards Compatibility:** Removing person sub-routes may require updating links or references.

**Previous Updates:**

- **December 7, 2024:** Initial person-level sub-routes conceived. _(Note: This approach is now evolving into a unified, query-param-based filter.)_
- **November 12, 2024:** Introduced nested routes, left nav, and sorting.
- **November 1, 2024:** Added cache invalidation for data freshness.
- **October 30, 2024:** Adopted JSON:API serializer.

**Project Goal:**
Create an intuitive, facet-based photo exploration tool integrated with macOS Photos data, enabling advanced sorting, selection, exporting, and multi-person filtering.

**Current State:**

- **Frontend:** Ember.js with album-level sorting and filtering now done fully on the frontend for improved performance.
- **Backend:** Express.js, JSON:API, data from `osxphotos`.
- **Data Handling:** `osxphotos` extracts metadata.
- **Selection & Export:** In progress.
- **Documentation & Styling:** Ongoing enhancements.

**Next Steps:**

1. **Implement Multi-Person Filtering with Query Params:**
   - Refactor UI to remove separate person routes (already done).
   - Add toggles in the left nav (done).
   - Update the album routeâ€™s model hook to factor in `people` query param (done).
2. **Improve Export Feature:**
   - Integrate actual export logic on the backend.
   - Show feedback to the user during export operations.
3. **UX and Performance:**
   - **Immediate Measure:** We have now implemented frontend-only sorting and filtering to avoid expensive re-fetches of large albums.
   - **Long-Term Vision:** Consider setting up an indexed database on the backend to handle large datasets more efficiently. Also develop a cache invalidation mechanism for Apple Photos library changes, so we know when our snapshot is stale and re-fetch only when necessary.
4. **Testing & Quality Assurance:**
   - Test multi-person filtering thoroughly.
   - Validate sorting and selection persistence with front-end-only filtering.
   - Confirm that no new network requests are made unnecessarily.
5. **Documentation & Cleanup:**
   - Keep all documentation updated.
   - Refactor code for maintainability.
```

### **./ISSUES.md**
```
# Issues and Resolutions

This file logs open issues and their statuses. Update it as new issues arise and existing ones progress.

---

## Issue 16: PostCSS "File not found: /app/styles/app.css" Error

**Opened By:** Jamie, Dec 14, 2024  
**Status:** In Progress

### Description

Encountered a build error because PostCSS didnâ€™t find `app.css` after SCSS changes.

### Actions

- Installed `ember-cli-sass` to compile `app.scss` into `app.css`.
- Updated `app.scss` to use `@tailwind` directives instead of `@import`.
- (Alternative) Renamed `app.scss` to `app.css` and removed `ember-cli-sass`.

### Next Steps

- Verify build succeeds (`ember serve`).
- If successful, mark as Resolved after testing in production-like scenarios.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name], Nov 12, 2024  
**Status:** **Resolved**

### Description

`albums/album` routeâ€™s template not rendering correctly.

### Resolution

- Added `{{outlet}}` to `albums.hbs`.
- Verified proper rendering.

---

## Issue 14: 404 Error When Fetching Album Data

**Opened By:** [Your Name], Nov 10, 2024  
**Status:** **Resolved**

### Description

`GET /api/albums/:albumUUID` returned 404.

### Resolution

- Implemented `GET /api/albums/:albumUUID`.
- Confirmed endpoint now works as expected.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need multi-photo selection persistence across sorting and filtering changes.

### Actions

- Created `selection.js` service to manage selected photos.
- Selections persist when changing sort order or navigating within the album.

### Next Steps

- Integrate with multi-person filtering now that filtering is query-param-based.
- Ensure that selected photos remain selected as users toggle people filters.
- Write more comprehensive tests for selection persistence.

---

## Issue 9: Adding Actions for Selected Photos (Export Functionality)

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need to export selected photos from the backend once chosen on the frontend.

### Actions

- Created `/api/photos/export` endpoint.
- Frontend can send selected photo IDs to initiate export.
- Basic user alerts implemented to inform the user of export status.

### Next Steps

- Implement actual export logic on the backend.
- Add progress indicators (e.g., a progress bar) in the UI.
- Validate that exported filenames handle duplicates properly.

---

## Issue 16: Filename Collisions in Exports

**Opened By:** [Your Name], Dec 11, 2024  
**Status:** **Open** (Reopened Dec 12, 2024)

### Description

When exporting images, sometimes duplicate filenames occur.

### Current Approach

- Prepend date/time to filenames.
- Append counters for duplicates.

### Next Steps

- Confirm that this approach truly prevents collisions.
- Test extensively in a real environment before marking resolved.

---

## Newly Considered Issue: Replacing Person Sub-Routes with Query Params

**Opened By:** [Your Name], Dec 12, 2024  
**Status:** **In Planning**

### Description

We initially implemented `albums/album/persons` sub-routes. We now want to remove them in favor of query params on the main album route. This will unify navigation and filtering, removing the need for â€œBackâ€ or â€œView Peopleâ€ links.

### Actions

- Update `DEVELOPMENT_PLAN.md` to reflect query-param-based person filtering.
- Adjust frontend UI to list people under the album in the left nav.
- Remove old person sub-route code once the new system is tested.

### Next Steps

- Implement toggles for people in the sidebar.
- Update the album route model hook to filter photos by selected people.
- Fully test the new approach.

---

## Issue 17: Persons Not Appearing in Album UI

**Opened By:** [Your Name], Dec 13, 2024  
**Status:** **Open**

### Description

Even though the backend returns `persons` as included data when fetching an album, they do not appear in the UI. In Ember Inspector, we see `album.persons` is present, but on the active controller, `persons` remains empty because the PromiseManyArray was not awaited before use.

### Actions

- In `app/routes/albums/album.js`, awaited `album.persons` before mapping/filtering.
- Once verified and tested, we can mark this issue resolved.

### Next Steps

- Verify persons now appear as expected.

---

## New Issue: `photoPersonNames` Always Empty in Controller

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** **Open**

### Description

Weâ€™re trying to filter photos by selected persons. However, `photoPersonNames` in `albums/album.js` controller logging always returns an empty array. The reason seems to be that `photo.persons` is not properly populated with Person model instances. Even though we have `@hasMany('person')` defined, the `persons` data might be coming in as raw strings rather than proper JSON:API relationships.

### Proposed Frontend-Only Fix

We can create a custom serializer for `photo` on the frontend that transforms the raw `persons` attribute into proper JSON:API relationships. This ensures Ember Data recognizes the `persons` as PersonModel instances.

### Next Steps

- Implement a `photo.js` serializer in `app/serializers/photo.js` that modifies the `normalize` response, converting `persons` strings into relationship objects and (optionally) included person records.
- Test if `photo.persons` now returns actual Person models.
- Confirm that `photoPersonNames` is no longer empty.

---

## Performance Impact from Re-Fetching Large Albums on Sort/Filter Changes

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** Open

### Description

Changing sorting/filtering previously caused large album re-fetches, leading to delays. We implemented front-end-only sorting/filtering to avoid unnecessary re-fetches.

### Actions

- Moved sorting and filtering logic to the frontend.
- Initial load might be slower, but subsequent operations are fast.

### Next Steps

- Consider indexed DB, cache invalidation strategies, pagination, or lazy loading for scalability.
- Monitor performance and refine as needed.

---

## Issue 19: Chrome "Aw, Snap!" Crash on Large Albums

**Opened By:** [Your Name], Dec 21, 2024  
**Status:** **Resolved**

### Description

When an album contains a very large number of photos (hundreds or thousands), Chrome sometimes crashes with an â€œAw, Snap!â€ error code 5. This typically indicates the browser is running out of memory or hitting some resource limit.

### Resolution

- **Implemented a default limit (e.g., 200 photos) when requesting an album** to prevent the UI from trying to render or sort thousands of photos at once.
- Added a `limit` query param so advanced users can pull more photos if needed (with caution).

### Next Steps

- For truly large datasets, implement full pagination instead of a single â€œlimitâ€ slice.
- Monitor memory usage when increasing `limit`.
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application. It enables browsing, filtering, and exporting photos from your macOS Photos library.

## Project Structure

- **backend/**: Express.js backend application.
- **frontend/**: Ember.js frontend application.
- **DEVELOPMENT_PLAN.md**: Roadmap and implementation details.
- **ISSUES.md**: Issues, debugging steps, and resolutions.
- **project-guidelines.md**: Collaboration and coding standards.

## Features

- **Album Navigation**: Browse albums via a left-side navigation column.
- **Photo Display**: View photos in selected albums with various sort options.
- **Faceted Person-Based Filtering**:  
  Under the currently active album, see a list of all recognized people.
  - **Single Person Filter**: Click one personâ€™s name to display only photos with that individual.
  - **Multiple People Filter**: Select additional names to narrow photos down to those containing _all_ the chosen individuals, enabling powerful faceted search.
- **Sorting**: Sort photos by various attributes (e.g., aesthetic scores).
- **Photo Selection**: Select multiple photos; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Freshness

- The backend checks for changes in the Photos library.
- Cache invalidation ensures up-to-date album and photo data.

## Performance and Optimization

- JSON:API compliance for seamless Ember Data integration.
- Plans to implement lazy loading and indexing for improved performance.

## UI/UX

- Nested routes (`{{outlet}}`) for clarity.
- Future enhancements include more intuitive multi-person selection interfaces and better export feedback.

## Post-Photo-Filter Export Workflow: Preparing Photos for Video Editing

Once you have exported a directory of photos from the Photo Filter application, you may want to prepare them for video editing in Final Cut Pro X (FCPX) or another professional non-linear editor. The following steps outline how to normalize image orientation, generate a consistent file list, determine dimensions, and create a ProRes video file that preserves aspect ratios for all images.

**Prerequisites:**

- [ImageMagick](https://imagemagick.org/index.php)
- [FFmpeg](https://ffmpeg.org/) and its associated tools (e.g., \`ffprobe\`)
- A directory of \`.jpg\` images exported from the Photo Filter app

### 1. Ensure All Images Have the Correct Orientation

Use ImageMagick to apply rotation metadata directly to the pixel data. This ensures that downstream tools see the images correctly oriented:

\`\`\`bash
brew install imagemagick
mogrify -auto-orient \*.jpg
\`\`\`

### 2. Generate a File List for ffmpeg

First, list all \`.jpg\` images in the current directory:

\`\`\`bash
ls -1 \*.jpg > file_list.txt
\`\`\`

Then convert that listing into a format ffmpeg can parse:

\`\`\`bash
awk '{print "file \x27" $0 "\x27"}' file_list.txt > formatted_list.txt
\`\`\`

### 3. Determine the Dimensions of the First Image

Check the width and height of one of your images using ffprobe. Replace \`DSCF8482.jpg\` with an actual image filename from your directory:

\`\`\`bash
ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 DSCF8482.jpg
\`\`\`

Suppose this returns \`6240,4160\`. These will be your reference dimensions.

### 4. Convert Images to a Video with Preserved Aspect Ratios

Use ffmpeg to generate a ProRes \`.mov\` file. Scale and pad each image to fit the chosen dimensions (e.g., \`6240x4160\`) without distortion. Replace \`6240\` and \`4160\` with the values obtained above:

\`\`\`bash
ffmpeg -f concat -safe 0 -i formatted_list.txt \
-vf "scale='min(iw\*4160/ih,6240)':4160,setsar=1,pad=6240:4160:(6240-iw)/2:(4160-ih)/2" \
-framerate 16 -c:v prores -pix_fmt yuv422p output_preserved_aspect.mov
\`\`\`

**What This Does:**

- **Scale:** Adjusts each image so that it fits within the 6240x4160 frame, preserving its aspect ratio.
- **Pad:** Centers the scaled image by adding black bars if needed.
- **ProRes Encoding:** Outputs a high-quality \`.mov\` file suitable for editing in Final Cut Pro or other professional NLEs.
- **Framerate:** Sets the video to 16 frames per second, which you can adjust as desired.

### Additional Tips

- **Adjust the Frame Rate:**  
  Change \`-framerate 16\` to your desired frame rate (e.g., \`-framerate 24\`).

- **Change the Output Codec:**  
  Prefer a different codec (e.g., H.264 for smaller file sizes)? Replace \`-c:v prores -pix_fmt yuv422p\` with \`-c:v libx264 -crf 18\`.

- **Further Refinements:**  
  If you have specific creative requirements (e.g., adding transitions, stabilizing footage, or applying filters), you can incorporate those steps into your ffmpeg pipeline or perform them later in your video editing software.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter

   2.	Backend Setup:
   ```

cd backend
npm install
npm run setup
npm run dev

    3.	Frontend Setup:

Open a new terminal window:

cd frontend/photo-filter-frontend
npm install
npm run start

    4.	Access the Application:

Visit http://localhost:4200.

Contributing
â€¢ Use clear and descriptive commit messages.
â€¢ Track issues in ISSUES.md.
â€¢ Follow guidelines in project-guidelines.md.

Testing
â€¢ Backend: Use Jest for tests (npm run test in backend/).
â€¢ Frontend: Use Ember CLI testing (npm run test in frontend/).

License

This project is licensed under the MIT License.
```

### **./project-guidelines.md**
```
Project Guidelines

Table of Contents

- Project Philosophy
- Keeping Up with Dependencies
- Data Formats
- Data Synchronization and Caching
- Ensuring Complete Project Overviews
- Coding Standards
- Naming Conventions
- Directory Structure
- Documentation Practices
- Privacy and Data Handling
- Project State and Continuity
- Issue Tracking and Debugging
- Collaboration Guidelines
- Environment and Dependency Management
- Error Handling and Logging
- Security Best Practices
- Testing
- Deployment and Operations
- Performance Optimization

---

## Project Philosophy

- User-Centric Design, Interactivity, Clarity, Modularity, Consistency.
- Ember.js Conventions: Follow Ember.js patterns.
- Privacy, Security, Performance, Scalability.
- Embrace Iterative Understanding: Treat solutions as provisional and open to revision.

## Keeping Up with Dependencies

- Stay informed of the latest versions and updates.
- Test thoroughly after upgrading dependencies.
- Document changes and version notes.

## Data Formats

- Use JSON:API for backend/frontend integration.
- Utilize `jsonapi-serializer` on the backend.

## Data Synchronization and Caching

- Implement cache invalidation using timestamps.
- Balance data freshness with performance.

## Ensuring Complete Project Overviews

- Include all relevant files in generated overviews.
- Update `generate-overview.sh` as the project evolves.
- Regularly review project-overview.txt for accuracy.

## Coding Standards

- Consistent indentation (2 spaces).
- camelCase for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- Avoid globals; use modules.
- Follow Ember.js coding conventions where applicable.

## Naming Conventions

- Dasherized filenames (e.g., `photo-controller.js`).
- Descriptive and concise filenames.

## Directory Structure

- `backend/`: Express.js server and APIs
- `frontend/`: Ember.js app
- `data/`, `exports/`, `scripts/`, `utils/`, `tests/`
- Keep structure organized and consistent.

## Documentation Practices

- Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`.
- Use inline code comments and JSDoc.
- Maintain a changelog and consider `ARCHITECTURE.md` for big-picture decisions.
- Include â€œQuestions to Considerâ€ to highlight uncertainties.

## Privacy and Data Handling

- Do not store personal data in git.
- Be transparent about data processing.

## Project State and Continuity

- Self-contained documentation.
- Reflect current state, pending tasks, and future plans within the project files.

## Issue Tracking and Debugging

- Log issues in `ISSUES.md`.
- Document steps taken and current status.
- **Do Not Mark Issues as Resolved Until Verified**:  
  **No issue should be marked as "Resolved" until the fix is actually applied by the real person managing the system, and tested to confirm it works in reality.**
- Use "Uncertain" tags if needed to highlight unresolved aspects.
- Treat resolutions as provisional truths.

## Collaboration Guidelines

- Communicate clearly and concisely.
- Provide full file replacements for verifiable changes.
- Keep project composed of smaller files for easy copy-paste integration.
- Include clear commit messages.

## Environment and Dependency Management

- Use `.nvmrc` for Node.js versions.
- Keep dependencies updated and tested.
- Store config in environment variables.
- Adhere to JSON:API specs to ensure frontend-backend compatibility.

## Error Handling and Logging

- Implement robust error handling in async code.
- Provide meaningful error messages.
- Use logging for debugging and monitoring.

## Security Best Practices

- No sensitive info in version control.
- Validate/sanitize user inputs.
- Use environment variables for credentials.

## Testing

- Comprehensive test coverage: unit, integration, acceptance.
- Use Jest (backend) and Ember CLI testing tools (frontend).
- Mock external dependencies.
- Write tests alongside code changes.
- Keep tests reliable and maintainable.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configs.
- Monitor performance and errors in production.

## Performance Optimization

- Optimize large dataset handling.
- Use caching and lazy loading.
- Profile resource usage.
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/test_albums.json**
```
{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle ðŸŽžï¸ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour â€”Â People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie â— Jamie": 4976, "Dominic â— Jamie": 4415, "Rosa Menkman â— Jamie Burkart": 2821, "Transfer â— Jamie Burkart": 2821, "Sondy â— Jamie": 2542, "Chad â— Jamie": 1830, "Lera Tarasenko â— Jamie Burkart": 1636, "Mir â— 196 Artists Residency": 1156, "Carper â— Burkart": 717, "Lydia â— Jamie": 380, "Jessi â— Mike â— Jamie": 347, "Jack â— Jamie": 332, "Lera Show â— Jamie Burkart": 310, "Patrick Weaver â— Jamie Burkart": 162, "Hayley â— Jamie": 149, "Claudette â— Jamie": 143, "Greta â— Shan â— Jamie": 137, "Zhen Li â— Jamie Burkart": 83, "Bobby â— Madeleine â— Jamie": 60, "Abby â— Jamie": 57, "Isabel Santos â— Jamie Burkart": 50, "Laura Mattingly â— Jamie Burkart": 45, "Thor â— Jamie": 35, "Stewart â— Jamie": 29, "Jessi â— Jamie Fashion Concepts &;-)": 26, "Gabi â— Michael â— Jamie": 17, "Melody â— Jamie": 13, "Michael â— Jamie": 9, "Em Gift â— Jamie Burkart": 1, "Bridget â— Jamie": 0}}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
```

### **./backend/utils/run-python-script.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
```

### **./backend/utils/exec-command.js**
```
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/utils/helpers.js**
```
// backend/utils/helpers.js

export function getNestedProperty(obj, propertyPath) {
  if (!propertyPath || typeof propertyPath !== "string") {
    return null;
  }
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

export function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

export function capitalizeAttributeName(attributeName) {
  const nameParts = attributeName.split(".");
  const lastPart = nameParts[nameParts.length - 1];
  return lastPart
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}
```

### **./backend/utils/export-images.js**
```
// backend/utils/export-images.js

import fs from "fs-extra";
import path from "path";
import { execCommand } from "./exec-command.js";

/**
 * Export images using osxphotos for a given album.
 * @param {string} osxphotosPath - Path to the osxphotos executable in the virtualenv.
 * @param {string} albumUUID - The UUID of the album to export.
 * @param {string} imagesDir - The directory to which images will be exported.
 * @param {string} photosPath - The path to the photos.json file.
 */
export async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use a date/time prefix and original_name directly via osxphotos template:
  // {created.strftime,%Y%m%d-%H%M%S}-{original_name}
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{created.strftime,%Y%m%d-%H%M%S}-{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

/**
 * Safely get a nested property from an object.
 * @param {object} obj - The object to retrieve the property from.
 * @param {string} propertyPath - The dot-separated path (e.g. "score.overall").
 * @returns {*} - The property value or null if not found.
 */
export function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/models/photoModel.js**
```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

### **./backend/package-lock.json**
```json
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-backend",
      "version": "1.0.0",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "cors": "^2.8.5",
        "express": "^4.21.1",
        "fs-extra": "^11.2.0",
        "jsonapi-serializer": "^3.6.7"
      },
      "devDependencies": {
        "concurrently": "^9.0.1",
        "jest": "^29.7.0",
...
```

### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/setup.js**
```
// ./scripts/setup.js

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

(async () => {
  try {
    const venvDir = path.join(process.cwd(), "venv");
    const venvPython = path.join(venvDir, "bin", "python3");
    const venvPip = path.join(venvDir, "bin", "pip");

    // Use Python 3.11 explicitly
    const pythonExecutable = "python3.11";

    // Check if virtual environment exists
    const venvExists = await fs.pathExists(venvPython);

    if (!venvExists) {
      console.log(
        `Creating Python virtual environment with ${pythonExecutable}...`
      );
      await execAsync(`${pythonExecutable} -m venv venv`);
      console.log("Virtual environment created.");
    } else {
      console.log("Virtual environment already exists, ready to collaborate.");
    }

    // Install or upgrade osxphotos
    console.log(
      "Inviting osxphotos to join the project by installing or upgrading it..."
    );
    await execAsync(`"${venvPip}" install --upgrade osxphotos`);
    console.log("osxphotos is now part of the team.");

    console.log("Setup completed successfully, all components are in place.");
  } catch (error) {
    console.error("Setup encountered an issue:", error);
    process.exit(1);
  }
})();
```

### **./backend/controllers/api-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );

      // After exporting, rename files to prepend the photo's capture date
      await renameExportedImages(imagesDir, photosPath);
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Rename exported images with date-based filenames
async function renameExportedImages(imagesDir, photosPath) {
  const photosData = await fs.readJson(photosPath);

  for (const photo of photosData) {
    const originalName = path.parse(photo.original_filename).name; // e.g., DSCF1191
    const photoDate = new Date(photo.date); // Parse the photoâ€™s date field
    const formattedDate = formatPhotoDate(photoDate); // YYYYMMDD-HHMMSS
    const oldPath = path.join(imagesDir, `${originalName}.jpg`);

    if (await fs.pathExists(oldPath)) {
      let newFilename = `${formattedDate}-${originalName}.jpg`;
      let finalPath = path.join(imagesDir, newFilename);

      // Check for collisions
      let counter = 1;
      while (await fs.pathExists(finalPath)) {
        newFilename = `${formattedDate}-${originalName}-${counter}.jpg`;
        finalPath = path.join(imagesDir, newFilename);
        counter++;
      }

      await fs.rename(oldPath, finalPath);
      console.log(`Renamed ${originalName}.jpg to ${newFilename}`);
    } else {
      console.warn(`File not found for rename: ${oldPath}`);
    }
  }
}

// Format the photo date as YYYYMMDD-HHMMSS
function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/people-legacy-controller.js**
```
// backend/controllers/people-legacy-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { getNestedProperty } from "../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Show all people in an album
export const getPeopleInAlbumLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Gather all distinct people
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    const people = Array.from(allPersons).sort();

    // Render persons.hbs view
    res.render("persons", { albumUUID, people });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Show photos of a single person in the album
export const getPhotosByPersonLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by person
    const filteredPhotos = photosData.filter((photo) => {
      return Array.isArray(photo.persons) && photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      // No photos of this person
      return res.render("person", {
        albumUUID,
        personName,
        photos: [],
        scoreAttributes: [],
        sortAttribute,
        sortOrder,
      });
    }

    // Add original_name property
    filteredPhotos.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from the first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort photos based on the requested attribute
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Render person.hbs view
    res.render("person", {
      albumUUID,
      personName,
      photos: filteredPhotos,
      scoreAttributes,
      sortAttribute,
      sortOrder,
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
```

### **./backend/controllers/api/albums-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const AlbumSerializer = new Serializer("album", {
  id: "uuid",
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
  relationships: {
    persons: {
      type: "person",
    },
  },
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    await fs.ensureDir(dataDir);

    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    const albumsData = await fs.readJson(albumsPath);
    const jsonApiData = AlbumSerializer.serialize(albumsData);
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    const albumsData = await fs.readJson(albumsPath);
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    let persons = [];
    if (await fs.pathExists(photosPath)) {
      const photosData = await fs.readJson(photosPath);
      const allPersons = new Set();
      photosData.forEach((photo) => {
        if (Array.isArray(photo.persons)) {
          photo.persons.forEach((name) => allPersons.add(name));
        }
      });
      persons = Array.from(allPersons).map((name) => {
        return {
          id: slugifyName(name),
          name: name,
        };
      });
    }

    const albumRecord = {
      uuid: album.uuid,
      title: album.title,
    };

    let albumJsonApi = AlbumSerializer.serialize(albumRecord);
    albumJsonApi.data.relationships = albumJsonApi.data.relationships || {};
    albumJsonApi.data.relationships.persons = {
      data: persons.map((p) => ({ type: "person", id: p.id })),
    };

    const personJsonApi = PersonSerializer.serialize(persons);

    const merged = {
      data: albumJsonApi.data,
      included: personJsonApi.data,
      meta: {},
    };

    res.json(merged);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/api/index.js**
```
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/people-controller.js**
```
// backend/controllers/api/people-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
    "persons",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

// List all people in an album
export const getPeopleInAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Extract all persons from all photos
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    res.json({ data: Array.from(allPersons) });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Get photos of a specific person in the album
export const getPhotosByPerson = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by personName
    const filteredPhotos = photosData.filter((photo) => {
      if (!Array.isArray(photo.persons)) return false;
      return photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      return res.json({
        data: [],
        meta: {
          albumUUID,
          personName,
          sortAttribute,
          sortOrder,
          scoreAttributes: [],
        },
      });
    }

    // Add originalName property
    filteredPhotos.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    filteredPhotos.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(filteredPhotos);

    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        personName,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/photos-controller.js
import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../../utils/export-images.js";
import { getNestedProperty } from "../../utils/helpers.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "exportedFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: { type: "album" },
    persons: { type: "person" },
  },
  pluralizeType: false,
  meta: {},
});

function formatPhotoDateWithOffset(dateString) {
  const match = dateString.match(
    /^(\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2}(?:\.\d+)?)([\+\-]\d{2}:\d{2})$/
  );
  if (!match) {
    return fallbackFormat(new Date(dateString));
  }

  const datePart = match[1];
  const timePart = match[2];

  const [year, month, day] = datePart.split("-").map(Number);
  const [hour, minute, secondRaw] = timePart.split(":");
  const hourNum = Number(hour);
  const minuteNum = Number(minute);
  const secondNum = Math.floor(Number(secondRaw));

  const YYYY = String(year);
  const MM = String(month).padStart(2, "0");
  const DD = String(day).padStart(2, "0");
  const HH = String(hourNum).padStart(2, "0");
  const mm = String(minuteNum).padStart(2, "0");
  const ss = String(secondNum).padStart(2, "0");

  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

function fallbackFormat(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    let photosData = await fs.readJson(photosPath);

    // Deduplicate photos by (original_filename, date) if needed
    photosData = deduplicatePhotos(photosData);

    // Prepare each photo
    const uniquePersons = new Map();
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
      const prefix = formatPhotoDateWithOffset(photo.date);
      photo.exportedFilename = `${prefix}-${photo.originalName}.jpg`;

      // Ensure persons is an array; if empty or undefined, make it empty array
      if (!Array.isArray(photo.persons)) {
        photo.persons = [];
      }

      // Collect person slugs
      photo.personsData = photo.persons.map((name) => {
        const slug = slugifyName(name);
        if (!uniquePersons.has(slug)) {
          uniquePersons.set(slug, { id: slug, name });
        }
        return { type: "person", id: slug };
      });

      // Set the album relationship
      photo.album = albumUUID;
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Serialize photos
    const jsonApiPhotoData = PhotoSerializer.serialize(photosData);

    // Serialize persons
    const personsArray = Array.from(uniquePersons.values());
    const jsonApiPersonData = PersonSerializer.serialize(personsArray);

    // Merge included resources
    const merged = {
      data: jsonApiPhotoData.data,
      included: jsonApiPersonData.data,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    };

    // Assign relationships.persons to each photo in `merged.data`
    // This ensures each photo has a proper JSON:API relationship
    merged.data.forEach((photo) => {
      const originalPhoto = photosData.find((p) => p.uuid === photo.id);
      if (
        originalPhoto &&
        originalPhoto.personsData &&
        originalPhoto.personsData.length > 0
      ) {
        photo.relationships = photo.relationships || {};
        photo.relationships.persons = {
          data: originalPhoto.personsData,
        };
      } else {
        photo.relationships = photo.relationships || {};
        photo.relationships.persons = { data: [] };
      }
    });

    res.json(merged);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function deduplicatePhotos(photos) {
  const map = new Map();
  for (const photo of photos) {
    const key = `${photo.original_filename}-${photo.date}`;
    if (!map.has(key)) {
      map.set(key, { ...photo });
    } else {
      // Merge persons if there's a duplicate
      const existing = map.get(key);
      if (Array.isArray(photo.persons)) {
        const existingPersons = new Set(existing.persons || []);
        photo.persons.forEach((p) => existingPersons.add(p));
        existing.persons = Array.from(existingPersons);
      }
      map.set(key, existing);
    }
  }
  return Array.from(map.values());
}

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";
import plist from "plist";
import { exec } from "child_process";
import os from "os";
import { createRequire } from "module";
import {
  getNestedProperty,
  capitalizeAttributeName,
} from "../utils/helpers.js";

const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images with osxphotos (directly uses date/time prefix)
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 60;

    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    const photoTags = {};

    attributesToProcess.forEach(({ name, order, limit }) => {
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);
        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;
        return order === "asc" ? aValue - bValue : bValue - aValue;
      });

      const topPhotos = sortedPhotos.slice(0, limit);
      topPhotos.forEach((photo) => {
        if (!photoTags[photo.uuid]) {
          photoTags[photo.uuid] = [];
        }
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photo.uuid].includes(attributeDisplayName)) {
          photoTags[photo.uuid].push(attributeDisplayName);
        }
      });
    });

    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort the photos by requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);
      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;
      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];
    if (tags.length === 0) continue;

    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
```

### **./backend/data/--albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/---albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/-albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums/A9641171-0398-46FC-B1EF-03B66D73BF32/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Grace Beana Burkart"
        ],
        "burst": false,
        "cloud_guid": "AR32fGDeh6iwMqLM9P5veibjAKgk",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-20 21:18:23.937434-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-20 17:42:02-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 3200,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/918451EC-C6A5-416D-B919-D23AE46FEBBF/photos.json**
```json
[
    {
        "albums": [
            "Sheep"
        ],
        "burst": false,
        "cloud_guid": "AbkiIdG7V0IzR4NfC4f4B8JslwNm",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2022-11-06 11:52:19.752600-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2022-11-06 17:52:18.936800+01:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1600,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/69865EDF-08F2-40B1-8E20-F802D6C4E6D3/photos.json**
```json
[
    {
        "albums": [
            "2024-12-11-Last Month",
            "Anna Pompermaier",
            "Austria",
            "Cenk G\u00fczelis",
            "FujiFilm x100v: All, Full Res",
            "Innsbruck, Austria",
            "Recent Month",
            "Recent Week",
            "Studio3",
            "Studio3 Symposium",
            "Studio3 Symposium \u2014\u00a0IRL"
        ],
        "burst": false,
        "cloud_guid": "AYxUYDskCQ/gPyKyTSQOsTKDO0qz",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-15 11:48:30.564913-05:00",
...
```

### **./backend/data/albums/1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Stefania"
        ],
        "burst": false,
        "cloud_guid": "AUf+djE+jaJNIaz2xEN31IC7yKg+",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-01 20:27:27.985500-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-01 19:29:14-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/66B493A8-1AA2-42B1-8092-316B0B8B2EB4/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V",
            "Jamie Burkart Portraits"
        ],
        "burst": false,
        "cloud_guid": "AXcMiG1MSUL3SVk2F2qOUqtpRNBS",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-28 19:23:39.381971-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-28 19:20:46-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/9379D36A-15A0-4705-BFC1-23574AE145D8/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Snow"
        ],
        "burst": false,
        "cloud_guid": "AeXFxa+Ga0PHwnMCmCZZC+qJZli9",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-06 14:55:41.022275-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-06 13:58:42-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 160,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/8F0E0536-45BB-4EED-A62B-B8F56D61412F/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "With Stefania"
        ],
        "burst": false,
        "cloud_guid": "Ae1jAv2u3zZVfKq8TJccL1BVavdL",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-07 18:34:44.419988-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-07 16:26:42-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 500,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/4CA23588-B72F-4807-8015-7ED9CABE44CB/photos.json**
```json
[
    {
        "albums": [
            "Dominic Antoine 2024",
            "FUJIFILM X100V-02"
        ],
        "burst": false,
        "cloud_guid": "Aep68bd5MWDZRzijvX3EiaHDQ5zX",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-23 17:38:23.356118-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-23 14:32:41-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/-1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Stefania"
        ],
        "burst": false,
        "cloud_guid": "AUf+djE+jaJNIaz2xEN31IC7yKg+",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-01 20:27:27.985500-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-01 19:29:14-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/16BC5397-4A87-49A1-8404-85D6473F3931/photos.json**
```json
[
    {
        "albums": [
            "2024-12-11-Last Month"
        ],
        "burst": false,
        "cloud_guid": "AUe3MMiGEMSXiJQFq+RdRUZ6gohE",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 21:54:44.122153-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 21:54:43.398000-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 2000,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/--1AF4375A-A948-45C7-B4B9-C9C2D4CB5DC5/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V-02",
            "Stefania"
        ],
        "burst": false,
        "cloud_guid": "AUf+djE+jaJNIaz2xEN31IC7yKg+",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-01-01 20:27:27.985500-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-01-01 19:29:14-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1250,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/F3E7E679-D0C3-4442-9984-BA2C2B9DEA4C/photos.json**
```json
[
    {
        "albums": [
            "Dominic Antoine Family Visit",
            "FujiFilm x100v: All, Full Res"
        ],
        "burst": false,
        "cloud_guid": "ASVx5Ac1sLyomOfpmIfrjujWXi0n",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-18 03:53:17.829920-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-17 17:53:36-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 3200,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/561CCDD4-26A7-4898-8514-ECE1AABF1409/photos.json**
```json
[
    {
        "albums": [
            "2024-12-01-day",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res",
            "Max & Jamie",
            "Mir & Max",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AcSEPiuXBZgwpoiypBMP7q0DWUTt",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-30 20:35:09.211243-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 19:07:52-05:00",
        "description": null,
        "exif_info": {
...
```

### **./backend/data/albums/9D1ED02F-D8D1-43F9-ACE0-1D35B14DE195/photos.json**
```json
[
    {
        "albums": [
            "FUJIFILM X100V",
            "Kendell + Mandy",
            "Sold the building"
        ],
        "burst": false,
        "cloud_guid": "AbKvwshLoD5UVXKZ2eDVsCSnrfVk",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-03-20 23:52:55.841168-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-03-20 21:24:15-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 640,
            "metering_mode": 5,
...
```

### **./backend/data/albums/6956E064-5A0E-4451-8A75-FC6724FED866/photos.json**
```json
[
    {
        "albums": [
            "2024-12-09",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res"
        ],
        "burst": false,
        "cloud_guid": "AbZe/Yx1gH5bPgoyi7FqXRZz8YrC",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-09 16:58:31.698262-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-12-09 11:03:56-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 320,
            "metering_mode": 5,
...
```

### **./backend/data/albums/D3988A5F-8B66-464B-B18C-457EC672621A/photos.json**
```json
[
    {
        "albums": [
            "2024-12-01-day",
            "2024-12-11-Last Month",
            "FujiFilm x100v: All, Full Res",
            "Max & Jamie",
            "Mir & Max",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AQucx0r2Z1j5VHamAkpTY4+F+3fP",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-30 20:35:09.221502-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 19:07:52-05:00",
        "description": null,
        "exif_info": {
...
```

### **./backend/data/albums/C5170173-2B78-498D-AB6E-E29188933158/photos.json**
```json
[
    {
        "albums": [
            "Emily Sphere"
        ],
        "burst": false,
        "cloud_guid": "AZriFwpx5Ic8GtYQ/tSX84mN620u",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2023-09-30 17:32:49.434345-04:00",
        "date_modified": "2024-06-13 16:54:23.792595-04:00",
        "date_trashed": null,
        "date": "2023-09-30 17:32:49.300000-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 640,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/CCA9CBAC-2CE3-419B-BEB2-44A5F9B7854E/photos.json**
```json
[
    {
        "albums": [
            "Charlie - We Might See"
        ],
        "burst": false,
        "cloud_guid": "AQp/d2GQnkiwJcHCYwLF41QqJ+1A",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2023-05-16 20:30:31.319333-04:00",
        "date_modified": "2024-06-14 09:39:48.291821-04:00",
        "date_trashed": null,
        "date": "2023-05-16 20:17:17-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": null,
            "metering_mode": null,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/07B45549-D8E7-40E1-BBC2-AA6A8383054B/photos.json**
```json
[
    {
        "albums": [
            "196 Bulbs \ud83d\udca1 2024",
            "2024-12-11-Last Month",
            "A Great Day",
            "Mir Thanksgiving 2024"
        ],
        "burst": false,
        "cloud_guid": "AYb8yeUxUYOD4yxwAvDh0b3UBV7l",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-12-01 10:30:41.023814-05:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-30 21:52:27-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 2500,
...
```

### **./backend/views/albums.hbs**
```
<h1 class="text-3xl font-bold mb-4">Select an Album</h1>

<div class="flex flex-row h-screen">
  <!-- Sidebar -->
  <div
    class="w-64 bg-base-100 border-r border-base-300 h-full overflow-y-auto p-4"
  >
    <ul class="menu w-full">
      {{#each this.model as |album|}}
        <li class="mb-1">
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-base-300"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <div class="flex-1 p-6">
    {{outlet}}
  </div>
</div>```

### **./backend/views/index.hbs**
```
<!-- backend/views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a> | 
<a href="/album/{{albumUUID}}/persons">View People in this Album</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.exported_filename}}"
        alt="{{this.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.exported_filename}}

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/layouts/main.hbs -->

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/views/person.hbs**
```
<!-- ./views/person.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos of {{personName}} in Album</h1>
<a href="/album/{{albumUUID}}/persons">Back to People</a>

<form method="GET" action="/album/{{albumUUID}}/person/{{personName}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{photo.exported_filename}}"
        alt="{{photo.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{photo.exported_filename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property photo ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/persons.hbs**
```
<!-- ./views/persons.hbs -->

<h1>People in Album</h1>
<a href="/album/{{albumUUID}}">Back to Album</a>

<ul>
  {{#each people as |person|}}
    <li><a href="/album/{{../albumUUID}}/person/{{person}}">{{person}}</a></li>
  {{/each}}
</ul>```

### **./backend/routes/index.js**
```
// backend/routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";
import {
  getPeopleInAlbumLegacy,
  getPhotosByPersonLegacy,
} from "../controllers/people-legacy-controller.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// New legacy routes for persons
router.get("/album/:albumUUID/persons", getPeopleInAlbumLegacy);
router.get("/album/:albumUUID/person/:personName", getPhotosByPersonLegacy);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
// backend/routes/api.js

import express from "express";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";

// Import the new people controllers
import {
  getPeopleInAlbum,
  getPhotosByPerson,
} from "../controllers/api/people-controller.js";

const apiRouter = express.Router();

// API route to get all albums
apiRouter.get("/albums", getAlbumsData);

// API route to get a single album by UUID
apiRouter.get("/albums/:albumUUID", getAlbumById);

// API route to get photos by album UUID
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

// API routes for people in an album
apiRouter.get("/albums/:albumUUID/persons", getPeopleInAlbum);
apiRouter.get("/albums/:albumUUID/person/:personName", getPhotosByPerson);

export default apiRouter;
```

## Frontend Files

### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  let app = new EmberApp(defaults, {
    postcssOptions: {
      compile: {
        enabled: true,
        plugins: [
          require('tailwindcss')('./tailwind.config.js'),
          require('autoprefixer'),
        ],
      },
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/tailwind.config.js**
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.hbs',
    './app/**/*.js',
    './app/**/*.ts',
    './app/**/*.gjs',
    './app/**/*.gts',
  ],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
};
```

### **./frontend/photo-filter-frontend/app/models/person.js**
```
// frontend/photo-filter-frontend/app/models/person.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class PersonModel extends Model {
  @attr('string') name;
  @hasMany('photo', { async: true, inverse: 'persons' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
// frontend/photo-filter-frontend/app/models/album.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: false, inverse: 'album' }) photos;
  // Change persons to async: false since we include all data and don't want extra requests
  @hasMany('person', { async: false, inverse: null }) persons;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
// frontend/photo-filter-frontend/app/models/photo.js
import Model, { attr, belongsTo, hasMany } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr('string') exportedFilename;
  @attr() score;
  @attr() exifInfo;

  @belongsTo('album', { async: false, inverse: 'photos' }) album;
  // Set async: false since we include all persons in the payload
  @hasMany('person', { async: false, inverse: 'photos' }) persons;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```

### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/components/photo-grid.hbs**
```
<div class="grid gap-6 sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-2">
  {{#each @photos as |photo index|}}
    <div class="card bg-base-100 shadow-lg">
      <figure>
        <img
          src="{{this.apiHost}}/images/{{@albumUUID}}/{{photo.exportedFilename}}"
          alt="{{photo.exportedFilename}}"
          class="max-w-full h-auto"
        />
      </figure>
      <div class="card-body">
        <h2 class="card-title text-sm">
          <span class="opacity-50">{{index}} -</span>
          {{photo.exportedFilename}}
        </h2>

        {{#if photo.tags}}
          <div class="mt-2 flex flex-wrap gap-2">
            {{#each photo.tags as |tag|}}
              <span class="badge badge-accent badge-outline">{{tag}}</span>
            {{/each}}
          </div>
        {{/if}}

        <p class="mt-2">
          {{capitalize (replace @sortAttribute "score." "")}}:
          {{get-nested-property photo @sortAttribute}}
        </p>
      </div>
    </div>
  {{/each}}
</div>```

### **./frontend/photo-filter-frontend/app/components/photo-grid.js**
```
import Component from '@glimmer/component';
import config from 'photo-filter-frontend/config/environment';

/**
 * PhotoGrid Component
 *
 * Arguments:
 * - @photos: An array of photo objects.
 * - @albumUUID: The album's UUID for constructing image URLs.
 * - @sortAttribute: The current sorting attribute to display values for.
 */
export default class PhotoGridComponent extends Component {
  get apiHost() {
    return config.APP.apiHost;
  }
}
```

### **./frontend/photo-filter-frontend/app/router.js**
```
import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });
});
```

### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
<!-- We are inside the main flex container defined in application.hbs -->
<!-- Here we split the space into a left nav and a main content area side by side. -->
<!-- Each gets overflow-auto so they scroll independently. -->

<div class="h-full w-full flex">
  <!-- Left nav: fixed width, scrollable -->
  <div
    class="w-64 bg-gray-100 border-r border-gray-300 h-full overflow-auto p-4"
  >
    <ul class="menu p-0 w-full">
      {{#each this.model as |album|}}
        <li class="mb-1">
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-gray-200 px-2 py-1"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <!-- Main content area: add id here so ember-router-scroll can find it -->
  <div id="main-content-area" class="flex-1 overflow-auto p-4">
    {{outlet}}
  </div>
</div>```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
{{page-title "PhotoFilterFrontend"}}

<div
  class="h-screen w-screen overflow-hidden bg-base-200 text-base-content relative"
>
  <!-- Fixed top nav -->
  <nav
    class="fixed top-0 left-0 right-0 h-16 z-50 bg-base-100 shadow flex items-center px-4 justify-between"
  >
    <a class="btn btn-ghost normal-case text-xl" href="/">Photo Filter</a>

    {{#if this.currentAlbum.isAlbumRoute}}
      <div class="flex items-center space-x-4">
        <!-- Album Title -->
        <h2 class="text-lg font-semibold">{{this.currentAlbum.albumTitle}}</h2>

        <!-- Sorting Options -->
        <div class="flex items-center space-x-2">
          <div class="form-control">
            <label class="label text-sm font-semibold">Sort by</label>
            <select
              id="sortAttribute"
              class="select select-xs select-bordered"
              {{on "change" (fn this.updateSortAttribute)}}
            >
              {{#each this.currentAlbum.scoreAttributes as |attribute|}}
                <option
                  value="score.{{attribute}}"
                  selected={{eq
                    this.currentAlbum.sortAttribute
                    (concat "score." attribute)
                  }}
                >
                  {{capitalize attribute}}
                </option>
              {{/each}}
            </select>
          </div>

          <div class="form-control">
            <label class="label text-sm font-semibold">Order</label>
            <select
              id="sortOrder"
              class="select select-xs select-bordered"
              {{on "change" (fn this.updateSortOrder)}}
            >
              <option
                value="desc"
                selected={{eq this.currentAlbum.sortOrder "desc"}}
              >Descending</option>
              <option
                value="asc"
                selected={{eq this.currentAlbum.sortOrder "asc"}}
              >Ascending</option>
            </select>
          </div>
        </div>
      </div>
    {{/if}}
  </nav>

  <div class="h-full w-full pt-16 flex">
    {{outlet}}
  </div>
</div>```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
<div class="flex justify-center mb-4 flex-wrap gap-2">
  {{#each this.model.persons as |person|}}
    <button
      type="button"
      class="btn btn-xs rounded-full normal-case
        {{if
          (contains person this.persons)
          'btn-primary text-white'
          'btn-outline text-gray-600'
        }}"
      {{on "click" (fn this.togglePerson person)}}
    >
      {{person}}
    </button>
  {{/each}}
</div>

<!-- Remove the did-update modifier -->
<div>
  <PhotoGrid
    @photos={{this.visiblePhotos}}
    @albumUUID={{this.model.albumUUID}}
    @sortAttribute={{this.sort}}
  />
</div>```

### **./frontend/photo-filter-frontend/app/controllers/application.js**
```
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';

export default class ApplicationController extends Controller {
  @service router;
  @service currentAlbum;

  @action
  updateSortAttribute(event) {
    const newSort = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: newSort,
              order: this.currentAlbum.sortOrder,
            },
          },
        );
      }
    }
  }

  @action
  updateSortOrder(event) {
    const newOrder = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: this.currentAlbum.sortAttribute,
              order: newOrder,
            },
          },
        );
      }
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
// frontend/photo-filter-frontend/app/controllers/albums/album.js
import Controller from '@ember/controller';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumController extends Controller {
  @service router;

  // Sorting & Filtering
  @tracked sort = 'score.overall';
  @tracked order = 'desc';
  @tracked persons = [];

  // Pagination
  @tracked page = 1;
  pageSize = 50; // number of photos to show per page

  // The route model returns: { album, photos, ... }
  get allPhotos() {
    // If the model hasnâ€™t fully loaded, return an empty array
    if (!this.model.isDataReady || !Array.isArray(this.model.photos)) {
      return [];
    }
    return this.model.photos;
  }

  /**
   * Return *all* photos after applying filtering and sorting,
   * but before pagination.
   */
  get filteredSortedPhotos() {
    let photos = this.allPhotos.slice();

    // 1. Filter by selected persons (if any)
    if (this.persons.length > 0) {
      photos = photos.filter((photo) => {
        // Each photo has an array of person model instances
        // with a `name` attribute
        const photoPersonNames = photo.persons.map((p) => p.name);
        // We want the photo to have *all* selected persons
        return this.persons.every((personName) =>
          photoPersonNames.includes(personName),
        );
      });
    }

    // 2. Sort by the current attribute and order
    photos.sort((a, b) => {
      const aValue = this.getNested(a, this.sort);
      const bValue = this.getNested(b, this.sort);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return this.order === 'asc' ? aValue - bValue : bValue - aValue;
    });

    return photos;
  }

  /**
   * Return only the photos that should appear
   * in the DOM on the current page.
   */
  get visiblePhotos() {
    // slice out the portion for current page
    const startIndex = (this.page - 1) * this.pageSize;
    const endIndex = this.page * this.pageSize;
    return this.filteredSortedPhotos.slice(startIndex, endIndex);
  }

  /**
   * Utility to handle nested paths like "score.overall".
   */
  getNested(obj, path) {
    return path.split('.').reduce((acc, part) => acc && acc[part], obj);
  }

  /**
   * Called when the user toggles a personâ€™s name in the UI,
   * to either add or remove that person from the filter.
   */
  @action
  togglePerson(personName) {
    let selected = [...this.persons];
    if (selected.includes(personName)) {
      selected = selected.filter((p) => p !== personName);
    } else {
      selected.push(personName);
    }
    this.persons = selected;

    // Also reset pagination to page 1 whenever we change filters
    this.page = 1;

    // Update query params in the URL
    this.router.transitionTo(
      'albums.album',
      this.router.currentRoute.params.album_id,
      {
        queryParams: {
          sort: this.sort,
          order: this.order,
          persons: this.persons,
        },
      },
    );
  }

  /**
   * Load the next page (increment `page`).
   * If weâ€™re at the last page, this does nothing.
   */
  @action
  loadMore() {
    // The total number of filtered photos (before pagination)
    const total = this.filteredSortedPhotos.length;

    // The index of the last item currently shown
    const lastShown = this.page * this.pageSize;

    if (lastShown < total) {
      // Another page still exists
      this.page++;
    }
  }

  /**
   * If the user changes the sort attribute in the UI,
   * reset page to 1 and update query params.
   */
  @action
  updateSortAttribute(event) {
    const newSort = event.target.value;
    this.sort = newSort;
    this.page = 1; // reset to first page
    this.router.transitionTo(
      'albums.album',
      this.router.currentRoute.params.album_id,
      {
        queryParams: {
          sort: newSort,
          order: this.order,
          persons: this.persons,
        },
      },
    );
  }

  /**
   * If the user changes the sort order in the UI,
   * reset page to 1 and update query params.
   */
  @action
  updateSortOrder(event) {
    const newOrder = event.target.value;
    this.order = newOrder;
    this.page = 1; // reset to first page
    this.router.transitionTo(
      'albums.album',
      this.router.currentRoute.params.album_id,
      {
        queryParams: {
          sort: this.sort,
          order: newOrder,
          persons: this.persons,
        },
      },
    );
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// app/routes/index.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service router;

  beforeModel() {
    this.router.replaceWith('albums');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
// frontend/photo-filter-frontend/app/routes/albums/album.js
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;
  @service currentAlbum;

  queryParams = {
    sort: {},
    order: {},
    persons: {
      // Custom serialize/deserialize so persons is always an array
      serialize(value) {
        return JSON.stringify(value);
      },
      deserialize(value) {
        if (typeof value === 'string') {
          try {
            const arr = JSON.parse(value);
            return arr;
          } catch (e) {
            return [];
          }
        }
        return value || [];
      },
    },
  };

  async model(params) {
    const {
      album_id,
      sort = 'score.overall',
      order = 'desc',
      persons = [],
    } = params;

    // Fetch the album record and persons in one go (async: false means all included data is ready)
    const album = await this.store.findRecord('album', album_id, {
      include: 'persons', // This ensures persons are included in the album payload
      reload: true,
    });

    const loadedPersons = album.persons;
    const allPersons = loadedPersons.map((person) => person.name);

    // Fetch all photos once, including included persons
    const allPhotos = await this.store.query('photo', {
      album_id,
    });

    // Since async: false is set on photo.persons and album.persons, we have all data now.
    // No need to reload anything. The included payload gave us all persons upfront.

    // Determine score attributes
    let scoreAttributes = [];
    if (allPhotos.meta && allPhotos.meta.scoreAttributes) {
      scoreAttributes = allPhotos.meta.scoreAttributes;
    } else if (allPhotos.length > 0 && allPhotos.firstObject.score) {
      scoreAttributes = Object.keys(allPhotos.firstObject.score);
    }

    // Sort persons by how many times they appear in the photos
    const personCountMap = {};
    allPhotos.forEach((photo) => {
      // photo.persons is already resolved since async: false
      photo.persons.forEach((p) => {
        personCountMap[p.name] = (personCountMap[p.name] || 0) + 1;
      });
    });

    const sortedAllPersons = allPersons.sort((a, b) => {
      const countA = personCountMap[a] || 0;
      const countB = personCountMap[b] || 0;
      if (countB !== countA) return countB - countA;
      return a.localeCompare(b);
    });

    // Update currentAlbum service
    this.currentAlbum.isAlbumRoute = true;
    this.currentAlbum.albumTitle = album.title;
    this.currentAlbum.scoreAttributes = scoreAttributes;
    this.currentAlbum.sortAttribute = sort;
    this.currentAlbum.sortOrder = order;

    // Data is fully ready, no reload needed
    const isDataReady = true;

    return {
      album,
      photos: allPhotos,
      albumUUID: allPhotos.meta?.albumUUID || album_id,
      sortAttribute: sort,
      sortOrder: order,
      scoreAttributes,
      persons: sortedAllPersons,
      selectedPersons: persons,
      isDataReady,
    };
  }

  resetController(controller, isExiting) {
    super.resetController(...arguments);
    if (isExiting) {
      // Reset currentAlbum service when leaving the album route
      this.currentAlbum.isAlbumRoute = false;
      this.currentAlbum.albumTitle = null;
      this.currentAlbum.scoreAttributes = [];
      this.currentAlbum.sortAttribute = 'score.overall';
      this.currentAlbum.sortOrder = 'desc';
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/eq.js**
```
// frontend/photo-filter-frontend/app/helpers/eq.js

import { helper } from '@ember/component/helper';

export default helper(function eq([a, b]) {
  return a === b;
});
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/contains.js**
```
import { helper } from '@ember/component/helper';

export default helper(function contains([item, array]) {
  return array.includes(item);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/current-album.js**
```
import Service from '@ember/service';
import { tracked } from '@glimmer/tracking';

export default class CurrentAlbumService extends Service {
  @tracked isAlbumRoute = false;
  @tracked albumTitle = null;
  @tracked scoreAttributes = [];
  @tracked sortAttribute = 'score.overall';
  @tracked sortOrder = 'desc';
  @tracked persons = [];
}
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

### **./frontend/photo-filter-frontend/config/optional-features.json**
```
{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    historySupportMiddleware: true, // enable for ember-router-scroll
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {},
    },

    APP: {
      apiHost: 'http://localhost:3000',
    },

    // Add routerScroll configuration here
    routerScroll: {
      targetElement: '#main-content-area',
    },
  };

  if (environment === 'development') {
    // ...
  }

  if (environment === 'test') {
    ENV.locationType = 'none';
    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // ...
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": ["--ci-provider=github"]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/-package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "dependencies": {
        "postcss": "^8.4.49"
      },
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/string": "^4.0.0",
        "@ember/test-helpers": "^3.3.1",
        "@glimmer/component": "^1.1.2",
...
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
// frontend/photo-filter-frontend/tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from '../helpers/index.js';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('visiting /albums and viewing an album', async function (assert) {
    await visit('/albums');

    assert.strictEqual(currentURL(), '/albums');
    assert.dom('h1').hasText('Select an Album');

    const albumLinks = findAll('a');
    assert.ok(albumLinks.length > 0, 'There are album links');

    // Click the first album link
    await click(albumLinks[0]);

    // The URL should change to the album route
    assert.ok(currentURL().startsWith('/albums/'), 'Navigated to album route');

    // Check that photos are displayed
    assert.dom('.photo-grid').exists('Photo grid is displayed');
    assert
      .dom('.photo-item')
      .exists({ count: 1 }, 'At least one photo is displayed');

    // Check that images have loaded
    assert.dom('.photo-item img').exists('Photo image is displayed');
  });
});
```

### **./frontend/photo-filter-frontend/tests/helpers/index.js**
```
import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file exists to provide wrappers around ember-qunit's
// test setup functions. This way, you can easily extend the setup that is
// needed per test type.

function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // Additional setup for application tests can be done here.
  //
  // For example, if you need an authenticated session for each
  // application test, you could do:
  //
  // hooks.beforeEach(async function () {
  //   await authenticateSession(); // ember-simple-auth
  // });
  //
  // This is also a good place to call test setup functions coming
  // from other addons:
  //
  // setupIntl(hooks, 'en-us'); // ember-intl
  // setupMirage(hooks); // ember-cli-mirage
}

function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);

  // Additional setup for rendering tests can be done here.
}

function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);

  // Additional setup for unit tests can be done here.
}

export { setupApplicationTest, setupRenderingTest, setupTest };
```

### **./frontend/photo-filter-frontend/README.md**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package.json**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Photo Filter Frontend",
  "scripts": {
    "build": "ember build --environment=production",
    "start": "ember serve",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "dependencies": {
    "postcss": "^8.4.49"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@ember/optional-features": "^2.1.0",
    "@ember/render-modifiers": "^2.1.0",
    "@ember/string": "^4.0.0",
    "@ember/test-helpers": "^3.3.1",
    "@glimmer/component": "^1.1.2",
    "@glimmer/tracking": "^1.1.2",
    "@html-next/vertical-collection": "^4.0.2",
    "autoprefixer": "^10.4.20",
    "broccoli-asset-rev": "^3.0.0",
    "concurrently": "^8.2.2",
    "daisyui": "^4.12.22",
    "ember-auto-import": "^2.8.1",
    "ember-cli": "~5.12.0",
    "ember-cli-app-version": "^7.0.0",
    "ember-cli-babel": "^8.2.0",
    "ember-cli-clean-css": "^3.0.0",
    "ember-cli-dependency-checker": "^3.3.2",
    "ember-cli-htmlbars": "^6.3.0",
    "ember-cli-inject-live-reload": "^2.1.0",
    "ember-cli-postcss": "^8.2.0",
    "ember-cli-sri": "^2.1.1",
    "ember-cli-terser": "^4.0.2",
    "ember-data": "~5.3.8",
    "ember-fetch": "^8.1.2",
    "ember-load-initializers": "^2.1.2",
    "ember-modifier": "^4.2.0",
    "ember-page-title": "^8.2.3",
    "ember-qunit": "^8.1.0",
    "ember-resolver": "^12.0.1",
    "ember-router-scroll": "^4.1.2",
    "ember-source": "~5.12.0",
    "ember-template-lint": "^6.0.0",
    "ember-welcome-page": "^7.0.2",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-ember": "^12.2.1",
    "eslint-plugin-n": "^16.6.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-qunit": "^8.1.2",
    "loader.js": "^4.7.0",
    "prettier": "^3.3.3",
    "qunit": "^2.22.0",
    "qunit-dom": "^3.2.1",
    "sass": "^1.83.0",
    "stylelint": "^15.11.0",
    "stylelint-config-standard": "^34.0.0",
    "stylelint-prettier": "^4.1.0",
    "tailwindcss": "^3.4.16",
    "tracked-built-ins": "^3.3.0",
    "webpack": "^5.95.0"
  },
  "engines": {
    "node": ">= 18"
  },
  "ember": {
    "edition": "octane"
  }
}
```

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
```

### **./frontend/photo-filter-frontend/.eslintrc.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
```

### **./frontend/photo-filter-frontend/postcss.config.js**
```
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

