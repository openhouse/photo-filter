# Project Overview: Photo Filter

Generated on: Sun Nov  3 21:17:38 EST 2024

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── DEVELOPMENT_PLAN.md
├── ISSUES.md
├── README.md
├── backend
│   ├── .babelrc
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── index.js
│   │   │   └── photos-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   └── photo-controller.js
│   ├── data
│   │   └── albums
│   │       └── 918451EC-C6A5-416D-B919-D23AE46FEBBF
│   │           └── photos.json
│   ├── models
│   │   └── photoModel.js
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── get-photos-library-last-modified.js
│   │   └── run-python-script.js
│   ├── views
│   │   ├── albums.hbs
│   │   ├── index.hbs
│   │   └── layouts
│   │       └── main.hbs
│   └── yarn.lock
├── data
│   └── albums
│       └── 8F27C9E8-F5CD-42AA-97A2-5DC49E0A4AB1
│           └── photos.json
├── frontend
│   └── photo-filter-frontend
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── README.md
│       ├── app
│       │   ├── adapters
│       │   │   └── application.js
│       │   ├── app.js
│       │   ├── components
│       │   │   └── .gitkeep
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   └── albums
│       │   │       └── album.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── get-nested-property.js
│       │   │   └── replace.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   ├── albums
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   └── index.js
│       │   ├── services
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.css
│       │   └── templates
│       │       ├── album.hbs
│       │       ├── albums
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       └── application.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package-lock.json
│       ├── package.json
│       ├── public
│       │   └── robots.txt
│       ├── testem.js
│       ├── tests
│       │   ├── helpers
│       │   │   └── index.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       └── yarn.lock
├── generate-overview.sh
├── osxphotos_crash.log
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
└── top_photo_uuids.txt

49 directories, 102 files
```

---

## Root-Level Files

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

## Update: Implementing Cache Invalidation Based on Timestamps

**Date:** November 1, 2024

### Decision

Implement cache invalidation based on timestamps to ensure the web application reflects the latest changes in the Apple Photos library.

### Rationale

- **Data Freshness**: Ensures users always see the latest albums and photos.
- **Performance**: Avoids unnecessary data regeneration, balancing performance with data freshness.

### Implementation Steps

1. **Create a Utility Function**:

   - Implement `getPhotosLibraryLastModified` to retrieve the last modified time of the Photos library.

2. **Update Backend Controllers**:

   - Modify `getAlbumsData` and `getPhotosByAlbumData` to check the last modified timestamps.
   - Regenerate cached data if the Photos library has changed.

3. **Testing**:

   - Test the implementation to ensure it correctly detects changes and updates cached data.

4. **Documentation**:

   - Update `README.md` and `project-guidelines.md` to reflect these changes.

### Potential Challenges

- **Accuracy of Timestamps**: Ensuring the last modified time accurately reflects changes within the library.
- **Edge Cases**: Handling situations where the Photos library changes without updating the last modified timestamp.
- **Performance Impact**: Monitoring any performance overhead introduced by checking timestamps.

---

## Previous Updates

## Update: Integration of JSON:API Serializer

- Decided to use `jsonapi-serializer` package on the backend to format API responses according to the JSON:API specification.
- Refactored the backend controllers to utilize the serializer, improving maintainability and compliance.
- Updated the package dependencies to include `jsonapi-serializer`.

---

## Project Goal

Develop a web application that interfaces with the user's macOS Photos library to enable interactive exploration, selection, and exporting of photos based on Apple's aesthetic scores and other metadata. The application aims to provide an engaging user experience by allowing users to select photos through intuitive interactions and perform actions like adding to albums or exporting selections.

## Current State

- **Data Extraction**: Implemented using `osxphotos` via a Python virtual environment.
- **Image Export**: Functioning correctly after resolving export issues.
- **Backend**: Express.js server with routes handling album and photo data.
- **Frontend**: Handlebars templates displaying albums and photos.
- **Styling**: Basic CSS styling using SCSS.
- **Issue Tracking**: `ISSUES.md` added for documenting issues and resolutions.

## New Objectives

- **Interactive Photo Selection**:

  - Implement the ability to select multiple photos by clicking and dragging the mouse over them.
  - Ensure selections persist as users switch between sorting attributes.
  - Allow users to collect selected photos from different sorting criteria.

- **Actions on Selected Photos**:

  - Provide options to add selected photos to a new or existing album in the Photos library.
  - Enable exporting selected images to a directory on the user's computer.
  - Organize new albums under a specific folder (e.g., "photo-filter") in the Photos library for encapsulation.

- **Enhanced Frontend Experience**:

  - Transition to an Ember.js frontend for better interactivity and responsiveness.
  - Use Express.js to serve API endpoints for data retrieval and actions.
  - Implement lazy loading of images to improve performance with large albums.

- **Roadmap Development**:

  - Set up a development roadmap outlining the transition to Ember.js and the implementation of new features.
  - Reimplement current features using the Ember.js frontend with Express.js as the API.
  - Expand the application with the new interactive features after the transition.

## Pending Tasks and Priorities

### 1. High Priority

- **Set Up Ember.js Frontend**:

  - Initialize a new Ember.js application within the project.
  - Configure the build and development environment to work alongside the existing Express.js backend.

- **Reimplement Current Features in Ember.js**:

  - Recreate album list view and photo grid view using Ember.js components.
  - Ensure existing functionality (album navigation, photo display, sorting) works seamlessly.

- **Implement Interactive Photo Selection**:

  - Develop a photo selection mechanism that allows users to select multiple photos via mouse dragging.
  - Use Ember.js services to manage the selection state and ensure persistence across different sorting views.

- **Add Actions for Selected Photos**:

  - Implement UI elements (buttons, menus) to perform actions on selected photos.
  - Set up API endpoints in Express.js to handle actions like adding to albums and exporting images.

- **Organize Albums in Photos Library**:

  - Use `osxphotos` to create new albums under a specific folder in the Photos library.
  - Ensure that the application can interact with the Photos library to perform these actions.

### 2. Medium Priority

- **Image Loading Optimization**:

  - Implement lazy loading of images to enhance performance with large photo collections.
  - Use Ember.js add-ons or native capabilities to achieve efficient image rendering.

- **UI/UX Enhancements**:

  - Improve the overall look and feel of the application.
  - Ensure the interface is intuitive and user-friendly for complex interactions.

- **Error Handling and Notifications**:

  - Provide user feedback for actions, especially for long-running processes.
  - Implement notifications or status indicators within the Ember.js app.

### 3. Low Priority

- **User Preferences and Settings**:

  - Allow users to save preferences like default export directories or album names.
  - Implement user authentication if necessary.

- **Advanced Filtering Options**:

  - Introduce additional filters (e.g., location, camera model, EXIF data).
  - Allow sorting by other subjective evaluation attributes.

- **Testing and Quality Assurance**:

  - Write unit and integration tests for both frontend and backend components.
  - Ensure robust error handling and data validation.

## Next Steps

1. **Initialize Ember.js Application**:

   - Install Ember CLI and set up the Ember.js app within the project directory.
   - Configure the development environment to run both the Ember.js frontend and Express.js backend concurrently.

2. **Set Up API Endpoints**:

   - Define RESTful API endpoints in Express.js for data retrieval and actions.
   - Ensure CORS is configured correctly for communication between frontend and backend.

3. **Reimplement Existing Features**:

   - Create Ember.js routes and components for album list and photo grid views.
   - Implement sorting functionality using Ember's computed properties and actions.

4. **Develop Photo Selection Mechanism**:

   - Use Ember.js components and services to enable photo selection via mouse dragging.
   - Ensure selection state persists across sorting changes.

5. **Implement Actions on Selected Photos**:

   - Add UI elements for actions like "Add to Album" and "Export Selected Photos."
   - Implement backend logic to handle these actions using `osxphotos`.

6. **Optimize Image Loading**:

   - Implement lazy loading for images to improve performance.
   - Test with large albums to ensure smooth user experience.

7. **Plan for Future Enhancements**:

   - Outline additional features and improvements based on user feedback and testing.
   - Prioritize tasks and update the development plan accordingly.

## Collaboration Notes

- **Code Provisioning**:

  - Provide full files for any code changes to facilitate copy-paste replacement.
  - Organize the project into smaller files if necessary to improve manageability.

- **Documentation**:

  - Keep all project files updated, including `README.md`, `ISSUES.md`, and `project-guidelines.md`.
  - Document architectural decisions and code changes thoroughly.

- **Issue Tracking**:

  - Utilize `ISSUES.md` for logging problems and tracking resolutions.
  - Include open-ended questions and uncertainties to encourage collaborative problem-solving.
```

### **./ISSUES.md**
```
# Issues and Resolutions

This file serves as a log of open issues, debugging steps taken, and resolutions. It's intended to facilitate collaborative problem-solving and prevent redundant efforts.

---

## Issue 12: Implementing Cache Invalidation Based on Timestamps

**Opened By:** [Your Name] on Nov 1, 2024

**Status:** **In Progress**

**Description:**

We need to ensure that the web application reflects the latest changes made in the Apple Photos library, such as newly added albums or photos. Currently, the application uses cached JSON files (`albums.json` and `photos.json`) and does not automatically update when changes occur.

**Objective:**

- Implement a mechanism to invalidate cached data based on the last modified timestamps of the Photos library and the cached files.

**Action Items:**

- [x] Create a utility function `getPhotosLibraryLastModified`.
- [x] Update `getAlbumsData` to check timestamps and regenerate `albums.json` if necessary.
- [ ] Update `getPhotosByAlbumData` to implement similar logic for `photos.json`.
- [ ] Test the implementation thoroughly.
- [ ] Update documentation to reflect the changes.

**Questions to Consider:**

- How frequently does the Photos library's last modified timestamp update?
- Are there any types of changes that do not affect the last modified time?
- How will this impact performance with large libraries?

---

## Issue 11: Using a JSON:API Package on the Backend

**Opened By:** [Your Name] on Oct 30, 2024

**Status:** **Resolved**

**Description:**

We need to ensure that our backend API responses conform to the JSON:API specification to work seamlessly with Ember Data. Manually formatting the responses can be error-prone and hard to maintain.

**Resolution:**

- Decided to integrate the `jsonapi-serializer` package on the backend.
- Refactored the API controllers to use the serializer.
- This improves maintainability and ensures compliance with the JSON:API specification.

**Action Items:**

- Installed `jsonapi-serializer` package.
- Updated API controllers by breaking them into smaller files and using the serializer.
- Updated package dependencies.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **Open**

**Description:**

We need to implement the ability for users to select multiple photos by clicking and dragging the mouse over them. Selections should persist as users switch between different sorting attributes. This functionality is essential for allowing users to collect photos as they explore their albums.

**Challenges:**

- **Mouse Drag Selection**: Implementing a user-friendly and intuitive way to select multiple photos with mouse dragging.
- **Selection Persistence**: Maintaining the selection state across different views and sorting options.
- **Performance**: Ensuring that the selection mechanism is performant, especially with large photo collections.

**Potential Solutions:**

- **Use Ember.js Services**:

  - Create a service to store the selection state, which can be accessed across different components and routes.

- **Photo Item Component**:

  - Develop a `PhotoItem` component that can detect mouse events and update the selection state accordingly.

- **Selection Library**:

  - Consider using or integrating with a library that handles drag selection (e.g., `ember-cli-drag-select`).

**Action Items:**

- Research existing Ember.js add-ons or libraries that facilitate drag selection.
- Implement the `SelectionService` to manage the selection state.
- Update the `PhotoGrid` and `PhotoItem` components to handle mouse events for selection.
- Ensure that the selection state is preserved when sorting attributes change.

**Questions to Consider:**

- How will the selection state be affected if the user navigates away from the album view?
- Do we need to implement a way to save and load selections across sessions?
- How can we optimize performance to handle thousands of photos?

---

## Issue 9: Adding Actions for Selected Photos

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **Open**

**Description:**

After implementing the selection mechanism, we need to allow users to perform actions on the selected photos, such as adding them to an album in the Photos library or exporting them to a directory.

**Challenges:**

- **Backend Integration**: Setting up API endpoints to handle actions on the backend.
- **Interaction with Photos Library**: Using `osxphotos` to add photos to albums or export them.
- **User Feedback**: Providing real-time feedback to the user about the status of their actions.

**Potential Solutions:**

- **API Endpoints**:

  - Create POST endpoints in Express.js to handle actions on selected photos.

- **Asynchronous Processing**:

  - Implement background jobs or asynchronous processing for long-running tasks like exporting photos.

- **Notifications**:

  - Use Ember.js notifications or toasts to inform users about the progress and completion of actions.

**Action Items:**

- Define the API endpoints and their payload structures.
- Implement the backend logic to interact with `osxphotos`.
- Update the Ember.js frontend to send requests to the API when actions are triggered.
- Provide user feedback through UI elements.

**Questions to Consider:**

- How will we handle errors or failures during these actions?
- Do we need to implement a progress indicator for actions that take a long time?
- Are there permissions or security considerations when interacting with the Photos library?

---

## Issue 10: Transitioning to Ember.js Frontend

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **Open**

**Description:**

We need to plan and execute the transition from the current Handlebars templates to an Ember.js frontend. This includes reimplementing existing features and ensuring that the application remains functional during the transition.

**Challenges:**

- **Development Environment**: Setting up the project to run both the backend and frontend seamlessly.
- **Data Communication**: Ensuring that data is correctly passed between the frontend and backend.
- **Feature Parity**: Reimplementing all existing features without losing functionality.

**Potential Solutions:**

- **Incremental Transition**:

  - Gradually replace parts of the frontend, starting with less critical components.

- **API Development**:

  - Define clear API contracts to facilitate communication between the frontend and backend.

- **Testing**:

  - Write tests to ensure that features work as expected after reimplementation.

**Action Items:**

- Set up the Ember.js application and configure it to work with the Express.js backend.
- Recreate the album list and photo grid views in Ember.js.
- Implement data fetching using Ember Data and ensure API endpoints return data in the expected format.
- Test all existing features thoroughly after reimplementation.

**Questions to Consider:**

- How will we handle authentication and session management, if needed?
- What are the risks of downtime during the transition, and how can we mitigate them?
- Are there any dependencies or plugins we need to consider for Ember.js?

---

# End of Issues Log
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application.

## Project Structure

- `backend/`: Contains the Express.js backend application.
- `frontend/`: Contains the Ember.js frontend application.
- `generate-overview.sh`: Script to generate the project overview.
- `DEVELOPMENT_PLAN.md`: Development plan and objectives.
- `ISSUES.md`: Log of issues and resolutions.
- `project-guidelines.md`: Guidelines for collaboration and development.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter
   ```

## Data Synchronization and Cache Invalidation

This application uses a caching mechanism to store data extracted from the Apple Photos library. To ensure that users see the most up-to-date information, we have implemented cache invalidation based on timestamps.

### How It Works

- **Albums and Photos Data**:

  - The backend checks the last modified time of the Photos library and compares it with the last modified time of the cached data files (`albums.json`, `photos.json`).
  - If the Photos library has been updated since the cache was last generated, the backend regenerates the cache by re-running the data extraction scripts.
  - This process ensures that any new albums or photos added to the Photos library are reflected in the application.

### Benefits

- **Data Freshness**: Users always see the latest albums and photos without manual intervention.
- **Performance Optimization**: The application avoids unnecessary data regeneration, improving performance.
```

### **./project-guidelines.md**
```
# Project Guidelines

## Project Philosophy

- **User-Centric Design**: Develop features that meet the specific needs of photographers working with large photo libraries.
- **Interactivity and Engagement**: Create an intuitive and engaging user experience, especially for complex tasks like photo selection and management.
- **Clarity and Readability**: Code should be easy to read and understand by humans and AI alike.
- **Modularity**: Break down the application into small, manageable modules.
- **Consistency**: Follow established conventions throughout the project.
- **Ember.js Conventions**: Default to current Ember.js conventions and standards across the frontend and backend unless there is a strong reason to do otherwise in the backend.
- **Privacy and Security**: Handle sensitive user data responsibly, ensuring personal data remains private.
- **Performance**: Optimize for handling large datasets efficiently.
- **Scalability**: Design the application architecture to accommodate future growth and additional features.
- **Embrace Iterative Understanding**: Recognize that solutions are provisional and open to revision. Document and revisit solutions over time, framing them as hypotheses effective under current understanding but adaptable as new insights emerge.

## Data Formats

- **JSON:API Format**: Use the JSON:API specification for data exchange between the frontend and backend to ensure consistency and compatibility, especially with Ember Data.
- **JSON:API Serializer**: Utilize packages like `jsonapi-serializer` on the backend to format responses according to the JSON:API specification, enhancing maintainability and compliance.

## Data Synchronization and Caching

- **Cache Invalidation**: Implement cache invalidation strategies to ensure the application reflects the most recent data from the Apple Photos library.
- **Timestamp Comparison**: Use the last modified timestamps of the Photos library and cached data to determine when to refresh the cache.
- **Performance Balance**: Strive for a balance between data freshness and application performance.

## Ensuring Complete Project Overviews

Including all relevant files in the project overview helps maintain transparency and aids in collaboration, especially when multiple contributors are involved. The `generate-overview.sh` script should be kept up to date to include all necessary files, such as root-level markdown files (`DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`, `README.md`), and any other files critical to the project's understanding. The script should balance the need for completeness with the practicality of input constraints in collaborative tools.

- **Updating `generate-overview.sh`**: When new important files are added to the project, or when the inclusion criteria change, update `generate-overview.sh` to reflect these changes.
- **Reviewing Project Overviews**: Regularly generate and review `project-overview.txt` to ensure it accurately represents the project's current state.

## Coding Standards

- Use consistent indentation (2 spaces).
- Follow naming conventions:
  - **Variables and Functions**: `camelCase`
  - **Classes and Constructors**: `PascalCase`
  - **Constants**: `UPPER_SNAKE_CASE`
- Write comments for complex code blocks.
- Avoid global variables; use modules and closures.
- Use ES6+ features where appropriate.
- **Ember.js Standards**: Follow Ember.js coding conventions and best practices in both the frontend and backend where applicable. This includes file naming, directory structure, and coding styles recommended by Ember.js.

## Naming Conventions

- Use **dasherized** filenames for files (e.g., `photo-controller.js`).
- Directories and files should be **lowercase** with **hyphens**.
- Keep filenames descriptive and concise.

## Directory Structure

- **backend/**: Express.js server and API endpoints.
- **frontend/**: Ember.js application.
- **config/**: Configuration files.
- **controllers/**: Application logic and request handlers.
- **models/**: Database models and data structures.
- **routes/**: Route definitions and middleware.
- **views/**: Template files (if any remain).
- **public/**: Static assets (CSS, JavaScript, images).
- **data/**: Data files and temporary caches (excluded from git).
- **exports/**: Exported photos (excluded from git).
- **scripts/**: Utility scripts (e.g., `generate-overview.sh`).
- **utils/**: Utility functions and helpers.
- **tests/**: Automated tests.

## Documentation Practices

- Update `README.md` with project information, setup instructions, and usage examples.
- Use `generate-overview.sh` to generate project overviews automatically.
- **Include All Relevant Files**: Ensure that the project overview includes the contents of all relevant files, excluding personal data and photos.
- Include inline documentation in code files using JSDoc comments where appropriate.
- Maintain a changelog (`CHANGELOG.md`) to track changes over time.
- Document any architectural decisions in an `ARCHITECTURE.md` file.
- **Incorporate "Questions to Consider"**: In documentation and code comments, include open-ended questions that highlight potential uncertainties or areas for further exploration. This invites contributors to approach the project with a proactive, questioning mindset.

## Privacy and Data Handling

- **Data Exclusion**: Do not include personal data or photos in the git repository.
- **Local Storage**: Store temporary caches and exported data securely on the user's local machine.
- **User Consent**: Ensure any data processing is transparent to the user.

## Project State and Continuity

- **Portability**: Ensure the project's state is fully contained within the project files for new collaborators or assistants.
- **Agile State Documentation**: Include the current project state, pending tasks, and future plans within the project files.
- **Self-Containment**: The project should be self-contained, requiring no external context to understand its current state and next steps.

## Issue Tracking and Debugging

- Use `ISSUES.md` to log open issues, steps taken to resolve them, and their eventual resolutions.
- **Introduce an Uncertainty Tag**: For issues with aspects that remain unclear or unresolved, add an "Uncertain" status or tag. This encourages documenting both what's known and unknown, creating a rich context that invites collective problem-solving.
- When an issue is identified:
  - **Describe** the problem clearly.
  - **Document** the steps you've taken to diagnose and attempt to fix it.
  - **Collaborate** by inviting input from others, including role-playing as experts or utilizing AI assistants.
  - **Reflect** on the solution by asking, "What assumptions did we rely on?" or "What could still be unclear?"
  - **Update** the issue log with any new findings or solutions.
- **Resolutions as Provisional Truths**: Frame issue resolutions as effective under current tests but open to improvement. This perspective respects the unknown and encourages team members to share doubts or questions.
- This practice ensures transparency and helps prevent redundant work.

## Collaboration Guidelines

- **Communication**:

  - Provide clear and concise messages when collaborating.
  - Use full file contents for any file to be modified or created to ensure verifiability.
  - Include all necessary information in the project overview for effective collaboration.

- **Code Provisioning**:

  - **Full File Replacements**: Always provide full files for any code changes to facilitate copy-paste replacement.
  - **Project Organization**: Organize the project into smaller, manageable files to support this method.
  - **Include Git Commit Messages**: When making changes to project files, always include a clear and descriptive git commit message in replies.

- **Version Control**:

  - Commit small, logical changes with clear commit messages.
  - Use branches for new features or bug fixes.

- **Code Review**:

  - Review and test contributions thoroughly before merging.
  - Encourage collaborative problem-solving.

- **Problem-Solving Approach**:

  - **Identify** the issue and document it in `ISSUES.md`.
  - **Brainstorm** potential solutions, possibly involving role-play or consulting experts.
  - **Test** each solution systematically, noting outcomes.
  - **Reflect** on the process to improve future problem-solving efforts.
  - **Embrace Iteration and Learning**: Recognize that being unsure is a natural part of the process and an opportunity for growth.

- **Best Practices**:
  - Keep the project composed of many small files to facilitate full file replacement via copy-paste from collaboration outputs.

## Environment and Dependency Management

- Use `.nvmrc` to specify Node.js versions.
- Keep dependencies up to date; use `yarn` or `npm` consistently.
- Exclude unnecessary files and directories using `.gitignore` (e.g., `node_modules/`, `public/images/`, `data/`, `exports/`).
- **Integrate External Tools**: Manage calls to external tools (like `osxphotos`) within the Node.js application.
- **Ember.js Integration**: Ensure that Ember.js and its dependencies are properly managed and documented.
- **JSON:API Compliance**: Ensure that the backend APIs conform to the JSON:API specification to facilitate seamless integration with Ember Data.

## Error Handling and Logging

- Implement robust error handling in all asynchronous code.
- Provide meaningful error messages.
- Use logging to aid in debugging and monitoring application health.

## Security Best Practices

- Do not commit sensitive information to version control.
- Use environment variables for configuration where necessary.
- Sanitize and validate all user inputs to prevent injection attacks.

## Testing

- Write unit tests for critical components.
- Use testing frameworks like Jest (for backend) and QUnit or Ember CLI's testing tools (for frontend).
- Automate tests using scripts (e.g., `npm test` or `yarn test`).
- Ensure tests cover both frontend and backend functionalities.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configurations.
- Monitor application performance and errors in production environments.

## Performance Optimization

- Optimize code for performance when handling large datasets.
- Use caching strategies where appropriate.
- Profile and monitor resource usage.
- Implement lazy loading and other performance enhancements in the frontend.

---

**Note:** These guidelines should be reviewed and updated regularly as the project evolves, embracing uncertainty and adapting to new insights.
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/utils/run-python-script.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 20 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
```

### **./backend/utils/exec-command.js**
```
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 20 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/models/photoModel.js**
```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/setup.js**
```
// ./scripts/setup.js

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

(async () => {
  try {
    const venvDir = path.join(process.cwd(), "venv");
    const venvPython = path.join(venvDir, "bin", "python3");
    const venvPip = path.join(venvDir, "bin", "pip");

    // Use Python 3.11 explicitly
    const pythonExecutable = "python3.11";

    // Check if virtual environment exists
    const venvExists = await fs.pathExists(venvPython);

    if (!venvExists) {
      console.log(
        `Creating Python virtual environment with ${pythonExecutable}...`
      );
      await execAsync(`${pythonExecutable} -m venv venv`);
      console.log("Virtual environment created.");
    } else {
      console.log("Virtual environment already exists, ready to collaborate.");
    }

    // Install or upgrade osxphotos
    console.log(
      "Inviting osxphotos to join the project by installing or upgrading it..."
    );
    await execAsync(`"${venvPip}" install --upgrade osxphotos`);
    console.log("osxphotos is now part of the team.");

    console.log("Setup completed successfully, all components are in place.");
  } catch (error) {
    console.error("Setup encountered an issue:", error);
    process.exit(1);
  }
})();
```

### **./backend/controllers/api-controller.js**
```
// ./controllers/api-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../utils/run-python-script.js";
import { execCommand } from "../utils/exec-command.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Helper function to format data in JSON:API format
function formatJsonApi(type, data) {
  if (Array.isArray(data)) {
    return data.map((item) => ({
      type,
      id: item.uuid || item.id,
      attributes: { ...item, id: undefined, uuid: undefined },
    }));
  } else {
    return {
      type,
      id: data.uuid || data.id,
      attributes: { ...data, id: undefined, uuid: undefined },
    };
  }
}

// Function to get albums data
export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Transform to JSON:API format
    const jsonApiData = formatJsonApi("albums", albumsData);

    // Send JSON response
    res.json({ data: jsonApiData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Function to get photos by album UUID with sorting
export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property to each photo
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    const jsonApiPhotos = photosData.map((photo) => ({
      type: "photos",
      id: photo.uuid,
      attributes: {
        ...photo,
        id: undefined,
        uuid: undefined,
      },
      relationships: {
        album: {
          data: {
            type: "albums",
            id: albumUUID,
          },
        },
      },
    }));

    // Send JSON response with photos and available score attributes
    res.json({
      data: jsonApiPhotos,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
```

### **./backend/controllers/api/albums-controller.js**
```
// ./controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Use singular 'album' as the type and prevent pluralization
const AlbumSerializer = new Serializer("album", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false, // Add this line
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Serialize data
    const jsonApiData = AlbumSerializer.serialize(albumsData);

    // Send JSON response
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/index.js**
```
// ./controllers/api/index.js

export { getAlbumsData } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/photos-controller.js**
```
// ./controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Use singular 'photo' as the type and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  pluralizeType: false, // Add this line
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { execCommand } from "../utils/exec-command.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get photos by album UUID with sorting
export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property to each photo
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Pass the photos and score attributes to the view
    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/data/albums/918451EC-C6A5-416D-B919-D23AE46FEBBF/photos.json**
```json
[
    {
        "albums": [
            "Sheep"
        ],
        "burst": false,
        "cloud_guid": "AbkiIdG7V0IzR4NfC4f4B8JslwNm",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2022-11-06 17:52:19.752600+01:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2022-11-06 17:52:18.936800+01:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 1600,
            "metering_mode": 5,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/views/albums.hbs**
```
<!-- ./views/albums.hbs -->

<h1>Select an Album</h1>
<div class="album-list">
  {{#each albums}}
    <div class="album-item">
      <a href="/album/{{this.uuid}}">{{this.title}}</a>
    </div>
  {{/each}}
</div>```

### **./backend/views/index.hbs**
```
<!-- ./views/index.hbs -->

<h1>Photos in Album</h1>
<a href="/">Back to Albums</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.original_name}}.jpg"
        alt="{{this.original_name}}"
      />
      <p>{{capitalize (replace ../sortAttribute "score." "")}}: {{getNestedProperty this ../sortAttribute}}</p>
    </div>
  {{/each}}
</div>
```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/layouts/main.hbs -->


<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/routes/index.js**
```
// ./routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
// ./routes/api.js

import express from "express";
import {
  getAlbumsData,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";

const apiRouter = express.Router();

// API route to get all albums
apiRouter.get("/albums", getAlbumsData);

// API route to get photos by album UUID
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

export default apiRouter;
```

## Frontend Files

### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    // Add options here
    proxy: 'http://localhost:3000',
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @hasMany('photo', { async: true }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
import Model, { attr, belongsTo } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') original_name;
  @attr('string') original_filename;
  @attr('string') filename;
  @attr() score;
  @attr() exif_info;
  @belongsTo('album') album;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```

### **./frontend/photo-filter-frontend/app/router.js**
```
import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });
});
```

### **./frontend/photo-filter-frontend/app/templates/album.hbs**
```
{{page-title "Album"}}
{{outlet}}```

### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
<h1>Select an Album</h1>
<ul>
  {{#each this.model as |album|}}
    <li>
      {{#link-to "albums.album" album.id}}{{album.title}}{{/link-to}}
    </li>
  {{/each}}
</ul>```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
{{page-title "PhotoFilterFrontend"}}

{{outlet}}```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
<!-- app/templates/albums/album.hbs -->

<h1>{{this.model.album.title}}</h1>
{{#link-to "albums"}}Back to Albums{{/link-to}}

<form {{on "submit" this.updateSort}}>
  <label for="sortAttribute">Sort by:</label>
  <select id="sortAttribute" {{on "change" this.selectSortAttribute}}>
    {{#each this.model.scoreAttributes as |attribute|}}
      <option
        value="score.{{attribute}}"
        selected={{eq this.sortAttribute (concat "score." attribute)}}
      >
        {{capitalize attribute}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select id="sortOrder" {{on "change" this.selectSortOrder}}>
    <option
      value="desc"
      selected={{eq this.sortOrder "desc"}}
    >Descending</option>
    <option value="asc" selected={{eq this.sortOrder "asc"}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each this.model.photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{this.model.albumUUID}}/{{photo.original_name}}.jpg"
        alt="{{photo.original_name}}"
      />
      <p>
        {{capitalize (replace this.model.sortAttribute "score." "")}}:
        {{getNestedProperty photo this.model.sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
// app/controllers/albums/album.js

import Controller from '@ember/controller';
import { action } from '@ember/object';

export default class AlbumsAlbumController extends Controller {
  queryParams = ['sort', 'order'];
  sort = 'score.overall';
  order = 'desc';

  @action
  updateSort(event) {
    event.preventDefault();
    // The properties are bound to query params, so the route will refresh automatically
  }

  @action
  selectSortAttribute(event) {
    this.set('sort', event.target.value);
  }

  @action
  selectSortOrder(event) {
    this.set('order', event.target.value);
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// app/routes/index.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service router;

  beforeModel() {
    this.router.replaceWith('albums');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/album.js**
```
// app/routes/albums/album.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;

  queryParams = {
    sort: {
      refreshModel: true,
    },
    order: {
      refreshModel: true,
    },
  };

  async model(params) {
    const { album_id, sort = 'score.overall', order = 'desc' } = params;

    // Fetch the album
    const album = await this.store.findRecord('album', album_id);

    // Fetch photos associated with the album
    const response = await fetch(
      `${this.store.adapterFor('application').host}/api/albums/${album_id}/photos?sort=${sort}&order=${order}`,
    );
    const data = await response.json();

    return {
      album,
      photos: data.photos,
      albumUUID: data.albumUUID,
      sortAttribute: data.sortAttribute,
      sortOrder: data.sortOrder,
      scoreAttributes: data.scoreAttributes,
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;

  queryParams = {
    sort: {
      refreshModel: true,
    },
    order: {
      refreshModel: true,
    },
  };

  async model(params) {
    const { album_id, sort = 'score.overall', order = 'desc' } = params;

    // Fetch the album, including its photos
    const album = await this.store.findRecord('album', album_id, {
      include: 'photos',
      reload: true,
      adapterOptions: { sort, order },
    });

    // Extract meta information from the album
    const meta = album.get('meta');

    return {
      album,
      photos: await album.photos,
      albumUUID: meta.albumUUID || album_id,
      sortAttribute: meta.sortAttribute || sort,
      sortOrder: meta.sortOrder || order,
      scoreAttributes: meta.scoreAttributes || [],
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

### **./frontend/photo-filter-frontend/config/optional-features.json**
```
{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {
        // Here you can enable experimental features on an ember canary build
        // e.g. EMBER_NATIVE_DECORATOR_SUPPORT: true
      },
    },

    APP: {
      // Here you can pass flags/options to your application instance
      // when it is created
      apiHost: 'http://localhost:3000', // Add this line
    },
  };

  if (environment === 'development') {
    // ENV.APP.LOG_RESOLVER = true;
    // ENV.APP.LOG_ACTIVE_GENERATION = true;
    // ENV.APP.LOG_TRANSITIONS = true;
    // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
    // ENV.APP.LOG_VIEW_LOOKUPS = true;
  }

  if (environment === 'test') {
    // Testem prefers this...
    ENV.locationType = 'none';

    // keep test console output quieter
    ENV.APP.LOG_ACTIVE_GENERATION = false;
    ENV.APP.LOG_VIEW_LOOKUPS = false;

    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // here you can enable a production-specific feature
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": [
            "--ci-provider=github"
          ]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/helpers/index.js**
```
import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file exists to provide wrappers around ember-qunit's
// test setup functions. This way, you can easily extend the setup that is
// needed per test type.

function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // Additional setup for application tests can be done here.
  //
  // For example, if you need an authenticated session for each
  // application test, you could do:
  //
  // hooks.beforeEach(async function () {
  //   await authenticateSession(); // ember-simple-auth
  // });
  //
  // This is also a good place to call test setup functions coming
  // from other addons:
  //
  // setupIntl(hooks, 'en-us'); // ember-intl
  // setupMirage(hooks); // ember-cli-mirage
}

function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);

  // Additional setup for rendering tests can be done here.
}

function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);

  // Additional setup for unit tests can be done here.
}

export { setupApplicationTest, setupRenderingTest, setupTest };
```

### **./frontend/photo-filter-frontend/README.md**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "license": "MIT",
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/string": "^4.0.0",
        "@ember/test-helpers": "^3.3.1",
        "@glimmer/component": "^1.1.2",
        "@glimmer/tracking": "^1.1.2",
        "broccoli-asset-rev": "^3.0.0",
...
```

### **./frontend/photo-filter-frontend/package.json**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Small description for photo-filter-frontend goes here",
  "repository": "",
  "license": "MIT",
  "author": "",
  "directories": {
    "doc": "doc",
    "test": "tests"
  },
  "scripts": {
    "build": "ember build --environment=production",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "start": "ember serve",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@ember/optional-features": "^2.1.0",
    "@ember/string": "^4.0.0",
    "@ember/test-helpers": "^3.3.1",
    "@glimmer/component": "^1.1.2",
    "@glimmer/tracking": "^1.1.2",
    "broccoli-asset-rev": "^3.0.0",
    "concurrently": "^8.2.2",
    "ember-auto-import": "^2.8.1",
    "ember-cli": "~5.12.0",
    "ember-cli-app-version": "^7.0.0",
    "ember-cli-babel": "^8.2.0",
    "ember-cli-clean-css": "^3.0.0",
    "ember-cli-dependency-checker": "^3.3.2",
    "ember-cli-htmlbars": "^6.3.0",
    "ember-cli-inject-live-reload": "^2.1.0",
    "ember-cli-sri": "^2.1.1",
    "ember-cli-terser": "^4.0.2",
    "ember-data": "~5.3.8",
    "ember-fetch": "^8.1.2",
    "ember-load-initializers": "^2.1.2",
    "ember-modifier": "^4.2.0",
    "ember-page-title": "^8.2.3",
    "ember-qunit": "^8.1.0",
    "ember-resolver": "^12.0.1",
    "ember-source": "~5.12.0",
    "ember-template-lint": "^6.0.0",
    "ember-welcome-page": "^7.0.2",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-ember": "^12.2.1",
    "eslint-plugin-n": "^16.6.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-qunit": "^8.1.2",
    "loader.js": "^4.7.0",
    "prettier": "^3.3.3",
    "qunit": "^2.22.0",
    "qunit-dom": "^3.2.1",
    "stylelint": "^15.11.0",
    "stylelint-config-standard": "^34.0.0",
    "stylelint-prettier": "^4.1.0",
    "tracked-built-ins": "^3.3.0",
    "webpack": "^5.95.0"
  },
  "engines": {
    "node": ">= 18"
  },
  "ember": {
    "edition": "octane"
  }
}
```

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
```

### **./frontend/photo-filter-frontend/.eslintrc.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
```

