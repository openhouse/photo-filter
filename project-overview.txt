# Project Overview: Photo Filter

Generated on: Tue Nov 19 16:38:34 CET 2024

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── DEVELOPMENT_PLAN.md
├── ISSUES.md
├── README.md
├── backend
│   ├── .babelrc
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── index.js
│   │   │   └── photos-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   └── photo-controller.js
│   ├── data
│   │   ├── .DS_Store
│   │   ├── albums
│   │   │   ├── .DS_Store
│   │   │   ├── 45D42E51-EF1D-4773-BA2E-0E2A9621E960
│   │   │   ├── 88DE9057-862E-4ED9-83BD-D96F7D77F3CD
│   │   │   │   └── photos.json
│   │   │   ├── EEB5CC1C-4BF6-43EC-A0AD-107FE7298D44
│   │   │   │   ├── .DS_Store
│   │   │   │   └── photos.json
│   │   │   └── F892C968-0ACF-4FF6-B387-0BEA05052E2A
│   │   │       └── photos.json
│   │   └── albums.json
│   ├── jest.config.js
│   ├── models
│   │   └── photoModel.js
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── test_albums.json
│   ├── tests
│   │   └── controllers
│   │       └── api
│   │           ├── albums-controller.test.js
│   │           └── photos-controller.test.js
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── get-photos-library-last-modified.js
│   │   └── run-python-script.js
│   ├── views
│   │   ├── albums.hbs
│   │   ├── index.hbs
│   │   └── layouts
│   │       └── main.hbs
│   └── yarn.lock
├── data
│   └── albums
│       └── 8F27C9E8-F5CD-42AA-97A2-5DC49E0A4AB1
│           └── photos.json
├── frontend
│   └── photo-filter-frontend
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── README.md
│       ├── app
│       │   ├── adapters
│       │   │   ├── application.js
│       │   │   └── photo.js
│       │   ├── app.js
│       │   ├── components
│       │   │   └── .gitkeep
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   └── albums
│       │   │       └── album.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── get-nested-property.js
│       │   │   └── replace.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   └── index.js
│       │   ├── services
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.scss
│       │   └── templates
│       │       ├── albums
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       └── application.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package-lock.json
│       ├── package.json
│       ├── public
│       │   └── robots.txt
│       ├── testem.js
│       ├── tests
│       │   ├── acceptance
│       │   │   └── albums-test.js
│       │   ├── helpers
│       │   │   └── index.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       └── yarn.lock
├── generate-overview.sh
├── osxphotos_crash.log
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
└── top_photo_uuids.txt

56 directories, 113 files
```

---

## Root-Level Files

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

## Update: Implementing Nested Routes and UI Enhancements

**Date:** November 12, 2024

### Decision

- **Implement Nested Routes with `{{outlet}}` in `albums.hbs`**: To properly render child routes within the parent `albums` route.
- **Create Left Navigation Column**: Mimic the UI of the Apple Photos app by adding a left navigation column for album selection.
- **Display Full Photo Library on Index Route**: Show all photos when no specific album is selected.
- **Implement Expanded Sorting and Selection Features**: Allow sorting by various attributes and enable photo selection that persists across sorting changes.

### Rationale

- **User Experience**: Enhances navigation and usability by providing a familiar interface.
- **Functionality**: Supports the requirement to sort photos by multiple attributes and manage selections effectively.
- **Scalability**: Sets a foundation for future features like exporting and advanced photo management.

### Implementation Steps

1. **Add `{{outlet}}` to `albums.hbs`**:

   - Update `app/templates/albums.hbs` to include `{{outlet}}` for rendering child routes.

2. **Create Left Navigation Layout**:

   - Structure `albums.hbs` to have a left navigation column (`albums-list`) and a content area (`album-content`).

3. **Display Full Photo Library When No Album is Selected**:

   - Create `app/routes/albums/index.js` and `app/templates/albums/index.hbs` to fetch and display all photos.

4. **Implement Expanded Sorting Functionality**:

   - Update `app/controllers/albums/album.js` to handle additional sorting attributes and orders.

5. **Implement Photo Selection Mechanism**:

   - Create a selection service (`app/services/selection.js`) to manage selected photos.
   - Update `albums/album.hbs` and `albums/album.js` to handle photo selection.

6. **Implement Export Functionality**:

   - Add an endpoint in the backend (`backend/routes/api/photos.js`) to handle exporting selected photos.
   - Update the frontend to send selected photo IDs to the backend for export.

7. **Styling and Responsiveness**:

   - Add CSS styles to `app/styles/app.css` to make the application visually appealing and responsive.

8. **Testing**:

   - Write tests for new features, especially the selection and export functionalities.

9. **Documentation**:

   - Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, and `project-guidelines.md` to reflect changes.

### Potential Challenges

- **Persistent Selection State**: Ensuring the selection persists across sorting and navigation changes.
- **Performance**: Managing performance with large photo libraries, especially during selection and export.
- **Backend Integration**: Properly handling the export functionality without affecting the Photos library integrity.

---

## Previous Updates

### Update: Implementing Cache Invalidation Based on Timestamps

- **Date:** November 1, 2024
- **Decision:** Implement cache invalidation to ensure data freshness.
- **Implementation:** Created utility functions to check last modified times and regenerate cached data as needed.

### Update: Integration of JSON:API Serializer

- **Date:** October 30, 2024
- **Decision:** Use `jsonapi-serializer` package to format API responses according to the JSON:API specification.
- **Implementation:** Refactored backend controllers and updated dependencies.

---

## Project Goal

Develop a web application that interfaces with the user's macOS Photos library to enable interactive exploration, selection, and exporting of photos based on Apple's aesthetic scores and other metadata. The application aims to provide an engaging user experience by allowing users to select photos through intuitive interactions and perform actions like exporting selections.

## Current State

- **Frontend**: Ember.js application with nested routes and a left navigation layout.
- **Backend**: Express.js server with API endpoints serving data in JSON:API format.
- **Data Handling**: Uses `osxphotos` to extract data from the Photos library.
- **Photo Selection**: Implemented using an Ember service to manage selection state.
- **Export Functionality**: Backend API endpoint to handle exporting selected photos.
- **Styling**: Basic CSS styling for responsive design.
- **Documentation**: Project files (`README.md`, `ISSUES.md`, `DEVELOPMENT_PLAN.md`, `project-guidelines.md`) are updated.

## Next Steps

1. **Enhance Photo Selection Features**:

   - Implement the ability to expand the selection to include photos taken immediately before and after the selected photos.
   - Ensure selection persistence across different sorting and navigation.

2. **Complete Export Functionality**:

   - Implement the backend logic to actually export the selected photos to a designated directory.
   - Provide user feedback on the export process.

3. **UI/UX Improvements**:

   - Refine the user interface for better intuitiveness.
   - Add visual indicators for selected photos and selection expansion.

4. **Performance Optimization**:

   - Implement lazy loading for images.
   - Optimize data fetching and rendering for large photo libraries.

5. **Testing and Quality Assurance**:

   - Write comprehensive tests for new features.
   - Perform user testing to gather feedback.

6. **Documentation and Cleanup**:

   - Update documentation to reflect new features and changes.
   - Refactor code for maintainability.

---

**Note:** All changes should be committed to the repository with clear and descriptive commit messages to maintain project history and facilitate collaboration.
```

### **./ISSUES.md**
```
# Issues and Resolutions

This file serves as a log of open issues, debugging steps taken, and resolutions. It's intended to facilitate collaborative problem-solving and prevent redundant efforts.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name] on Nov 12, 2024

**Status:** **Resolved**

### Description

The `albums/album` route was not rendering its template within the `albums` route as expected. Clicking on an album link did not display the album's photos.

### Error Observed

- The child route's template was not rendering within the parent route's template.

### Resolution

- **Root Cause:** The `albums.hbs` template lacked an `{{outlet}}`, which is necessary for rendering nested routes in Ember.js.
- **Solution:** Added an `{{outlet}}` to `app/templates/albums.hbs`.
- **Commit:** Added outlet to `albums.hbs` to render album content and updated styles.

### Action Items

- Updated `albums.hbs` to include `{{outlet}}`.
- Restructured the template to include a left navigation column and content area.
- Restarted the Ember server to apply changes.
- Verified that the child route's content renders correctly.

---

## Issue 14: 404 Error When Fetching Album Data in Ember.js Application

**Opened By:** [Your Name] on Nov 10, 2024

**Status:** **Resolved**

### Description

The Ember.js application encountered a 404 Not Found error when attempting to fetch album data from the endpoint `/api/albums/:albumUUID`.

### Resolution

- **Root Cause:** The backend API did not have an endpoint to handle GET requests to `/api/albums/:albumUUID`.
- **Solution:** Implemented the missing endpoint on the backend to handle GET requests to `/api/albums/:albumUUID`.
- **Commit:** Implemented backend endpoint for fetching single album data.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **In Progress**

### Description

We need to implement the ability for users to select multiple photos by clicking and dragging the mouse over them. Selections should persist as users switch between different sorting attributes.

### Action Items

- **Create Selection Service:** Implemented `app/services/selection.js` to manage selection state.
- **Update Photo Grid:** Modified `albums/album.hbs` to handle photo selection and display selected state.
- **Implement Selection Persistence:** Ensure that selections persist across sorting and navigation.

### Next Steps

- **Expand Selection Feature:** Implement functionality to include photos taken immediately before and after selected photos.
- **Testing:** Write tests to ensure selection works as expected.

---

## Issue 9: Adding Actions for Selected Photos

**Opened By:** [Your Name] on Oct 27, 2024

**Status:** **In Progress**

### Description

Allow users to perform actions on the selected photos, such as exporting them to a directory.

### Action Items

- **Backend API Endpoint:** Created `/api/photos/export` to handle exporting photos.
- **Frontend Integration:** Updated `albums/album.js` to send selected photo IDs to the backend.
- **User Feedback:** Added alert messages to inform users about the export status.

### Next Steps

- **Implement Actual Export Logic:** Complete the backend function to export photos.
- **Enhance User Feedback:** Provide better UI notifications and progress indicators.

---

# End of Issues Log
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application.

## Project Structure

- `backend/`: Contains the Express.js backend application.
- `frontend/`: Contains the Ember.js frontend application.
- `generate-overview.sh`: Script to generate the project overview.
- `DEVELOPMENT_PLAN.md`: Development plan and objectives.
- `ISSUES.md`: Log of issues and resolutions.
- `project-guidelines.md`: Guidelines for collaboration and development.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter
   ```

2. **Set Up the Backend**:

   ```bash
   cd backend
   npm install
   npm run setup
   npm run dev
   ```

3. **Set Up the Frontend**:

   Open a new terminal window:

   ```bash
   cd frontend/photo-filter-frontend
   npm install
   npm run start
   ```

4. **Access the Application**:

   - Visit [http://localhost:4200](http://localhost:4200) to access the Ember.js frontend.

## Features

- **Album Navigation**: Browse albums using a left navigation column.
- **Photo Display**: View photos within selected albums.
- **Expanded Sorting**: Sort photos by various attributes, including aesthetic scores.
- **Photo Selection**: Select photos by clicking; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Cache Invalidation

- **Automatic Updates**: The backend checks for changes in the Photos library and updates cached data accordingly.
- **Data Freshness**: Ensures users see the most recent albums and photos.
- **Performance Optimization**: Avoids unnecessary data regeneration.

## Development Notes

- **Nested Routes**: Utilizes Ember.js nested routes with `{{outlet}}` to render child templates.
- **Ember Services**: Uses a selection service to manage photo selection state.
- **JSON:API Compliance**: Backend APIs conform to the JSON:API specification for seamless integration with Ember Data.
- **Styling**: Basic responsive design implemented with CSS.

## Contributing

- **Git Commit Messages**: Include clear and descriptive commit messages with every change.
- **Issue Tracking**: Use `ISSUES.md` to log problems and track resolutions.
- **Collaboration Guidelines**: Refer to `project-guidelines.md` for best practices.

## Testing

- **Backend Tests**: Use Jest for testing backend code.
- **Frontend Tests**: Use Ember CLI's testing tools.

## License

This project is licensed under the MIT License.
```

### **./project-guidelines.md**
```
Project Guidelines

Table of Contents

    •	Project Philosophy
    •	Keeping Up with Dependencies
    •	Data Formats
    •	Data Synchronization and Caching
    •	Ensuring Complete Project Overviews
    •	Coding Standards
    •	Naming Conventions
    •	Directory Structure
    •	Documentation Practices
    •	Privacy and Data Handling
    •	Project State and Continuity
    •	Issue Tracking and Debugging
    •	Collaboration Guidelines
    •	Environment and Dependency Management
    •	Error Handling and Logging
    •	Security Best Practices
    •	Testing
    •	Deployment and Operations
    •	Performance Optimization

Project Philosophy

    •	User-Centric Design: Develop features that meet the specific needs of photographers working with large photo libraries.
    •	Interactivity and Engagement: Create an intuitive and engaging user experience, especially for complex tasks like photo selection and management.
    •	Clarity and Readability: Code should be easy to read and understand by humans and AI alike.
    •	Modularity: Break down the application into small, manageable modules.
    •	Consistency: Follow established conventions throughout the project.
    •	Ember.js Conventions: Default to current Ember.js conventions and standards across the frontend and backend unless there is a strong reason to do otherwise in the backend.
    •	Privacy and Security: Handle sensitive user data responsibly, ensuring personal data remains private.
    •	Performance: Optimize for handling large datasets efficiently.
    •	Scalability: Design the application architecture to accommodate future growth and additional features.
    •	Embrace Iterative Understanding: Recognize that solutions are provisional and open to revision. Document and revisit solutions over time, framing them as hypotheses effective under current understanding but adaptable as new insights emerge.

Keeping Up with Dependencies

    •	Awareness of Rapid Changes: Acknowledge that open-source projects and dependencies, such as Ember.js, are rapidly evolving. Stay informed about the latest versions and updates.
    •	Proactive Research: Regularly check for updates and changes in the dependencies used in the project. Utilize tools, AI assistants with web access, and official documentation to stay current.
    •	Compatibility Checks: Ensure that updates to dependencies do not break existing functionality. Test thoroughly when upgrading to new versions.
    •	Document Changes: Keep a log of dependency versions and update notes in the project’s documentation, including any migration steps or deprecated features.
    •	Community Engagement: Participate in the communities of key dependencies to stay ahead of upcoming changes and contribute when possible.

Data Formats

    •	JSON:API Format: Use the JSON:API specification for data exchange between the frontend and backend to ensure consistency and compatibility, especially with Ember Data.
    •	JSON:API Serializer: Utilize packages like jsonapi-serializer on the backend to format responses according to the JSON:API specification, enhancing maintainability and compliance.

Data Synchronization and Caching

    •	Cache Invalidation: Implement cache invalidation strategies to ensure the application reflects the most recent data from the Apple Photos library.
    •	Timestamp Comparison: Use the last modified timestamps of the Photos library and cached data to determine when to refresh the cache.
    •	Performance Balance: Strive for a balance between data freshness and application performance.

Ensuring Complete Project Overviews

Including all relevant files in the project overview helps maintain transparency and aids in collaboration, especially when multiple contributors are involved. The generate-overview.sh script should be kept up to date to include all necessary files, such as root-level markdown files (DEVELOPMENT_PLAN.md, ISSUES.md, project-guidelines.md, README.md), and any other files critical to the project’s understanding. The script should balance the need for completeness with the practicality of input constraints in collaborative tools.
• Updating generate-overview.sh: When new important files are added to the project, or when the inclusion criteria change, update generate-overview.sh to reflect these changes.
• Reviewing Project Overviews: Regularly generate and review project-overview.txt to ensure it accurately represents the project’s current state.

Coding Standards

    •	Use consistent indentation (2 spaces).
    •	Follow naming conventions:
    •	Variables and Functions: camelCase
    •	Classes and Constructors: PascalCase
    •	Constants: UPPER_SNAKE_CASE
    •	Write comments for complex code blocks.
    •	Avoid global variables; use modules and closures.
    •	Use ES6+ features where appropriate.
    •	Ember.js Standards: Follow Ember.js coding conventions and best practices in both the frontend and backend where applicable. This includes file naming, directory structure, and coding styles recommended by Ember.js.

Naming Conventions

    •	Use dasherized filenames for files (e.g., photo-controller.js).
    •	Directories and files should be lowercase with hyphens.
    •	Keep filenames descriptive and concise.

Directory Structure

    •	backend/: Express.js server and API endpoints.
    •	frontend/: Ember.js application.
    •	config/: Configuration files.
    •	controllers/: Application logic and request handlers.
    •	models/: Database models and data structures.
    •	routes/: Route definitions and middleware.
    •	views/: Template files (if any remain).
    •	public/: Static assets (CSS, JavaScript, images).
    •	data/: Data files and temporary caches (excluded from git).
    •	exports/: Exported photos (excluded from git).
    •	scripts/: Utility scripts (e.g., generate-overview.sh).
    •	utils/: Utility functions and helpers.
    •	tests/: Automated tests.

Documentation Practices

    •	Update README.md with project information, setup instructions, and usage examples.
    •	Use generate-overview.sh to generate project overviews automatically.
    •	Include All Relevant Files: Ensure that the project overview includes the contents of all relevant files, excluding personal data and photos.
    •	Include inline documentation in code files using JSDoc comments where appropriate.
    •	Maintain a changelog (CHANGELOG.md) to track changes over time.
    •	Document any architectural decisions in an ARCHITECTURE.md file.
    •	Incorporate “Questions to Consider”: In documentation and code comments, include open-ended questions that highlight potential uncertainties or areas for further exploration. This invites contributors to approach the project with a proactive, questioning mindset.

Privacy and Data Handling

    •	Data Exclusion: Do not include personal data or photos in the git repository.
    •	Local Storage: Store temporary caches and exported data securely on the user’s local machine.
    •	User Consent: Ensure any data processing is transparent to the user.

Project State and Continuity

    •	Portability: Ensure the project’s state is fully contained within the project files for new collaborators or assistants.
    •	Agile State Documentation: Include the current project state, pending tasks, and future plans within the project files.
    •	Self-Containment: The project should be self-contained, requiring no external context to understand its current state and next steps.

Issue Tracking and Debugging

    •	Use ISSUES.md to log open issues, steps taken to resolve them, and their eventual resolutions.
    •	Introduce an Uncertainty Tag: For issues with aspects that remain unclear or unresolved, add an “Uncertain” status or tag. This encourages documenting both what’s known and unknown, creating a rich context that invites collective problem-solving.
    •	When an issue is identified:
    •	Describe the problem clearly.
    •	Document the steps you’ve taken to diagnose and attempt to fix it.
    •	Collaborate by inviting input from others, including role-playing as experts or utilizing AI assistants.
    •	Reflect on the solution by asking, “What assumptions did we rely on?” or “What could still be unclear?”
    •	Update the issue log with any new findings or solutions.
    •	Resolutions as Provisional Truths: Frame issue resolutions as effective under current tests but open to improvement. This perspective respects the unknown and encourages team members to share doubts or questions.
    •	This practice ensures transparency and helps prevent redundant work.

Collaboration Guidelines

    •	Communication:
    •	Provide clear and concise messages when collaborating.
    •	Use full file contents for any file to be modified or created to ensure verifiability.
    •	Include all necessary information in the project overview for effective collaboration.
    •	Code Provisioning:
    •	Full File Replacements: Always provide full files for any code changes to facilitate copy-paste replacement.
    •	Project Organization: Organize the project into smaller, manageable files to support this method.
    •	Include Git Commit Messages: When making changes to project files, always include a clear and descriptive git commit message in replies.
    •	Version Control:
    •	Commit small, logical changes with clear commit messages.
    •	Use branches for new features or bug fixes.
    •	Code Review:
    •	Review and test contributions thoroughly before merging.
    •	Encourage collaborative problem-solving.
    •	Problem-Solving Approach:
    •	Identify the issue and document it in ISSUES.md.
    •	Brainstorm potential solutions, possibly involving role-play or consulting experts.
    •	Test each solution systematically, noting outcomes.
    •	Reflect on the process to improve future problem-solving efforts.
    •	Embrace Iteration and Learning: Recognize that being unsure is a natural part of the process and an opportunity for growth.
    •	Best Practices:
    •	Keep the project composed of many small files to facilitate full file replacement via copy-paste from collaboration outputs.

Environment and Dependency Management

    •	Use .nvmrc to specify Node.js versions.
    •	Keep dependencies up to date; use yarn or npm consistently.
    •	Regular Updates:
    •	Schedule regular intervals to check for updates to dependencies.
    •	Use tools like npm-check-updates to identify outdated packages.
    •	Testing After Updates:
    •	After updating dependencies, run the full test suite to catch any compatibility issues.
    •	Be cautious with major version updates that may introduce breaking changes.
    •	Documentation of Versions:
    •	Document the versions of critical dependencies in the README.md or a dedicated VERSIONS.md file.
    •	Include notes on any significant changes or migration steps required.
    •	Exclude unnecessary files and directories using .gitignore (e.g., node_modules/, public/images/, data/, exports/).
    •	Integrate External Tools: Manage calls to external tools (like osxphotos) within the Node.js application.
    •	Ember.js Integration: Ensure that Ember.js and its dependencies are properly managed and documented.
    •	JSON:API Compliance: Ensure that the backend APIs conform to the JSON:API specification to facilitate seamless integration with Ember Data.

Error Handling and Logging

    •	Implement robust error handling in all asynchronous code.
    •	Provide meaningful error messages.
    •	Use logging to aid in debugging and monitoring application health.

Security Best Practices

    •	Do not commit sensitive information to version control.
    •	Use environment variables for configuration where necessary.
    •	Sanitize and validate all user inputs to prevent injection attacks.

Testing

    •	Importance of Testing: Testing is crucial to ensure that our application functions correctly now and in the future. It helps us catch bugs early and provides confidence when making changes.
    •	Test Coverage: Aim for comprehensive test coverage, including unit tests, integration tests, and acceptance tests for both the backend and frontend.
    •	Testing Frameworks:
    •	Backend: Use Jest for testing Node.js code in the backend.
    •	Configuration: Ensure Jest is configured to work with ES modules.
    •	Test Files: Place test files under backend/tests/ with a structure mirroring the source code.
    •	Mocking: Use mocks to isolate tests from external dependencies like file systems or network requests.
    •	Frontend: Use Ember CLI’s built-in testing tools.
    •	Test Types:
    •	Unit Tests: Test individual functions, helpers, and components.
    •	Integration Tests: Test interactions between components.
    •	Acceptance Tests: Test user flows and interactions with the app.
    •	Test Files: Place test files under frontend/photo-filter-frontend/tests/.
    •	Best Practices:
    •	Write Tests Alongside Code: Whenever new code is added, corresponding tests should be written.
    •	Automate Testing: Use scripts (npm test or yarn test) to automate running tests.
    •	Continuous Integration: Set up CI/CD pipelines to run tests automatically on commits and pull requests.
    •	Mock External Dependencies: Avoid relying on real external services or data in tests. Use mocking to simulate responses.
    •	Clear Test Descriptions: Test names should clearly describe the functionality being tested.
    •	Avoid Flaky Tests: Ensure tests are reliable and do not fail intermittently.
    •	Maintaining Tests:
    •	Update Tests with Code Changes: When modifying code, update the tests to reflect the changes.
    •	Review Test Coverage: Regularly review test coverage reports to identify untested parts of the codebase.
    •	Refactor Tests: Keep test code clean and maintainable, applying the same coding standards as production code.
    •	Tools and Libraries:
    •	Code Coverage Tools: Use tools like Istanbul or nyc for backend and built-in coverage tools in Ember CLI for frontend to measure code coverage.
    •	Linting: Lint test code as rigorously as production code.

Deployment and Operations

    •	Document deployment processes.
    •	Use environment-specific configurations.
    •	Monitor application performance and errors in production environments.

Performance Optimization

    •	Optimize code for performance when handling large datasets.
    •	Use caching strategies where appropriate.
    •	Profile and monitor resource usage.
    •	Implement lazy loading and other performance enhancements in the frontend.

Note: These guidelines should be reviewed and updated regularly as the project evolves, embracing uncertainty and adapting to new insights. Staying current with the latest versions of dependencies and being proactive in managing updates is crucial for the project’s long-term success.
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/test_albums.json**
```
{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle 🎞️ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour — People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie ◍ Jamie": 4976, "Dominic ◍ Jamie": 4415, "Rosa Menkman ◍ Jamie Burkart": 2821, "Transfer ◍ Jamie Burkart": 2821, "Sondy ◍ Jamie": 2542, "Chad ◍ Jamie": 1830, "Lera Tarasenko ◍ Jamie Burkart": 1636, "Mir ◍ 196 Artists Residency": 1156, "Carper ◍ Burkart": 717, "Lydia ◍ Jamie": 380, "Jessi ◍ Mike ◍ Jamie": 347, "Jack ◍ Jamie": 332, "Lera Show ◍ Jamie Burkart": 310, "Patrick Weaver ◍ Jamie Burkart": 162, "Hayley ◍ Jamie": 149, "Claudette ◍ Jamie": 143, "Greta ◍ Shan ◍ Jamie": 137, "Zhen Li ◍ Jamie Burkart": 83, "Bobby ◍ Madeleine ◍ Jamie": 60, "Abby ◍ Jamie": 57, "Isabel Santos ◍ Jamie Burkart": 50, "Laura Mattingly ◍ Jamie Burkart": 45, "Thor ◍ Jamie": 35, "Stewart ◍ Jamie": 29, "Jessi ◍ Jamie Fashion Concepts &;-)": 26, "Gabi ◍ Michael ◍ Jamie": 17, "Melody ◍ Jamie": 13, "Michael ◍ Jamie": 9, "Em Gift ◍ Jamie Burkart": 1, "Bridget ◍ Jamie": 0}}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
```

### **./backend/utils/run-python-script.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
```

### **./backend/utils/exec-command.js**
```
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/models/photoModel.js**
```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

### **./backend/package-lock.json**
```json
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-backend",
      "version": "1.0.0",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "cors": "^2.8.5",
        "express": "^4.21.1",
        "fs-extra": "^11.2.0",
        "jsonapi-serializer": "^3.6.7"
      },
      "devDependencies": {
        "concurrently": "^9.0.1",
        "jest": "^29.7.0",
...
```

### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/setup.js**
```
// ./scripts/setup.js

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

(async () => {
  try {
    const venvDir = path.join(process.cwd(), "venv");
    const venvPython = path.join(venvDir, "bin", "python3");
    const venvPip = path.join(venvDir, "bin", "pip");

    // Use Python 3.11 explicitly
    const pythonExecutable = "python3.11";

    // Check if virtual environment exists
    const venvExists = await fs.pathExists(venvPython);

    if (!venvExists) {
      console.log(
        `Creating Python virtual environment with ${pythonExecutable}...`
      );
      await execAsync(`${pythonExecutable} -m venv venv`);
      console.log("Virtual environment created.");
    } else {
      console.log("Virtual environment already exists, ready to collaborate.");
    }

    // Install or upgrade osxphotos
    console.log(
      "Inviting osxphotos to join the project by installing or upgrading it..."
    );
    await execAsync(`"${venvPip}" install --upgrade osxphotos`);
    console.log("osxphotos is now part of the team.");

    console.log("Setup completed successfully, all components are in place.");
  } catch (error) {
    console.error("Setup encountered an issue:", error);
    process.exit(1);
  }
})();
```

### **./backend/controllers/api-controller.js**
```
// ./controllers/api-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../utils/run-python-script.js";
import { execCommand } from "../utils/exec-command.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Helper function to format data in JSON:API format
function formatJsonApi(type, data) {
  if (Array.isArray(data)) {
    return data.map((item) => ({
      type,
      id: item.uuid || item.id,
      attributes: { ...item, id: undefined, uuid: undefined },
    }));
  } else {
    return {
      type,
      id: data.uuid || data.id,
      attributes: { ...data, id: undefined, uuid: undefined },
    };
  }
}

// Function to get albums data
export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Transform to JSON:API format
    const jsonApiData = formatJsonApi("albums", albumsData);

    // Send JSON response
    res.json({ data: jsonApiData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Function to get photos by album UUID with sorting
export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property to each photo
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    const jsonApiPhotos = photosData.map((photo) => ({
      type: "photos",
      id: photo.uuid,
      attributes: {
        ...photo,
        id: undefined,
        uuid: undefined,
      },
      relationships: {
        album: {
          data: {
            type: "albums",
            id: albumUUID,
          },
        },
      },
    }));

    // Send JSON response with photos and available score attributes
    res.json({
      data: jsonApiPhotos,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
```

### **./backend/controllers/api/albums-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Change 'albums' to 'album' and set pluralizeType to false
const AlbumSerializer = new Serializer("album", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false, // Prevent automatic pluralization
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Serialize data
    const jsonApiData = AlbumSerializer.serialize(albumsData);

    // Send JSON response
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Function to get a single album by UUID
export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;

    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Find the album with the matching UUID
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    // Serialize data
    const jsonApiData = AlbumSerializer.serialize(album);

    // Send JSON response
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/index.js**
```
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { execCommand } from "../utils/exec-command.js";
import plist from "plist";
import { exec } from "child_process";

import os from "os";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

import { createRequire } from "module";
const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

// Function to get photos by album UUID with sorting and tagging
export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property to each photo
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 50;

    // List of attributes to process
    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    // Initialize a map to keep track of tags for each photo
    const photoTags = {};

    // For each attribute, compute the top N photos
    attributesToProcess.forEach(({ name, order, limit }) => {
      // Sort photos based on the attribute
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);

        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;

        if (order === "asc") {
          return aValue - bValue;
        } else {
          return bValue - aValue;
        }
      });

      // Take the top N photos
      const topPhotos = sortedPhotos.slice(0, limit);

      // Add the attribute name to the tags for each top photo
      topPhotos.forEach((photo) => {
        const photoId = photo.uuid;
        if (!photoTags[photoId]) {
          photoTags[photoId] = [];
        }
        // Extract the attribute display name
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photoId].includes(attributeDisplayName)) {
          photoTags[photoId].push(attributeDisplayName);
        }
      });
    });

    // Now, when rendering the photos, include the tags
    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    // Extract the list of score attributes for the dropdown
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Pass the photos and score attributes to the view
    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath.split(".").reduce((acc, part) => {
    if (acc && acc[part] !== undefined) {
      return acc[part];
    } else {
      return null;
    }
  }, obj);
}

// Helper function to capitalize attribute names
function capitalizeAttributeName(attributeName) {
  // Convert 'score.overall' to 'Overall'
  const nameParts = attributeName.split(".");
  const lastPart = nameParts[nameParts.length - 1];
  return lastPart
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

// Function to set tags on exported images
async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];

    if (tags.length === 0) {
      continue; // No tags to set
    }

    // **Add the count tag**
    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
```

### **./backend/data/albums.json**
```json
[
    {
        "uuid": "13F82066-89B7-44D1-B42E-C6D139EDB3EA",
        "title": "Inner Space"
    },
    {
        "uuid": "F1FBF40F-1B96-4040-80BB-B438AE7CF673",
        "title": "Carmen"
    },
    {
        "uuid": "5DF549B9-BA1C-4958-A538-46811101F518",
        "title": "Jamie"
    },
    {
        "uuid": "B307E6B7-F2A1-4077-8520-1556B09B98AF",
        "title": "LoVid"
    },
    {
        "uuid": "265925AE-5152-40DD-A35B-2F9AD7F19610",
        "title": "Lera Show"
...
```

### **./backend/data/albums/EEB5CC1C-4BF6-43EC-A0AD-107FE7298D44/photos.json**
```json
[
    {
        "albums": [
            "FujiFilm x100v: All, Full Res",
            "Studio3"
        ],
        "burst": false,
        "cloud_guid": "AeYanNpn+78RnmuKdBkVH8exg96c",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-15 18:02:02.568318+01:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-15 17:13:24+01:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 3200,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/88DE9057-862E-4ED9-83BD-D96F7D77F3CD/photos.json**
```json
[
    {
        "albums": [
            "FujiFilm x100v: All, Full Res",
            "Innsbruck Family"
        ],
        "burst": false,
        "cloud_guid": "AYaUuJtA5yA6XXDRPyhyj5y6JVIU",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-11-17 17:37:33.167930+01:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-11-17 10:25:23+01:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 160,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/F892C968-0ACF-4FF6-B387-0BEA05052E2A/photos.json**
```json
[
    {
        "albums": [
            "Dawn Riddle \ud83c\udf9e\ufe0f On a Roll"
        ],
        "burst": false,
        "cloud_guid": "ARoRNA4UZ5Cb0dqUdEVM/fOnPQ2n",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-10-06 19:00:43.723274-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2024-10-06 19:00:43.720590-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": null,
            "metering_mode": null,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/views/albums.hbs**
```
<!-- ./views/albums.hbs -->

<h1>Select an Album</h1>
<div class="album-list">
  {{#each albums}}
    <div class="album-item">
      <a href="/album/{{this.uuid}}">{{this.title}}</a>
    </div>
  {{/each}}
</div>```

### **./backend/views/index.hbs**
```
<!-- ./views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.original_name}}.jpg"
        alt="{{this.original_name}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.original_name}}.jpg

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        
        {{capitalize (replace ../sortAttribute "score." "")}}: {{getNestedProperty this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/layouts/main.hbs -->


<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/routes/index.js**
```
// ./routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
// backend/routes/api.js

import express from "express";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";

const apiRouter = express.Router();

// API route to get all albums
apiRouter.get("/albums", getAlbumsData);

// API route to get a single album by UUID
apiRouter.get("/albums/:albumUUID", getAlbumById);

// API route to get photos by album UUID
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

export default apiRouter;
```

## Frontend Files

### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  const app = new EmberApp(defaults, {
    // Add options here
    proxy: 'http://localhost:3000',
    sassOptions: {
      extension: 'scss',
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
// frontend/photo-filter-frontend/app/models/album.js

import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: true, inverse: 'album' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
// app/models/photo.js

import Model, { attr, belongsTo } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr() score;
  @attr() exifInfo;
  @belongsTo('album', { async: true, inverse: 'photos' }) album;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```

### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/styles/app.scss**
```
/* frontend/photo-filter-frontend/app/styles/app.scss */

.smart-album-label {
  font-style: italic;
  color: gray;
}
```

### **./frontend/photo-filter-frontend/app/router.js**
```
import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });
});
```

### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
<!-- frontend/photo-filter-frontend/app/templates/albums.hbs -->

<h1>Select an Album</h1>
<ul>
  {{#each this.model as |album|}}
    <li>
      <LinkTo @route="albums.album" @model={{album.id}}>
        {{album.title}}
        {{#if album.isSmart}}
          <span class="smart-album-label">(Smart Album)</span>
        {{/if}}
      </LinkTo>
    </li>
  {{/each}}
</ul>```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
{{page-title "PhotoFilterFrontend"}}

{{outlet}}```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
<!-- app/templates/albums/album.hbs -->

<h1>{{this.model.album.title}}</h1>
{{#link-to "albums"}}Back to Albums{{/link-to}}

<form {{on "submit" this.updateSort}}>
  <label for="sortAttribute">Sort by:</label>
  <select id="sortAttribute" {{on "change" this.selectSortAttribute}}>
    {{#each this.model.scoreAttributes as |attribute|}}
      <option
        value="score.{{attribute}}"
        selected={{eq this.sortAttribute (concat "score." attribute)}}
      >
        {{capitalize attribute}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select id="sortOrder" {{on "change" this.selectSortOrder}}>
    <option
      value="desc"
      selected={{eq this.sortOrder "desc"}}
    >Descending</option>
    <option value="asc" selected={{eq this.sortOrder "asc"}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each this.model.photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{this.model.albumUUID}}/{{photo.originalName}}.jpg"
        alt="{{photo.originalName}}"
      />
      <p>
        {{capitalize (replace this.model.sortAttribute "score." "")}}:
        {{getNestedProperty photo this.model.sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
// app/controllers/albums/album.js

import Controller from '@ember/controller';
import { action } from '@ember/object';

export default class AlbumsAlbumController extends Controller {
  queryParams = ['sort', 'order'];
  sort = 'score.overall';
  order = 'desc';

  @action
  updateSort(event) {
    event.preventDefault();
    // Properties are bound to query params; the model will refresh automatically
  }

  @action
  selectSortAttribute(event) {
    this.set('sort', event.target.value);
  }

  @action
  selectSortOrder(event) {
    this.set('order', event.target.value);
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// app/routes/index.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class IndexRoute extends Route {
  @service router;

  beforeModel() {
    this.router.replaceWith('albums');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
// app/routes/albums/album.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;

  queryParams = {
    sort: {
      refreshModel: true,
    },
    order: {
      refreshModel: true,
    },
  };

  async model(params) {
    const { album_id, sort = 'score.overall', order = 'desc' } = params;

    // Fetch the album without including photos
    const album = await this.store.findRecord('album', album_id);

    // Fetch photos associated with the album using store.query
    const photos = await this.store.query('photo', {
      album_id,
      sort,
      order,
    });

    // Get meta data from the photos response
    const meta = photos.meta || {};

    return {
      album,
      photos,
      albumUUID: meta.albumUUID || album_id,
      sortAttribute: meta.sortAttribute || sort,
      sortOrder: meta.sortOrder || order,
      scoreAttributes: meta.scoreAttributes || [],
    };
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

### **./frontend/photo-filter-frontend/config/optional-features.json**
```
{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {
        // Here you can enable experimental features on an ember canary build
        // e.g. EMBER_NATIVE_DECORATOR_SUPPORT: true
      },
    },

    APP: {
      // Here you can pass flags/options to your application instance
      // when it is created
      apiHost: 'http://localhost:3000', // Add this line
    },
  };

  if (environment === 'development') {
    // ENV.APP.LOG_RESOLVER = true;
    // ENV.APP.LOG_ACTIVE_GENERATION = true;
    // ENV.APP.LOG_TRANSITIONS = true;
    // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
    // ENV.APP.LOG_VIEW_LOOKUPS = true;
  }

  if (environment === 'test') {
    // Testem prefers this...
    ENV.locationType = 'none';

    // keep test console output quieter
    ENV.APP.LOG_ACTIVE_GENERATION = false;
    ENV.APP.LOG_VIEW_LOOKUPS = false;

    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // here you can enable a production-specific feature
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": [
            "--ci-provider=github"
          ]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
// frontend/photo-filter-frontend/tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from '../helpers/index.js';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('visiting /albums and viewing an album', async function (assert) {
    await visit('/albums');

    assert.strictEqual(currentURL(), '/albums');
    assert.dom('h1').hasText('Select an Album');

    const albumLinks = findAll('a');
    assert.ok(albumLinks.length > 0, 'There are album links');

    // Click the first album link
    await click(albumLinks[0]);

    // The URL should change to the album route
    assert.ok(currentURL().startsWith('/albums/'), 'Navigated to album route');

    // Check that photos are displayed
    assert.dom('.photo-grid').exists('Photo grid is displayed');
    assert
      .dom('.photo-item')
      .exists({ count: 1 }, 'At least one photo is displayed');

    // Check that images have loaded
    assert.dom('.photo-item img').exists('Photo image is displayed');
  });
});
```

### **./frontend/photo-filter-frontend/tests/helpers/index.js**
```
import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file exists to provide wrappers around ember-qunit's
// test setup functions. This way, you can easily extend the setup that is
// needed per test type.

function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // Additional setup for application tests can be done here.
  //
  // For example, if you need an authenticated session for each
  // application test, you could do:
  //
  // hooks.beforeEach(async function () {
  //   await authenticateSession(); // ember-simple-auth
  // });
  //
  // This is also a good place to call test setup functions coming
  // from other addons:
  //
  // setupIntl(hooks, 'en-us'); // ember-intl
  // setupMirage(hooks); // ember-cli-mirage
}

function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);

  // Additional setup for rendering tests can be done here.
}

function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);

  // Additional setup for unit tests can be done here.
}

export { setupApplicationTest, setupRenderingTest, setupTest };
```

### **./frontend/photo-filter-frontend/README.md**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package-lock.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "photo-filter-frontend",
      "version": "0.0.0",
      "license": "MIT",
      "devDependencies": {
        "@babel/core": "^7.25.2",
        "@babel/eslint-parser": "^7.25.1",
        "@babel/plugin-proposal-decorators": "^7.24.7",
        "@ember/optional-features": "^2.1.0",
        "@ember/string": "^4.0.0",
        "@ember/test-helpers": "^3.3.1",
        "@glimmer/component": "^1.1.2",
        "@glimmer/tracking": "^1.1.2",
        "broccoli-asset-rev": "^3.0.0",
...
```

### **./frontend/photo-filter-frontend/package.json**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Small description for photo-filter-frontend goes here",
  "repository": "",
  "license": "MIT",
  "author": "",
  "directories": {
    "doc": "doc",
    "test": "tests"
  },
  "scripts": {
    "build": "ember build --environment=production",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "start": "ember serve",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/eslint-parser": "^7.25.1",
    "@babel/plugin-proposal-decorators": "^7.24.7",
    "@ember/optional-features": "^2.1.0",
    "@ember/string": "^4.0.0",
    "@ember/test-helpers": "^3.3.1",
    "@glimmer/component": "^1.1.2",
    "@glimmer/tracking": "^1.1.2",
    "broccoli-asset-rev": "^3.0.0",
    "concurrently": "^8.2.2",
    "ember-auto-import": "^2.8.1",
    "ember-cli": "~5.12.0",
    "ember-cli-app-version": "^7.0.0",
    "ember-cli-babel": "^8.2.0",
    "ember-cli-clean-css": "^3.0.0",
    "ember-cli-dependency-checker": "^3.3.2",
    "ember-cli-htmlbars": "^6.3.0",
    "ember-cli-inject-live-reload": "^2.1.0",
    "ember-cli-sass": "^11.0.1",
    "ember-cli-sri": "^2.1.1",
    "ember-cli-terser": "^4.0.2",
    "ember-data": "~5.3.8",
    "ember-fetch": "^8.1.2",
    "ember-load-initializers": "^2.1.2",
    "ember-modifier": "^4.2.0",
    "ember-page-title": "^8.2.3",
    "ember-qunit": "^8.1.0",
    "ember-resolver": "^12.0.1",
    "ember-source": "~5.12.0",
    "ember-template-lint": "^6.0.0",
    "ember-welcome-page": "^7.0.2",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-ember": "^12.2.1",
    "eslint-plugin-n": "^16.6.2",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-qunit": "^8.1.2",
    "loader.js": "^4.7.0",
    "prettier": "^3.3.3",
    "qunit": "^2.22.0",
    "qunit-dom": "^3.2.1",
    "sass": "^1.80.6",
    "stylelint": "^15.11.0",
    "stylelint-config-standard": "^34.0.0",
    "stylelint-prettier": "^4.1.0",
    "tracked-built-ins": "^3.3.0",
    "webpack": "^5.95.0"
  },
  "engines": {
    "node": ">= 18"
  },
  "ember": {
    "edition": "octane"
  }
}
```

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
```

### **./frontend/photo-filter-frontend/.eslintrc.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
```

