# Project Overview: Photo Filter

Generated on: Mon Jun 23 20:25:26 EDT 2025
System Architecture: x86_64
Branch: feature/use-dev-osxphotos-utc

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── ADVISORY-TEAM.md
├── ARTISTIC-NOTES.md
├── backend
│   ├── .babelrc
│   ├── .DS_Store
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── index.js
│   │   │   ├── people-controller.js
│   │   │   ├── photos-controller.js
│   │   │   └── time-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   ├── people-legacy-controller.js
│   │   └── photo-controller.js
│   ├── data
│   │   ├── .DS_Store
│   │   └── albums
│   │       ├── .DS_Store
│   │       ├── 0EB23188-CA33-4FDA-BA27-A3B290466224
│   │       │   └── photos.json
│   │       ├── 13F82066-89B7-44D1-B42E-C6D139EDB3EA
│   │       │   └── photos.json
│   │       ├── 240AEA0E-D789-44BB-9BCF-AFCCC122A4EA
│   │       │   └── photos.json
│   │       ├── A6B54487-D9FC-4F22-981D-3B521EBE2B67
│   │       │   └── photos.json
│   │       └── B8F95C71-AF41-47E2-95F5-635AD81101E4
│   │           └── photos.json
│   ├── jest.config.js
│   ├── models
│   │   └── photoModel.js
│   ├── osxphotos_crash.log
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── detect_cameras.js
│   │   ├── detect_sources.js
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── helper
│   │   │   └── deviceName.js
│   │   ├── helpers
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── test_albums.json
│   ├── tests
│   │   ├── controllers
│   │   │   └── api
│   │   │       ├── albums-controller.test.js
│   │   │       └── photos-controller.test.js
│   │   └── utils
│   │       └── precise-timestamp.test.js
│   ├── tsconfig.json
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── export-images.js
│   │   ├── get-photos-library-last-modified.js
│   │   ├── helpers.js
│   │   ├── precise-timestamp.js
│   │   └── run-python-script.js
│   └── views
│       ├── albums.hbs
│       ├── index.hbs
│       ├── layouts
│       │   └── main.hbs
│       ├── person.hbs
│       └── persons.hbs
├── camera-summary.json
├── CINEMATIC-VISION.md
├── COMPASSION.md
├── DEVELOPMENT_PLAN.md
├── docs
│   ├── FILE‑NAMING.md
│   └── microsecond-filenames.md
├── frontend
│   ├── .DS_Store
│   └── photo-filter-frontend
│       ├── .DS_Store
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── app
│       │   ├── adapters
│       │   │   ├── application.js
│       │   │   └── photo.js
│       │   ├── app.js
│       │   ├── components
│       │   │   ├── .gitkeep
│       │   │   ├── photo-grid.hbs
│       │   │   ├── photo-grid.js
│       │   │   ├── time-nav.hbs
│       │   │   └── time-nav.ts
│       │   ├── config
│       │   │   └── environment.d.ts
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   └── application.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── contains.js
│       │   │   ├── eq.js
│       │   │   ├── get-nested-property.js
│       │   │   ├── replace.js
│       │   │   └── type-of.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   ├── person.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   ├── application.js
│       │   │   └── index.js
│       │   ├── serializers
│       │   ├── services
│       │   │   ├── current-album.js
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.css
│       │   └── templates
│       │       ├── albums
│       │       │   ├── album
│       │       │   │   └── persons
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       ├── application.hbs
│       │       └── index.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package.json
│       ├── postcss.config.js
│       ├── public
│       │   └── robots.txt
│       ├── README.md
│       ├── tailwind.config.js
│       ├── testem.js
│       ├── tests
│       │   ├── acceptance
│       │   │   ├── albums-test.js
│       │   │   └── person-filtering-test.js
│       │   ├── helpers.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       ├── tsconfig.json
│       └── types
│           ├── ember-data
│           │   └── types
│           │       └── registries
│           │           └── model.d.ts
│           ├── global.d.ts
│           └── photo-filter-frontend
│               └── index.d.ts
├── generate-overview.sh
├── ISSUES.md
├── MINDFUL-DISCLAIMERS.md
├── osxphotos_crash.log
├── package-lock.json
├── package.json
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── README.md
├── RELATIONAL-PRACTICES.md
├── rfcs
│   └── 0007-incremental-library-sync.md
├── scripts
│   ├── cleanup-duplicates.sh
│   ├── create-video.sh
│   ├── delete‑jpeg‑duplicates.sh
│   ├── img-meta-dump.sh
│   └── tag_random_green.sh
├── shared-types
│   └── PhotoData.ts
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
├── TESTING_GUIDE.md
├── TIMELINE_TAXONOMY.md
├── top_photo_uuids.txt
├── tsconfig.json
└── TYPESCRIPT_GUIDE.md

73 directories, 167 files
Operating System: macOS 15.4.1
```

---

## Root-Level Files

### **./ADVISORY-TEAM.md**
```
# Advisory Team

Below is our fully updated **ADVISORY_TEAM.md**. It now includes both the original descriptions of the advisors’ key strengths and their endorsements/testimonials from each other, reflecting how each member values the other’s contributions to the project.

---

## 1. Yehuda Katz

**Key Strengths (Original)**

- Co-creator of Ember.js and core contributor in the JavaScript ecosystem.
- Deep knowledge of Ember conventions, router patterns, and performance optimizations.
- Experienced mentor who can guide architectural decisions on large-scale Ember projects.

**Why This Matters for Photo Filter**

- Ember.js is your chosen frontend framework. Yehuda’s insider understanding of Ember can help you streamline routes, components, and data flows.
- He can advise on advanced patterns for query param–based filtering, performance, and future-proofing the Ember app.

**Team Endorsements**

- **Douglas Wilson**: “Yehuda is our Ember.js guru, ensuring the frontend is well-structured and efficient. He champions best practices, so the experience remains smooth and maintainable.”
- **Rhet Turnbull**: “Yehuda transforms complex Ember routes into intuitive user flows. He also helps me understand how my Python-based exports feed seamlessly into the Ember data layer.”
- **Deborah Treisman**: “He gives us a user-friendly, well-structured Ember environment. With him, it’s easy to weave editorial features—like micro-narratives or story arcs—into the UI.”
- **Margaret Morse**: “He’s the framework wizard who ensures every function of the Ember app can be expanded for inclusive user experiences. His architecture fosters mindful disclaimers and interactions.”
- **Warren Sack**: “Yehuda fosters the Ember architecture that allows for interesting time-based sequences. He’s crucial when we experiment with query params, cinematic transitions, or timeline-based filters.”

---

## 2. Douglas Wilson

**Key Strengths (Original)**

- Longtime principal maintainer of Express.js.
- Expert in Node.js, HTTP request lifecycles, server performance, and middleware design.
- Skilled in diagnosing complex issues and optimizing for production-scale deployments.

**Why This Matters for Photo Filter**

- Your backend is built with Express.js. Douglas can help refine API endpoints, caching strategies, error handling, and security best practices.
- With the monorepo approach (Ember + Express), he’d ensure a robust Node foundation.

**Team Endorsements**

- **Yehuda Katz**: “Douglas provides an incredibly stable foundation on the backend. Watching him optimize Express.js routes is a joy—he keeps everything fast, clear, and secure.”
- **Rhet Turnbull**: “He gives me peace of mind by making the Express backend a model of reliability. If I have specialized Python scripts, I know his server logic will handle them gracefully.”
- **Deborah Treisman**: “He ensures the server remains stable so that no user experiences hitches during curation. He’s also mindful of performance, which helps when we handle big photo libraries.”
- **Margaret Morse**: “Douglas knows how to keep data flowing reliably across the Node/Express side. I count on him to integrate disclaimers or warnings gracefully at the API level.”
- **Warren Sack**: “He lays the Node/Express foundation that can handle video or real-time transformations. We can rely on his routes to scale for more cinematic or data-intensive expansions.”

---

## 3. Rhet Turnbull

**Key Strengths (Original)**

- Creator and maintainer of [osxphotos](https://github.com/RhetTbull/osxphotos).
- Specializes in reverse-engineering Apple Photos database structures.
- Active in responding to community needs around Apple Photos changes.

**Why This Matters for Photo Filter**

- Your pipeline uses Python scripts (osxphotos or a close variant) to export and process photos.
- Having Rhet’s insights ensures that your macOS Photos integration remains stable when Apple updates Photos’ schema or metadata.
- He can also recommend best practices for large-scale exports and metadata transformations.

**Team Endorsements**

- **Yehuda Katz**: “Rhet is our secret weapon for staying compatible with macOS Photos. His Python scripts and osxphotos integration let us tackle Apple’s schema changes without fear.”
- **Douglas Wilson**: “Rhet lays the groundwork for everything related to Apple Photos integration. He’s saved us endless headaches by anticipating future Photos library updates.”
- **Deborah Treisman**: “He grounds the entire system in real Apple Photos data. Without his thorough approach, we risk losing narrative threads each time Apple updates their schemas.”
- **Margaret Morse**: “He singlehandedly keeps us Apple-proof, so to speak. Because of him, any deep changes in Photos remain manageable. He bridges that Python–Node gap seamlessly.”
- **Warren Sack**: “Because of Rhet, we can harness Apple Photos data for potential short films or time-lapses. His synergy between Python exports and our final interface is key to bridging still images and motion.”

---

## 4. Deborah Treisman

**Note**  
Deborah was added as part of the extended advisory team. She brings deep editorial and emotional intelligence to the project.

**Team Endorsements**

- **Yehuda Katz**: “Deborah elegantly reminds us that each photo is a small story and that our filtering tools must handle emotional complexity. She brings empathy to every design choice.”
- **Douglas Wilson**: “She consistently checks our human-centric approach. She makes sure we handle user emotions with care and editorial sensitivity, which resonates well in the UI.”
- **Rhet Turnbull**: “Deborah reframes our project goals to consider personal memory curation. She highlights that photos aren’t just files—they’re stories, and we’re supporting the editor in each user.”
- **Margaret Morse**: “She ensures that we handle the emotional content of images carefully. She frames the editorial aspect, so we remain attentive to the resonances each photograph can hold.”
- **Warren Sack**: “Deborah highlights narrative coherence. She sees every photo and sequence as a potential story, which is vital when we merge cinematic arcs with personal memories.”

---

## 5. Margaret Morse

**Note**  
Margaret was added as part of the extended advisory team. She brings a media studies and cultural context perspective.

**Team Endorsements**

- **Yehuda Katz**: “Margaret broadens our perspective on cultural and historical contexts. It’s not just about code or UI; it’s about how real people experience these images.”
- **Douglas Wilson**: “She prompts us to consider the social and cultural impact of our filters. She ensures that our disclaimers and mindful design reflect real-world complexities.”
- **Rhet Turnbull**: “Margaret keeps the focus on broader cultural contexts. She reminds us that the application might handle sensitive, historically loaded images, pushing us to maintain respectful disclaimers.”
- **Deborah Treisman**: “Margaret protects the project’s integrity by focusing on inclusive design and disclaimers. She helps us remember that photo collections can carry deep personal or historical significance.”
- **Warren Sack**: “Margaret broadens the social context of these creative features. She helps us see how new media arcs can involve not just fun or utility but also deep cultural reflection.”

---

## 6. Warren Sack

**Note**  
Warren was added as part of the extended advisory team. He contributes expertise in film aesthetics, narrative structure, and computational media.

**Team Endorsements**

- **Yehuda Katz**: “Warren shows us how the cinematic potential in photo sequences can be brought to life, bridging that creative space between code, film aesthetics, and new media thinking.”
- **Douglas Wilson**: “He brings an eye for the cinematic and creative. He encourages us to see how code can serve narrative arcs and visual storytelling, deepening the user’s experience.”
- **Rhet Turnbull**: “He envisions new ways to create dynamic, cinematic experiences from still images. His perspective on bridging code with conceptual artistry is invaluable.”
- **Deborah Treisman**: “Warren inspires a more cinematic dimension to our editorial approach. His ideas about bridging digital media structures and film narratives keep us thinking about the ‘big picture.’”
- **Margaret Morse**: “He encourages a fluid understanding of how photos might become narratives or cinematic experiences. Warren’s lens ensures we consider not just archiving but also creative expression.”

---

## Summary

- **Yehuda Katz** → Ember.js guidance, future-proof front-end architecture, user-centric data flows.
- **Douglas Wilson** → Express.js expertise, robust server performance, stable APIs.
- **Rhet Turnbull** → Deep Photos.app knowledge, python integration, data stability amid Apple updates.
- **Deborah Treisman** → Editorial & emotional perspective, reminding us photos are stories with emotional resonance.
- **Margaret Morse** → Cultural/historical context, mindful disclaimers, inclusive design.
- **Warren Sack** → Cinematic/creative dimension, bridging film aesthetics, narrative arcs, and code.

These six individuals provide a near-ideal synergy across every facet of the Photo Filter Application—front-end, backend, editorial curation, macOS Photos integration, cultural awareness, and cinematic transformation.
```

### **./ARTISTIC-NOTES.md**
```
Node Version: v20.19.2
# ARTISTIC-NOTES.md

This document provides editorial and artistic context for the Photo Filter Application, referencing the ways photography, curation, and narrative come together in the project. It is intended to help future contributors understand the artistic motivations behind certain design decisions.

---

## Editorial and Narrative Approach

- **Intentional Sequences**  
  The application isn't merely a batch sorter of images; it helps create sequences that function almost like photo essays or mini-narratives. Each album can be ordered or filtered in ways that highlight a story arc—people present, aesthetic scores, or event chronology.

- **Contextual Metadata**  
  We emphasize user-driven annotation and curation. While the app draws on Apple Photos library data, the user’s personal “artistic sense” (e.g., references to an old 8mm camera or time-lapse sequences) shapes how they pick or weigh certain aesthetic scores.

- **User as Editor**  
  The user effectively serves as an editor, deciding which images to “export” or highlight. By showing multiple vantage points in quick succession, the short ‘micro animations’ described in our overall project vision come to life.

---

## Why This Matters for Contributors

1. **UI and UX**:  
   Understanding the user’s editorial desire to quickly form a “photo story” ensures that future UI enhancements (e.g., grouping selected shots, providing an instant storyboard preview) align with the underlying editorial flow.

2. **Documentation**:  
   Art-based language or code comments that reference “story arcs,” “montage,” or “narrative logic” might appear. These notes let contributors see why the code is structured around flexible sorting, filtering, and partial exports.

3. **Future Integrations**:
   - Potential tools for “story notes” or “annotations” on images.
   - Collaborative editing features where multiple users discuss or rank images to shape a final “photo essay.”

---

## Suggestions for Further Development

- **Story Mode**:  
  A future feature that packages a user’s curated images, along with textual annotations, into a shareable web gallery or mini digital zine.

- **Annotations UI**:  
  Possibly layering short text notes onto a “selected sequence” of images so that each “chapter” in a photo essay has a distinct thematic anchor.

- **Editorial Guidelines**:  
  Encouraging or guiding best practices for consistent imagery, color, or timing if the user wants a coherent final look.

---

_Last updated: 2025-01-12_
```

### **./CINEMATIC-VISION.md**
```
# CINEMATIC-VISION.md

The Photo Filter Application stands at the intersection of photography and cinema, enabling the user to create the “shortest of short films,” as described in the project’s original vision. This file elaborates on the cinematic aspects and how they might extend the application’s functionality.

---

## Core Cinematic Concepts

1. **Time-Based Sequencing**  
   Users can take advantage of the app’s sorting and filtering to create sequences where small differences between frames become visually compelling, reminiscent of time-lapse or stop-motion animation.

2. **Micro-Motion**  
   When images shot in quick bursts or with intentional repeated framing are lined up, subtle changes (e.g., shifting facial expression, slight camera tilt) create illusions of motion, bridging photography and cinematic flow.

3. **Montage and Discontinuity**  
   By rearranging images out of chronological order or mixing high aesthetic-score images with unexpected angles, users can produce “montage” effects that disrupt linear narrative. This allows more experimental or conceptual short film structures.

---

## Potential Future Features

- **Montage Editor**  
  A UI overlay that allows users to drag and drop frames into a timeline. This timeline could export directly to Final Cut Pro–ready clips or sequences.

- **Cinematic “Arcs”**  
  Extend the concept of filtering by aesthetic score. For instance, choose a “continuity arc” for similar angles or a “contrast arc” to jump between drastically different shots.

- **Smooth Transitions & Keyframing**  
  Collaborate with advanced post-processing (e.g., using Final Cut or third-party scripts) to identify “key frames” or intervals to create a smoother bridging effect.

---

## Workflow Integration with Video Editors

- **Export for Final Cut Pro**  
  The application can already export a folder of images with standardized filenames. Integrating optional metadata or “cue sheets” (time stamps, ordering) could make the handoff to FCPX more seamless.

- **Two-Stage Export**
  1. **Rough Cut**: The user chooses and orders frames in the Photo Filter application.
  2. **Fine Cut**: Final Cut, Premiere, or DaVinci Resolve handles advanced transitions, color grading, and motion stabilization.

---

## Acknowledgments

- Influenced by the tradition of single-frame shutter usage in film cameras.
- Inspired by analog film editing aesthetics (cast iron film editors, splicing tape).
- Encourages a deeper exploration of “the space and time between photos.”

_Last updated: 2025-01-12_
```

### **./COMPASSION.md**
```
# COMPASSION.md

## **Compassion Software Principles**

This document outlines the foundational principles and guidelines for embedding compassion into the design, development, and lifecycle of the Photo Filter Application. These guidelines build upon our previous frameworks (like the approach used in healthcare-helper) and reflect the unique emotional terrain of working with photographic memories.

---

## **Core Principles**

1. **Self-Compassion**

   - Recognize that software creation is an iterative process, often involving learning curves and emotional labor.
   - Encourage breaks, acknowledging personal limits, and normalizing discussions of stress or overwhelm.
   - Where feasible, embed supportive text within the UI or code comments (e.g., “Take a moment to rest your eyes if you feel tired.”).

2. **Radical Acceptance**

   - Embrace the reality that users may have a myriad of emotional responses to images.
   - Develop features with the understanding that unpredictability is part of real life.
   - This fosters resilience in code and documentation, preparing for edge cases and user feedback.

3. **Relational Intelligence**

   - Recognize that photos may represent interpersonal dynamics—family, friendships, or community ties.
   - Develop features (e.g., person-based filtering) with a sense of relational care and caution.
   - Provide prompts or disclaimers (see [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md)) when actions could unearth sensitive content.

4. **Trauma-Informed Design**

   - Anticipate that some images may trigger painful memories.
   - Offer UI pathways to gracefully skip or hide content, especially if repeated exposure would be detrimental.
   - Document these practices so that future contributors maintain a trauma-informed perspective.

5. **Mindful Technology**

   - Avoid gamification of addictive usage patterns. Instead, encourage intentional usage.
   - Keep features like multi-person filtering or aesthetic scoring transparent and adjustable, so users remain in control.
   - Build mindful reflection points into the development cycle (e.g., code reviews that check for potential emotional or ethical pitfalls).

6. **Collaborative Systems**
   - Expand on the notion that we co-create meaning with our community.
   - Include a healthy dialogue in issue threads and documentation updates, factoring in emotional and cultural perspectives, not just technical ones.
   - Seek feedback from diverse viewpoints, ensuring the final product respects a broad user base.

---

## **Stations of the Software Apparatus**

1. **Design**

   - Start with a sense of empathy for how images can affect well-being.
   - Sketch out user flows that are easy to exit or pause if content is overwhelming.

2. **Implementation**

   - Code modularly so emotional or specialized features can be toggled or refined based on user comfort levels.
   - Maintain robust error handling that gracefully communicates potential data or user experience issues.

3. **Interaction**

   - Provide optional “emotional check-ins,” especially when browsing large sets of personal photos.
   - Label potentially intense transitions (like face recognition or time-lapse creation) with short disclaimers or soft warnings.

4. **Iteration**
   - Embrace iterative learning. Regularly check the system for relational blind spots (see [RELATIONAL-PRACTICES.md](./RELATIONAL-PRACTICES.md)).
   - Refine disclaimers, UI language, or code structure based on feedback, updated trauma-informed knowledge, or cultural changes.

---

## **Features to Prioritize**

- **Emotional Mapping**  
  Explore ways the user can note or categorize emotional significance or triggers for specific images.

- **Self-Compassion Toolkit**  
  Provide gentle reminders or prompts to step away or breathe if usage sessions become too lengthy or intense.

- **Nonviolent Communication Templates**  
  Offer respectful language suggestions for shared album annotations or group critiques.

- **Safe Spaces & Hiding Tools**  
  Possibly enable “hide from feed” features for images that might be too raw at certain times.

- **Narrative Storytelling Features**  
  Continue bridging cinematic arcs and mindful curation, allowing personal reflection in curated “photo stories.”

---

## **Ethical Commitments**

- **Privacy First**: The code respects local storage by default; network sharing is optional and user-driven.
- **Bias Awareness**: If AI or face recognition is used, remain vigilant about potential biases and correct them swiftly.
- **Cultural Sensitivity**: Recognize that images hold different meanings across diverse contexts; design inclusive labels and disclaimers.
- **Developer Accountability**: Our process includes reflection on how code changes might affect the emotional or relational experience.

---

## **Developer Guidelines**

1. **Collaborate with Empathy**  
   Provide context or emotional caution in pull requests if new features or large data sets might stir strong feelings.

2. **Document Decisions Thoughtfully**  
   In your commit messages or merges, describe not just _what_ changed but also _why_—especially if it touches on ethical or emotional aspects.

3. **Test for Relational Impact**  
   Where feasible, ask: “Could this feature inadvertently expose, highlight, or hide sensitive content?”

4. **Iterate with Care**  
   Carefully evolve the code base. If removing or renaming a feature that users might be emotionally attached to, add disclaimers.

---

## **Future Directions**

- Incorporate direct references to mental health resources or hotlines if the platform broadens to more general use.
- Gather community stories to shape new disclaimers or mindful prompts, ensuring a continuous feedback loop.

---

## **Integration with Relational Practices**

We amplify these principles further in [`RELATIONAL-PRACTICES.md`](./RELATIONAL-PRACTICES.md). That file offers practical examples for ensuring the **spirit** of compassion is upheld daily—during code reviews, user interactions, and all forms of collaboration.

**Last Updated: 2025-01-12**
```

### **./DEVELOPMENT_PLAN.md**
```
# Development Plan

### December 14, 2024: Tailwind & DaisyUI Integration Update

**Decision & Implementation:**

- Removed `@import` of Tailwind CSS files in `app.scss` and replaced them with:
  ```scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  ```

### Update: Transition to Query-Param-Based Faceted Person Filtering

**Date:** December 12, 2024

**Decision:**

- Move from nested person-specific routes toward a unified album route that uses query parameters to filter by selected individuals.
- The UI will display a list of people in the left navigation under the currently active album. Users can toggle individuals on or off (via checkboxes or links), and the album’s displayed photos will filter to include only photos with all selected individuals.
- Remove the separate “View People in this Album” link and the “Back to Albums” link, as album navigation and person filtering are now integrated in the left nav.
- Eventually incorporate a front-end UI framework (like Bootstrap or Material Design) for a more cohesive look and feel.

**Rationale:**

- **Integrated Navigation:** Having all filtering (by album, by people) and sorting in one unified route simplifies the user experience.
- **Improved UX:** No need to navigate to a separate persons sub-route. People-based filtering is just another facet of the main album view.
- **Scalability:** Query params enable easy multi-person filtering. As the user selects multiple names, they appear in the URL’s query params, making the filtering state shareable and bookmarkable.
- **Future-Ready:** Paves the way to easily add other facets (like tags, locations, or events) as query-parameter-based filters.

**Implementation Steps:**

1. **Remove Person Sub-Routes**  
   No longer need `albums/album/persons` or `albums/album/persons/person/:person_name`.
2. **Update Album Route to Use Query Params**  
   Add a `people` query param to `albums.album`, update toggles, etc.
3. **UI Updates**  
   People filters appear in the left nav, integrated with album listing.
4. **Backend**  
   The backend remains largely the same. For multi-person queries, client-side filtering is primary; future server optimization possible.
5. **Documentation**  
   Update relevant docs: `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `README.md`.
6. **Testing and Validation**  
   Confirm query params work and that reloading with persons in the URL is stable.

**Potential Challenges:**

- Complex filtering for large libraries might need caching or indexing.
- UI complexity if many persons are toggled.

---

### Previous Updates

- **December 7, 2024**: Initial person-level sub-routes conceived.
- **November 12, 2024**: Introduced nested routes, left nav, and sorting.
- **November 1, 2024**: Added cache invalidation for data freshness.
- **October 30, 2024**: Adopted JSON:API serializer.

---

## Project Goal

Create an intuitive, facet-based photo exploration tool integrated with macOS Photos data, enabling advanced sorting, selection, exporting, and multi-person filtering.

---

## Current State

- **Frontend**: Ember.js with album-level sorting and filtering done on the frontend for performance.
- **Backend**: Express.js, JSON:API, data from `osxphotos`.
- **Data Handling**: `osxphotos` extracts metadata; `photos.json` captures results for each album.
- **Selection & Export**: In progress.
- **Documentation & Styling**: Ongoing enhancements.

---

## Next Steps

1. **Implement Multi-Person Filtering with Query Params**  
   Completed the initial approach; further refinements ongoing.
2. **Improve Export Feature**  
   Integrate actual export logic on the backend, plus UI feedback during export.
3. **UX and Performance**  
   Potentially add an indexed DB or partial caching for large datasets; also set up a refresh route.
4. **Testing & Quality Assurance**  
   Strengthen acceptance tests (e.g. `person-filtering-test.js`).
5. **Documentation & Cleanup**  
   Keep all docs updated; refactor code for maintainability.

---

## Cinematic Montages and Artistic Workflow

With the emerging cinematic use cases (see `CINEMATIC-VISION.md` for deeper discussion):

- **Facilitating “Short Films”**  
  Users often drag out ~150 images, place them into an external video editor (Final Cut Pro or similar), and generate micro-animations or time-lapse sequences. Our sorting by aesthetic score or by recognized faces can help them find key frames or ensure coverage of all event participants.

- **Montage Tools**  
  While advanced timeline editing is best left to specialized video software, the Photo Filter app can provide “proto-montage” capabilities:

  - Exporting images in a “chronological yet selective” order.
  - Tagging or marking intervals for quick selection in FCPX.
  - Potential future feature: “mini-sequence preview,” letting the user quickly flip through frames in the app (like a mechanical film editor’s spool).

- **Long-Term Vision**
  - Possibly integrate a “Montage Editor” overlay in the Ember frontend for a quick drag-and-drop sequence.
  - Provide “story arc” filters (e.g., stable lighting vs. highly varied frames).
  - Output an “XML timeline” or JSON for direct import into editing software.

This alignment of photography with micro-cinema underscores our commitment to bridging the still and moving image realms. By continuing to refine filtering and selection tools, we enable both everyday photographers and fine-art practitioners to unearth new narrative possibilities.

---

## **Time Taxonomy Feature (Planned)**

**Date:** January 12, 2025

**Overview:**
We will implement a **time-based hierarchy** in the left nav, similar to how we list people or albums. The system will only show Year → Month → Week → Day nodes if photos exist for those nodes. Clicking them filters the photo grid accordingly.

**Key Steps:**

1. **Metadata Aggregation**

   - Parse each photo’s date/time.
   - Populate a “time index” table or JSON structure, grouping by year, month, etc.

2. **Backend Endpoint**

   - A new route, e.g. `GET /api/time-index`, returns a hierarchical JSON of available years/months/weeks/days.

3. **Frontend UI**

   - In Ember, create a “Time” section in the left nav. Expand/collapse each year, month, etc.
   - Multi-select logic, updating query params with the chosen date slices.

4. **Querying**

   - Combine date filters with existing person/album filters. For instance, `dates=2024-12-07,2024-12-08` plus `persons=Margaret,Douglas`.

5. **Testing & Documentation**
   - Acceptance tests for multi-date selection.
   - Document in `TIMELINE_TAXONOMY.md`.

**Potential Roadblocks:**

- Large date range or scattered photos might complicate the UI. We’ll consider partial or lazy loading.
- Weeks are tricky—defining them consistently and avoiding user confusion.

**Schedule Estimate:**

- Implementation to begin after finishing the multi-person filtering enhancements (by mid-January 2025).
- Initial release by early February 2025, with refinements continuing.

---
```

### **./ISSUES.md**
```
Branch: feature/use-dev-osxphotos-utc

This project is a monorepo containing both the Ember.js frontend and the Express.js backend applications.
---

## Project Structure

```
# Issues and Resolutions

This file logs open issues and their statuses. Update it as new issues arise and existing ones progress.

---

## Issue 16: PostCSS "File not found: /app/styles/app.css" Error

**Opened By:** Jamie, Dec 14, 2024  
**Status:** In Progress

### Description

Encountered a build error because PostCSS didn’t find `app.css` after SCSS changes.

### Actions

- Installed `ember-cli-sass` to compile `app.scss` into `app.css`.
- Updated `app.scss` to use `@tailwind` directives instead of `@import`.
- (Alternative) Renamed `app.scss` to `app.css` and removed `ember-cli-sass`.

### Next Steps

- Verify build succeeds (`ember serve`).
- If successful, mark as Resolved after testing in production-like scenarios.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name], Nov 12, 2024  
**Status:** **Resolved**

### Description

`albums/album` route’s template not rendering correctly.

### Resolution

- Added `{{outlet}}` to `albums.hbs`.
- Verified proper rendering.

---

## Issue 14: 404 Error When Fetching Album Data

**Opened By:** [Your Name], Nov 10, 2024  
**Status:** **Resolved**

### Description

`GET /api/albums/:albumUUID` returned 404.

### Resolution

- Implemented `GET /api/albums/:albumUUID`.
- Confirmed endpoint now works as expected.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need multi-photo selection persistence across sorting and filtering changes.

### Actions

- Created `selection.js` service to manage selected photos.
- Selections persist when changing sort order or navigating within the album.

### Next Steps

- Integrate with multi-person filtering now that filtering is query-param-based.
- Ensure that selected photos remain selected as users toggle people filters.
- Write more comprehensive tests for selection persistence.

---

## Issue 9: Adding Actions for Selected Photos (Export Functionality)

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need to export selected photos from the backend once chosen on the frontend.

### Actions

- Created `/api/photos/export` endpoint.
- Frontend can send selected photo IDs to initiate export.
- Basic user alerts implemented to inform the user of export status.

### Next Steps

- Implement actual export logic on the backend.
- Add progress indicators (e.g., a progress bar) in the UI.
- Validate that exported filenames handle duplicates properly.

---

## Issue 16: Filename Collisions in Exports

**Opened By:** [Your Name], Dec 11, 2024  
**Status:** **Open** (Reopened Dec 12, 2024)

### Description

When exporting images, sometimes duplicate filenames occur.

### Current Approach

- Prepend date/time to filenames.
- Append counters for duplicates.

### Next Steps

- Confirm that this approach truly prevents collisions.
- Test extensively in a real environment before marking resolved.

---

## Newly Considered Issue: Replacing Person Sub-Routes with Query Params

**Opened By:** [Your Name], Dec 12, 2024  
**Status:** **In Planning**

### Description

We initially implemented `albums/album/persons` sub-routes. We now want to remove them in favor of query params on the main album route. This will unify navigation and filtering, removing the need for “Back” or “View People” links.

### Actions

- Update `DEVELOPMENT_PLAN.md` to reflect query-param-based person filtering.
- Adjust frontend UI to list people under the album in the left nav.
- Remove old person sub-route code once the new system is tested.

### Next Steps

- Implement toggles for people in the sidebar.
- Update the album route model hook to filter photos by selected people.
- Fully test the new approach.

---

## Issue 17: Persons Not Appearing in Album UI

**Opened By:** [Your Name], Dec 13, 2024  
**Status:** **Open**

### Description

Even though the backend returns `persons` as included data when fetching an album, they do not appear in the UI. In Ember Inspector, we see `album.persons` is present, but on the active controller, `persons` remains empty because the PromiseManyArray was not awaited before use.

### Actions

- In `app/routes/albums/album.js`, awaited `album.persons` before mapping/filtering.
- Once verified and tested, we can mark this issue resolved.

### Next Steps

- Verify persons now appear as expected.

---

## New Issue: `photoPersonNames` Always Empty in Controller

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** **Open**

### Description

We’re trying to filter photos by selected persons. However, `photoPersonNames` in `albums/album.js` controller logging always returns an empty array. The reason seems to be that `photo.persons` is not properly populated with Person model instances. Even though we have `@hasMany('person')` defined, the `persons` data might be coming in as raw strings rather than proper JSON:API relationships.

### Proposed Frontend-Only Fix

We can create a custom serializer for `photo` on the frontend that transforms the raw `persons` attribute into proper JSON:API relationships. This ensures Ember Data recognizes the `persons` as PersonModel instances.

### Next Steps

- Implement a `photo.js` serializer in `app/serializers/photo.js` that modifies the `normalize` response, converting `persons` strings into relationship objects and (optionally) included person records.
- Test if `photo.persons` now returns actual Person models.
- Confirm that `photoPersonNames` is no longer empty.

---

## Performance Impact from Re-Fetching Large Albums on Sort/Filter Changes

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** Open

### Description

Changing sorting/filtering previously caused large album re-fetches, leading to delays. We implemented front-end-only sorting/filtering to avoid unnecessary re-fetches.

### Actions

- Moved sorting and filtering logic to the frontend.
- Initial load might be slower, but subsequent operations are fast.

### Next Steps

- Consider indexed DB, cache invalidation strategies, pagination, or lazy loading for scalability.
- Monitor performance and refine as needed.

---

## Issue 19: Chrome "Aw, Snap!" Crash on Large Albums

**Opened By:** [Your Name], Dec 21, 2024  
**Status:** **Resolved**

### Description

When an album contains a very large number of photos (hundreds or thousands), Chrome sometimes crashes with an “Aw, Snap!” error code 5. This typically indicates the browser is running out of memory or hitting some resource limit.

### Resolution

- **Implemented a default limit (e.g., 200 photos) when requesting an album** to prevent the UI from trying to render or sort thousands of photos at once.
- Added a `limit` query param so advanced users can pull more photos if needed (with caution).

### Next Steps

- For truly large datasets, implement full pagination instead of a single “limit” slice.
- Monitor memory usage when increasing `limit`.

---

## Issue 20: Time Taxonomy in Left Nav

**Opened By:** [Your Name], Jan 12, 2025  
**Status:** Open

### Description

We want to add a new time-based taxonomy (Years → Months → Weeks → Days) in the left nav. Only show nodes with existing photos. Let the user multi-select date ranges to form a combined album view on the right side, possibly also filtering by people.

### Proposed Actions

1. **Add a new `time-index` endpoint** returning a hierarchical JSON of years, months, weeks, days.
2. **Implement a new Ember route and left nav section** for the time taxonomy.
3. **Support multi-select** (like checkboxes).
4. **Combine with existing person filters**.

### Next Steps

- Add documentation (`TIMELINE_TAXONOMY.md`) describing the data structure.
- Add a proof of concept for generating a time index from our photo metadata.
- Build or update acceptance tests to ensure multi-time-slice selection works.

---
```

### **./MINDFUL-DISCLAIMERS.md**
```
.
├── .DS_Store
├── .gitignore
├── .nvmrc
├── ADVISORY-TEAM.md
├── ARTISTIC-NOTES.md
├── backend
│   ├── .babelrc
│   ├── .DS_Store
│   ├── .nvmrc
│   ├── controllers
│   │   ├── api
│   │   │   ├── albums-controller.js
│   │   │   ├── index.js
│   │   │   ├── people-controller.js
│   │   │   ├── photos-controller.js
│   │   │   └── time-controller.js
│   │   ├── api-controller.js
│   │   ├── get-albums.js
│   │   ├── get-photos-by-album.js
│   │   ├── people-legacy-controller.js
│   │   └── photo-controller.js
│   ├── data
│   │   ├── .DS_Store
│   │   └── albums
│   │       ├── .DS_Store
│   │       ├── 0EB23188-CA33-4FDA-BA27-A3B290466224
│   │       │   └── photos.json
│   │       ├── 13F82066-89B7-44D1-B42E-C6D139EDB3EA
│   │       │   └── photos.json
│   │       ├── 240AEA0E-D789-44BB-9BCF-AFCCC122A4EA
│   │       │   └── photos.json
│   │       ├── A6B54487-D9FC-4F22-981D-3B521EBE2B67
│   │       │   └── photos.json
│   │       └── B8F95C71-AF41-47E2-95F5-635AD81101E4
│   │           └── photos.json
│   ├── jest.config.js
│   ├── models
│   │   └── photoModel.js
│   ├── osxphotos_crash.log
│   ├── package.json
│   ├── public
│   │   └── stylesheets
│   │       └── scss
│   │           └── style.scss
│   ├── routes
│   │   ├── api.js
│   │   └── index.js
│   ├── scripts
│   │   ├── detect_cameras.js
│   │   ├── detect_sources.js
│   │   ├── export_albums.py
│   │   ├── export_photos_in_album.py
│   │   ├── helper
│   │   │   └── deviceName.js
│   │   ├── helpers
│   │   ├── setup.js
│   │   └── template_functions.py
│   ├── server.js
│   ├── test_albums.json
│   ├── tests
│   │   ├── controllers
│   │   │   └── api
│   │   │       ├── albums-controller.test.js
│   │   │       └── photos-controller.test.js
│   │   └── utils
│   │       └── precise-timestamp.test.js
│   ├── tsconfig.json
│   ├── utils
│   │   ├── exec-command.js
│   │   ├── export-images.js
│   │   ├── get-photos-library-last-modified.js
│   │   ├── helpers.js
│   │   ├── precise-timestamp.js
│   │   └── run-python-script.js
│   └── views
│       ├── albums.hbs
│       ├── index.hbs
│       ├── layouts
│       │   └── main.hbs
│       ├── person.hbs
│       └── persons.hbs
├── camera-summary.json
├── CINEMATIC-VISION.md
├── COMPASSION.md
├── DEVELOPMENT_PLAN.md
├── docs
│   ├── FILE‑NAMING.md
│   └── microsecond-filenames.md
├── frontend
│   ├── .DS_Store
│   └── photo-filter-frontend
│       ├── .DS_Store
│       ├── .editorconfig
│       ├── .ember-cli
│       ├── .eslintignore
│       ├── .eslintrc.js
│       ├── .github
│       │   └── workflows
│       │       └── ci.yml
│       ├── .gitignore
│       ├── .prettierignore
│       ├── .prettierrc.js
│       ├── .stylelintignore
│       ├── .stylelintrc.js
│       ├── .template-lintrc.js
│       ├── .watchmanconfig
│       ├── app
│       │   ├── adapters
│       │   │   ├── application.js
│       │   │   └── photo.js
│       │   ├── app.js
│       │   ├── components
│       │   │   ├── .gitkeep
│       │   │   ├── photo-grid.hbs
│       │   │   ├── photo-grid.js
│       │   │   ├── time-nav.hbs
│       │   │   └── time-nav.ts
│       │   ├── config
│       │   │   └── environment.d.ts
│       │   ├── controllers
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   └── application.js
│       │   ├── helpers
│       │   │   ├── .gitkeep
│       │   │   ├── capitalize.js
│       │   │   ├── contains.js
│       │   │   ├── eq.js
│       │   │   ├── get-nested-property.js
│       │   │   ├── replace.js
│       │   │   └── type-of.js
│       │   ├── index.html
│       │   ├── models
│       │   │   ├── .gitkeep
│       │   │   ├── album.js
│       │   │   ├── person.js
│       │   │   └── photo.js
│       │   ├── router.js
│       │   ├── routes
│       │   │   ├── .gitkeep
│       │   │   ├── albums
│       │   │   │   ├── album
│       │   │   │   │   └── persons
│       │   │   │   └── album.js
│       │   │   ├── albums.js
│       │   │   ├── application.js
│       │   │   └── index.js
│       │   ├── serializers
│       │   ├── services
│       │   │   ├── current-album.js
│       │   │   └── store.js
│       │   ├── styles
│       │   │   └── app.css
│       │   └── templates
│       │       ├── albums
│       │       │   ├── album
│       │       │   │   └── persons
│       │       │   └── album.hbs
│       │       ├── albums.hbs
│       │       ├── application.hbs
│       │       └── index.hbs
│       ├── config
│       │   ├── ember-cli-update.json
│       │   ├── environment.js
│       │   ├── optional-features.json
│       │   └── targets.js
│       ├── ember-cli-build.js
│       ├── package.json
│       ├── postcss.config.js
│       ├── public
│       │   └── robots.txt
│       ├── README.md
│       ├── tailwind.config.js
│       ├── testem.js
│       ├── tests
│       │   ├── acceptance
│       │   │   ├── albums-test.js
│       │   │   └── person-filtering-test.js
│       │   ├── helpers.js
│       │   ├── index.html
│       │   ├── integration
│       │   │   └── .gitkeep
│       │   ├── test-helper.js
│       │   └── unit
│       │       ├── .gitkeep
│       │       ├── models
│       │       │   ├── album-test.js
│       │       │   └── photo-test.js
│       │       ├── routes
│       │       │   ├── album-test.js
│       │       │   └── albums-test.js
│       │       └── services
│       │           └── store-test.js
│       ├── tsconfig.json
│       └── types
│           ├── ember-data
│           │   └── types
│           │       └── registries
│           │           └── model.d.ts
│           ├── global.d.ts
│           └── photo-filter-frontend
│               └── index.d.ts
├── generate-overview.sh
├── ISSUES.md
├── MINDFUL-DISCLAIMERS.md
├── osxphotos_crash.log
├── package-lock.json
├── package.json
├── project-guidelines.md
├── project-overview.txt
├── public
│   └── stylesheets
│       └── css
│           └── style.css
├── README.md
├── RELATIONAL-PRACTICES.md
├── rfcs
│   └── 0007-incremental-library-sync.md
├── scripts
│   ├── cleanup-duplicates.sh
│   ├── create-video.sh
│   ├── delete‑jpeg‑duplicates.sh
│   ├── img-meta-dump.sh
│   └── tag_random_green.sh
├── shared-types
│   └── PhotoData.ts
├── test-images
│   ├── .osxphotos_export.db
│   ├── IMG_0743.HEIC
│   └── uuids.txt
├── test-osxphotos.js
├── TESTING_GUIDE.md
├── TIMELINE_TAXONOMY.md
├── top_photo_uuids.txt
├── tsconfig.json
└── TYPESCRIPT_GUIDE.md

73 directories, 167 files
```

---

## Root-Level Files

### **./ADVISORY-TEAM.md**
```
# MINDFUL-DISCLAIMERS.md

## Purpose

This file centralizes all disclaimers and precautionary statements so that contributors, users, and stakeholders fully understand the relational and emotional considerations of working with photo-based data in the Photo Filter Application.

---

## 1. Emotional Sensitivity Disclaimer

**Context**  
Photography often contains memories with significant emotional resonance—family events, personal milestones, or reminders of loss. Filtering through large volumes of images may trigger unexpected memories or emotional responses.

**Disclaimer**  
While the Photo Filter Application aims to facilitate creative exploration, we acknowledge that certain imagery may evoke stress, sadness, or trauma. We encourage users and team members to practice self-care, take breaks, and seek supportive resources if distress arises.

---

## 2. Trauma-Informed User Interactions

**Context**  
Trauma-informed design helps us avoid re-traumatizing users inadvertently. The app occasionally surfaces old photos or personal moments that may intersect with difficult past experiences.

**Disclaimer**  
This software does not replace professional mental health support. If reviewing or sorting photos triggers severe emotional distress, please reach out to a qualified professional or mental health resource. The development team has integrated mindful language and gentle UI prompts, but we cannot predict or prevent all triggers.

---

## 3. Privacy and Data Sensitivity

**Context**  
The Photo Filter Application processes metadata from a user’s personal photo library. This metadata can include date/time, location, and face recognition data, all of which is sensitive.

**Disclaimer**  
Users are responsible for ensuring they comply with relevant privacy regulations and best practices. The code, as provided, does not collect or store your images on third-party servers beyond your local environment—unless explicitly connected to an external service by you. If you deploy the application in a shared or cloud environment, you must configure secure access controls.

---

## 4. Ethical Use of Visual AI

**Context**  
The platform can support or integrate with AI-based analytics (face detection, aesthetic scoring, etc.).

**Disclaimer**  
We caution contributors and end-users to assess whether these AI features align with their ethical standards. We assume no liability for misuse of AI-driven capabilities. Always audit your data processing flows for potential bias or discriminatory outcomes.

---

## 5. Developers’ Emotional Wellbeing

**Context**  
Much like users, developers can feel overwhelmed if managing intense or large-scale photo sets or dealing with emotional user stories. This is especially true when debugging or manually verifying large emotional archives.

**Disclaimer**  
We encourage all contributors to adopt healthy boundaries—take breaks, practice mindfulness, and communicate openly with the team if tasks feel personally distressing. We have formal guidelines in [COMPASSION.md](./COMPASSION.md) and [RELATIONAL-PRACTICES.md](./RELATIONAL-PRACTICES.md).

---

## 6. Iteration and Evolution

We intend these disclaimers to be living elements of the project. If new disclaimers become relevant, please add them here. We welcome feedback, suggestions, or expansions as the app evolves.

**Last Updated:** 2025-01-12
```

### **./project-guidelines.md**
```
# Advisory Team

Below is our fully updated **ADVISORY_TEAM.md**. It now includes both the original descriptions of the advisors’ key strengths and their endorsements/testimonials from each other, reflecting how each member values the other’s contributions to the project.

---

## 1. Yehuda Katz

**Key Strengths (Original)**

- Co-creator of Ember.js and core contributor in the JavaScript ecosystem.
- Deep knowledge of Ember conventions, router patterns, and performance optimizations.
- Experienced mentor who can guide architectural decisions on large-scale Ember projects.

**Why This Matters for Photo Filter**

- Ember.js is your chosen frontend framework. Yehuda’s insider understanding of Ember can help you streamline routes, components, and data flows.
- He can advise on advanced patterns for query param–based filtering, performance, and future-proofing the Ember app.

**Team Endorsements**

- **Douglas Wilson**: “Yehuda is our Ember.js guru, ensuring the frontend is well-structured and efficient. He champions best practices, so the experience remains smooth and maintainable.”
- **Rhet Turnbull**: “Yehuda transforms complex Ember routes into intuitive user flows. He also helps me understand how my Python-based exports feed seamlessly into the Ember data layer.”
- **Deborah Treisman**: “He gives us a user-friendly, well-structured Ember environment. With him, it’s easy to weave editorial features—like micro-narratives or story arcs—into the UI.”
- **Margaret Morse**: “He’s the framework wizard who ensures every function of the Ember app can be expanded for inclusive user experiences. His architecture fosters mindful disclaimers and interactions.”
- **Warren Sack**: “Yehuda fosters the Ember architecture that allows for interesting time-based sequences. He’s crucial when we experiment with query params, cinematic transitions, or timeline-based filters.”

---

## 2. Douglas Wilson

**Key Strengths (Original)**

- Longtime principal maintainer of Express.js.
- Expert in Node.js, HTTP request lifecycles, server performance, and middleware design.
- Skilled in diagnosing complex issues and optimizing for production-scale deployments.

**Why This Matters for Photo Filter**

- Your backend is built with Express.js. Douglas can help refine API endpoints, caching strategies, error handling, and security best practices.
- With the monorepo approach (Ember + Express), he’d ensure a robust Node foundation.

**Team Endorsements**

- **Yehuda Katz**: “Douglas provides an incredibly stable foundation on the backend. Watching him optimize Express.js routes is a joy—he keeps everything fast, clear, and secure.”
- **Rhet Turnbull**: “He gives me peace of mind by making the Express backend a model of reliability. If I have specialized Python scripts, I know his server logic will handle them gracefully.”
- **Deborah Treisman**: “He ensures the server remains stable so that no user experiences hitches during curation. He’s also mindful of performance, which helps when we handle big photo libraries.”
- **Margaret Morse**: “Douglas knows how to keep data flowing reliably across the Node/Express side. I count on him to integrate disclaimers or warnings gracefully at the API level.”
- **Warren Sack**: “He lays the Node/Express foundation that can handle video or real-time transformations. We can rely on his routes to scale for more cinematic or data-intensive expansions.”

---

## 3. Rhet Turnbull

**Key Strengths (Original)**

- Creator and maintainer of [osxphotos](https://github.com/RhetTbull/osxphotos).
- Specializes in reverse-engineering Apple Photos database structures.
- Active in responding to community needs around Apple Photos changes.

**Why This Matters for Photo Filter**

- Your pipeline uses Python scripts (osxphotos or a close variant) to export and process photos.
- Having Rhet’s insights ensures that your macOS Photos integration remains stable when Apple updates Photos’ schema or metadata.
- He can also recommend best practices for large-scale exports and metadata transformations.

**Team Endorsements**

- **Yehuda Katz**: “Rhet is our secret weapon for staying compatible with macOS Photos. His Python scripts and osxphotos integration let us tackle Apple’s schema changes without fear.”
- **Douglas Wilson**: “Rhet lays the groundwork for everything related to Apple Photos integration. He’s saved us endless headaches by anticipating future Photos library updates.”
- **Deborah Treisman**: “He grounds the entire system in real Apple Photos data. Without his thorough approach, we risk losing narrative threads each time Apple updates their schemas.”
- **Margaret Morse**: “He singlehandedly keeps us Apple-proof, so to speak. Because of him, any deep changes in Photos remain manageable. He bridges that Python–Node gap seamlessly.”
- **Warren Sack**: “Because of Rhet, we can harness Apple Photos data for potential short films or time-lapses. His synergy between Python exports and our final interface is key to bridging still images and motion.”

---

## 4. Deborah Treisman

**Note**  
Deborah was added as part of the extended advisory team. She brings deep editorial and emotional intelligence to the project.

**Team Endorsements**

- **Yehuda Katz**: “Deborah elegantly reminds us that each photo is a small story and that our filtering tools must handle emotional complexity. She brings empathy to every design choice.”
- **Douglas Wilson**: “She consistently checks our human-centric approach. She makes sure we handle user emotions with care and editorial sensitivity, which resonates well in the UI.”
- **Rhet Turnbull**: “Deborah reframes our project goals to consider personal memory curation. She highlights that photos aren’t just files—they’re stories, and we’re supporting the editor in each user.”
- **Margaret Morse**: “She ensures that we handle the emotional content of images carefully. She frames the editorial aspect, so we remain attentive to the resonances each photograph can hold.”
- **Warren Sack**: “Deborah highlights narrative coherence. She sees every photo and sequence as a potential story, which is vital when we merge cinematic arcs with personal memories.”

---

## 5. Margaret Morse

**Note**  
Margaret was added as part of the extended advisory team. She brings a media studies and cultural context perspective.

**Team Endorsements**

- **Yehuda Katz**: “Margaret broadens our perspective on cultural and historical contexts. It’s not just about code or UI; it’s about how real people experience these images.”
- **Douglas Wilson**: “She prompts us to consider the social and cultural impact of our filters. She ensures that our disclaimers and mindful design reflect real-world complexities.”
- **Rhet Turnbull**: “Margaret keeps the focus on broader cultural contexts. She reminds us that the application might handle sensitive, historically loaded images, pushing us to maintain respectful disclaimers.”
- **Deborah Treisman**: “Margaret protects the project’s integrity by focusing on inclusive design and disclaimers. She helps us remember that photo collections can carry deep personal or historical significance.”
- **Warren Sack**: “Margaret broadens the social context of these creative features. She helps us see how new media arcs can involve not just fun or utility but also deep cultural reflection.”

---

## 6. Warren Sack

**Note**  
Warren was added as part of the extended advisory team. He contributes expertise in film aesthetics, narrative structure, and computational media.

**Team Endorsements**

- **Yehuda Katz**: “Warren shows us how the cinematic potential in photo sequences can be brought to life, bridging that creative space between code, film aesthetics, and new media thinking.”
- **Douglas Wilson**: “He brings an eye for the cinematic and creative. He encourages us to see how code can serve narrative arcs and visual storytelling, deepening the user’s experience.”
- **Rhet Turnbull**: “He envisions new ways to create dynamic, cinematic experiences from still images. His perspective on bridging code with conceptual artistry is invaluable.”
- **Deborah Treisman**: “Warren inspires a more cinematic dimension to our editorial approach. His ideas about bridging digital media structures and film narratives keep us thinking about the ‘big picture.’”
- **Margaret Morse**: “He encourages a fluid understanding of how photos might become narratives or cinematic experiences. Warren’s lens ensures we consider not just archiving but also creative expression.”

---

## Summary

- **Yehuda Katz** → Ember.js guidance, future-proof front-end architecture, user-centric data flows.
- **Douglas Wilson** → Express.js expertise, robust server performance, stable APIs.
- **Rhet Turnbull** → Deep Photos.app knowledge, python integration, data stability amid Apple updates.
- **Deborah Treisman** → Editorial & emotional perspective, reminding us photos are stories with emotional resonance.
- **Margaret Morse** → Cultural/historical context, mindful disclaimers, inclusive design.
- **Warren Sack** → Cinematic/creative dimension, bridging film aesthetics, narrative arcs, and code.

These six individuals provide a near-ideal synergy across every facet of the Photo Filter Application—front-end, backend, editorial curation, macOS Photos integration, cultural awareness, and cinematic transformation.
```

### **./ARTISTIC-NOTES.md**
```
Project Guidelines

Table of Contents

- Project Philosophy
- Keeping Up with Dependencies
- Data Formats
- Data Synchronization and Caching
- Ensuring Complete Project Overviews
- Coding Standards
- Naming Conventions
- Directory Structure
- Documentation Practices
- Privacy and Data Handling
- Project State and Continuity
- Issue Tracking and Debugging
- Collaboration Guidelines
- Environment and Dependency Management
- Error Handling and Logging
- Security Best Practices
- Testing
- Deployment and Operations
- Performance Optimization

---

## Project Philosophy

- User-Centric Design, Interactivity, Clarity, Modularity, Consistency.
- Ember.js Conventions: Follow Ember.js patterns.
- Privacy, Security, Performance, Scalability.
- Embrace Iterative Understanding: Treat solutions as provisional and open to revision.

## Keeping Up with Dependencies

- Stay informed of the latest versions and updates.
- Test thoroughly after upgrading dependencies.
- Document changes and version notes.

## Data Formats

- Use JSON:API for backend/frontend integration.
- Utilize `jsonapi-serializer` on the backend.

## Data Synchronization and Caching

- Implement cache invalidation using timestamps.
- Balance data freshness with performance.

## Ensuring Complete Project Overviews

- Include all relevant files in generated overviews.
- Update `generate-overview.sh` as the project evolves.
- Regularly review project-overview.txt for accuracy.

## Coding Standards

- Consistent indentation (2 spaces).
- camelCase for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- Avoid globals; use modules.
- Follow Ember.js coding conventions where applicable.

## Naming Conventions

- Dasherized filenames (e.g., `photo-controller.js`).
- Descriptive and concise filenames.

## Directory Structure

- `backend/`: Express.js server and APIs
- `frontend/`: Ember.js app
- `data/`, `exports/`, `scripts/`, `utils/`, `tests/`
- Keep structure organized and consistent.

## Documentation Practices

- Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`.
- Use inline code comments and JSDoc.
- Maintain a changelog and consider `ARCHITECTURE.md` for big-picture decisions.
- Include “Questions to Consider” to highlight uncertainties.

## Privacy and Data Handling

- Do not store personal data in git.
- Be transparent about data processing.

## Project State and Continuity

- Self-contained documentation.
- Reflect current state, pending tasks, and future plans within the project files.

## Issue Tracking and Debugging

- Log issues in `ISSUES.md`.
- Document steps taken and current status.
- **Do Not Mark Issues as Resolved Until Verified**:  
  **No issue should be marked as "Resolved" until the fix is actually applied by the real person managing the system, and tested to confirm it works in reality.**
- Use "Uncertain" tags if needed to highlight unresolved aspects.
- Treat resolutions as provisional truths.

## Collaboration Guidelines

- Communicate clearly and concisely.
- Provide full file replacements for verifiable changes.
- Keep project composed of smaller files for easy copy-paste integration.
- Include clear commit messages.

## Environment and Dependency Management

- Use `.nvmrc` for Node.js versions.
- Keep dependencies updated and tested.
- Store config in environment variables.
- Adhere to JSON:API specs to ensure frontend-backend compatibility.

## Error Handling and Logging

- Implement robust error handling in async code.
- Provide meaningful error messages.
- Use logging for debugging and monitoring.

## Security Best Practices

- No sensitive info in version control.
- Validate/sanitize user inputs.
- Use environment variables for credentials.

## Testing

- Comprehensive test coverage: unit, integration, acceptance.
- Use Jest (backend) and Ember CLI testing tools (frontend).
- Mock external dependencies.
- Write tests alongside code changes.
- Keep tests reliable and maintainable.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configs.
- Monitor performance and errors in production.

## Performance Optimization

- Optimize large dataset handling.
- Use caching and lazy loading.
- Profile resource usage.
```

### **./README.md**
```
# ARTISTIC-NOTES.md

This document provides editorial and artistic context for the Photo Filter Application, referencing the ways photography, curation, and narrative come together in the project. It is intended to help future contributors understand the artistic motivations behind certain design decisions.

---

## Editorial and Narrative Approach

- **Intentional Sequences**  
  The application isn't merely a batch sorter of images; it helps create sequences that function almost like photo essays or mini-narratives. Each album can be ordered or filtered in ways that highlight a story arc—people present, aesthetic scores, or event chronology.

- **Contextual Metadata**  
  We emphasize user-driven annotation and curation. While the app draws on Apple Photos library data, the user’s personal “artistic sense” (e.g., references to an old 8mm camera or time-lapse sequences) shapes how they pick or weigh certain aesthetic scores.

- **User as Editor**  
  The user effectively serves as an editor, deciding which images to “export” or highlight. By showing multiple vantage points in quick succession, the short ‘micro animations’ described in our overall project vision come to life.

---

## Why This Matters for Contributors

1. **UI and UX**:  
   Understanding the user’s editorial desire to quickly form a “photo story” ensures that future UI enhancements (e.g., grouping selected shots, providing an instant storyboard preview) align with the underlying editorial flow.

2. **Documentation**:  
   Art-based language or code comments that reference “story arcs,” “montage,” or “narrative logic” might appear. These notes let contributors see why the code is structured around flexible sorting, filtering, and partial exports.

3. **Future Integrations**:
   - Potential tools for “story notes” or “annotations” on images.
   - Collaborative editing features where multiple users discuss or rank images to shape a final “photo essay.”

---

## Suggestions for Further Development

- **Story Mode**:  
  A future feature that packages a user’s curated images, along with textual annotations, into a shareable web gallery or mini digital zine.

- **Annotations UI**:  
  Possibly layering short text notes onto a “selected sequence” of images so that each “chapter” in a photo essay has a distinct thematic anchor.

- **Editorial Guidelines**:  
  Encouraging or guiding best practices for consistent imagery, color, or timing if the user wants a coherent final look.

---

_Last updated: 2025-01-12_
```

### **./CINEMATIC-VISION.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application. It enables browsing, filtering, and exporting photos from your macOS Photos library.

## Project Structure

- **backend/**: Express.js backend application.
- **frontend/**: Ember.js frontend application.
- **DEVELOPMENT_PLAN.md**: Roadmap and implementation details.
- **ISSUES.md**: Issues, debugging steps, and resolutions.
- **project-guidelines.md**: Collaboration and coding standards.

## Features

- **Album Navigation**: Browse albums via a left-side navigation column.
- **Photo Display**: View photos in selected albums with various sort options.
- **Faceted Person-Based Filtering**:  
  Under the currently active album, see a list of all recognized people.
  - **Single Person Filter**: Click one person’s name to display only photos with that individual.
  - **Multiple People Filter**: Select additional names to narrow photos down to those containing _all_ the chosen individuals, enabling powerful faceted search.
- **Sorting**: Sort photos by various attributes (e.g., aesthetic scores).
- **Photo Selection**: Select multiple photos; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Freshness

- The backend checks for changes in the Photos library.
- Cache invalidation ensures up-to-date album and photo data.

## Performance and Optimization

- JSON:API compliance for seamless Ember Data integration.
- Plans to implement lazy loading and indexing for improved performance.

## UI/UX

- Nested routes (`{{outlet}}`) for clarity.
- Future enhancements include more intuitive multi-person selection interfaces and better export feedback.

## Post-Photo-Filter Export Workflow: Preparing Photos for Video Editing

Once you have exported a directory of photos from the Photo Filter application, you may want to prepare them for video editing in Final Cut Pro X (FCPX) or another professional non-linear editor. The following steps outline how to normalize image orientation, generate a consistent file list, determine dimensions, and create a ProRes video file that preserves aspect ratios for all images.

**Prerequisites:**

- [ImageMagick](https://imagemagick.org/index.php)
- [FFmpeg](https://ffmpeg.org/) and its associated tools (e.g., \`ffprobe\`)
- A directory of \`.jpg\` images exported from the Photo Filter app

### 1. Ensure All Images Have the Correct Orientation

Use ImageMagick to apply rotation metadata directly to the pixel data. This ensures that downstream tools see the images correctly oriented:

\`\`\`bash
brew install imagemagick
mogrify -auto-orient \*.jpg
\`\`\`

### 2. Generate a File List for ffmpeg

First, list all \`.jpg\` images in the current directory:

\`\`\`bash
ls -1 \*.jpg > file_list.txt
\`\`\`

Then convert that listing into a format ffmpeg can parse:

\`\`\`bash
awk '{print "file \x27" $0 "\x27"}' file_list.txt > formatted_list.txt
\`\`\`

### 3. Determine the Dimensions of the First Image

Check the width and height of one of your images using ffprobe. Replace \`DSCF8482.jpg\` with an actual image filename from your directory:

\`\`\`bash
ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 DSCF8482.jpg
\`\`\`

Suppose this returns \`6240,4160\`. These will be your reference dimensions.

### 4. Convert Images to a Video with Preserved Aspect Ratios

Use ffmpeg to generate a ProRes \`.mov\` file. Scale and pad each image to fit the chosen dimensions (e.g., \`6240x4160\`) without distortion. Replace \`6240\` and \`4160\` with the values obtained above:

\`\`\`bash
ffmpeg -f concat -safe 0 -i formatted_list.txt \
-vf "scale='min(iw\*4160/ih,6240)':4160,setsar=1,pad=6240:4160:(6240-iw)/2:(4160-ih)/2" \
-framerate 16 -c:v prores -pix_fmt yuv422p output_preserved_aspect.mov
\`\`\`

**What This Does:**

- **Scale:** Adjusts each image so that it fits within the 6240x4160 frame, preserving its aspect ratio.
- **Pad:** Centers the scaled image by adding black bars if needed.
- **ProRes Encoding:** Outputs a high-quality \`.mov\` file suitable for editing in Final Cut Pro or other professional NLEs.
- **Framerate:** Sets the video to 16 frames per second, which you can adjust as desired.

### Additional Tips

- **Adjust the Frame Rate:**  
  Change \`-framerate 16\` to your desired frame rate (e.g., \`-framerate 24\`).

- **Change the Output Codec:**  
  Prefer a different codec (e.g., H.264 for smaller file sizes)? Replace \`-c:v prores -pix_fmt yuv422p\` with \`-c:v libx264 -crf 18\`.

- **Further Refinements:**  
  If you have specific creative requirements (e.g., adding transitions, stabilizing footage, or applying filters), you can incorporate those steps into your ffmpeg pipeline or perform them later in your video editing software.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter

   2.	Backend Setup:
   ```

cd backend
npm install
npm run setup
npm run dev

    3.	Frontend Setup:

Open a new terminal window:

cd frontend/photo-filter-frontend
npm install
npm run start

    4.	Access the Application:

Visit http://localhost:4200.

Contributing
• Use clear and descriptive commit messages.
• Track issues in ISSUES.md.
• Follow guidelines in project-guidelines.md.

Testing
• Backend: Use Jest for tests (npm run test in backend/).
• Frontend: Use Ember CLI testing (npm run test in frontend/).

License

This project is licensed under the MIT License.

### 2025‑06‑16 — UTC filename upgrade

> **Breaking change:** After clearing `backend/data/albums`, all newly exported
> images will have a UTC timestamp prefix (see `docs/FILE‑NAMING.md`).
> Old caches can safely be deleted; no user‑visible paths changed.
```

### **./RELATIONAL-PRACTICES.md**
```
# CINEMATIC-VISION.md

The Photo Filter Application stands at the intersection of photography and cinema, enabling the user to create the “shortest of short films,” as described in the project’s original vision. This file elaborates on the cinematic aspects and how they might extend the application’s functionality.

---

## Core Cinematic Concepts

1. **Time-Based Sequencing**  
   Users can take advantage of the app’s sorting and filtering to create sequences where small differences between frames become visually compelling, reminiscent of time-lapse or stop-motion animation.

2. **Micro-Motion**  
   When images shot in quick bursts or with intentional repeated framing are lined up, subtle changes (e.g., shifting facial expression, slight camera tilt) create illusions of motion, bridging photography and cinematic flow.

3. **Montage and Discontinuity**  
   By rearranging images out of chronological order or mixing high aesthetic-score images with unexpected angles, users can produce “montage” effects that disrupt linear narrative. This allows more experimental or conceptual short film structures.

---

## Potential Future Features

- **Montage Editor**  
  A UI overlay that allows users to drag and drop frames into a timeline. This timeline could export directly to Final Cut Pro–ready clips or sequences.

- **Cinematic “Arcs”**  
  Extend the concept of filtering by aesthetic score. For instance, choose a “continuity arc” for similar angles or a “contrast arc” to jump between drastically different shots.

- **Smooth Transitions & Keyframing**  
  Collaborate with advanced post-processing (e.g., using Final Cut or third-party scripts) to identify “key frames” or intervals to create a smoother bridging effect.

---

## Workflow Integration with Video Editors

- **Export for Final Cut Pro**  
  The application can already export a folder of images with standardized filenames. Integrating optional metadata or “cue sheets” (time stamps, ordering) could make the handoff to FCPX more seamless.

- **Two-Stage Export**
  1. **Rough Cut**: The user chooses and orders frames in the Photo Filter application.
  2. **Fine Cut**: Final Cut, Premiere, or DaVinci Resolve handles advanced transitions, color grading, and motion stabilization.

---

## Acknowledgments

- Influenced by the tradition of single-frame shutter usage in film cameras.
- Inspired by analog film editing aesthetics (cast iron film editors, splicing tape).
- Encourages a deeper exploration of “the space and time between photos.”

_Last updated: 2025-01-12_
# RELATIONAL-PRACTICES.md

This document outlines the cultural and mindful norms for collaboration—among humans, AI systems, or any other stakeholders. It expands on our Compassion Software Principles and clarifies how disclaimers in [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md) are woven into daily operations.

---

## 1. Guiding Principles

1. **User Ownership of Memories**

   - Acknowledge that photos can be precious or vulnerable data.
   - If an update (e.g., to the filtering UI) might inadvertently surface sensitive imagery, we must carefully label the change and tie it to disclaimers.

2. **Shared Authorship**

   - All contributors—team members, open-source participants, advisors, AI assistants—co-create the code, docs, and user experience.
   - This means we also _share responsibility_ for ensuring disclaimers stay current and that the code remains mindful.

3. **Transparent Communication**

   - Propose new disclaimers or feature updates openly.
   - Use “emotional check” markers in issue threads to highlight potential triggers or emotional complexities.

4. **Mindful Interactions**
   - **AI Involvement**: Whenever AI helps generate code, note it in commit messages or comments. This fosters trust and traceability.
   - **Conflict Mediation**: If a design choice might be emotionally charged—like defaulting to AI-based face identification—take a short reflection period. Possibly label the pull request as “Mindful Review Requested.”

---

## 2. Recommended Practices

- **Code Reviews**

  - Evaluate PRs with an eye toward how disclaimers or mindful language might be updated.
  - Encourage short, gentle feedback rather than abrupt rejections.

- **Issue Discussions**

  - Mark potential sensitive tasks with `[Emotional Load]` or `[Trigger Warning]`.
  - If uncertain about user impact, reference [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md) or ask another contributor to do a relational check.

- **Documentation Updates**
  - Where possible, embed short disclaimers or notes directly in relevant doc sections.
  - Link to broader disclaimers in [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md) so readers can easily find more detail.

---

## 3. Integrations with `COMPASSION.md`

- **Emotional Mapping**: If we add or change how the user can label photos with emotional markers, we reflect that in the disclaimers and ensure contributors realize the potential sensitivity in triaging emotional data.
- **Self-Compassion Toolkit**: Encourage devs and testers to notice if they’re pushing themselves too hard. Use or adapt “Take a mindful pause” prompts in the code review template.

---

## 4. Practical Examples

### Example A: Submitting a PR That Adds a New Person-Recognition Feature

1. Update `MINDFUL-DISCLAIMERS.md` with a short note that recognition may reveal old or painful memories.
2. In your PR, mention potential emotional triggers from unexpectedly seeing certain faces.

### Example B: Changing Default Sort Behavior

1. If you default to “score.overall,” clarify that photos with high aesthetic scores might overshadow meaningful but less “perfect” pictures.
2. Consider how disclaimers in the UI can remind the user that aesthetic scoring is subjective and not a measure of personal value.

### Example C: Renaming an Album or Photo Key

1. If the name has cultural or personal significance, note the reason for renaming in your commit.
2. Flag it for mindful review if the rename might distress certain user groups.

---

## 5. Respectful Off-Ramps

- **When a Collaborator Needs a Break**

  - They can take a “mindful pause” from tasks, ensuring someone else can temporarily cover or postpone.
  - Avoid penalizing or stigmatizing these breaks; we assume best intentions and protect each other’s well-being.

- **User Data and Boundaries**
  - If a user decides to _not_ see certain content, we respect that choice.
  - In code or design discussions, never override user-set preferences for the sake of a “cool new feature” without a thorough relational check.

---

## 6. Encouraging a Broad Community Dialogue

- **Periodic Check-Ins**
  - Host short “town halls” or Slack threads for feedback on disclaimers or emotional features.
- **Educational Materials**
  - Provide short tutorials on “emotional filtering” or “mindful cinematic transitions” so new devs see how we combine technical and relational awareness.

---

## 7. Looking Ahead

1. **Multi-Language Disclaimers**:
   - As the user base diversifies, consider translations or culturally specific disclaimers.
2. **Audio-Visual Sensitivities**:
   - If the app starts offering audio or video, disclaimers should expand accordingly.
3. **Continuous Adaptation**:
   - Keep an open channel for refining disclaimers, especially if new emotional scenarios or expansions arise.

---

**Last Updated**: 2025-01-12
```
```


### **./COMPASSION.md**
```
### **./TESTING_GUIDE.md**
```
# COMPASSION.md

## **Compassion Software Principles**

This document outlines the foundational principles and guidelines for embedding compassion into the design, development, and lifecycle of the Photo Filter Application. These guidelines build upon our previous frameworks (like the approach used in healthcare-helper) and reflect the unique emotional terrain of working with photographic memories.

---

## **Core Principles**

1. **Self-Compassion**

   - Recognize that software creation is an iterative process, often involving learning curves and emotional labor.
   - Encourage breaks, acknowledging personal limits, and normalizing discussions of stress or overwhelm.
   - Where feasible, embed supportive text within the UI or code comments (e.g., “Take a moment to rest your eyes if you feel tired.”).

2. **Radical Acceptance**

   - Embrace the reality that users may have a myriad of emotional responses to images.
   - Develop features with the understanding that unpredictability is part of real life.
   - This fosters resilience in code and documentation, preparing for edge cases and user feedback.

3. **Relational Intelligence**

   - Recognize that photos may represent interpersonal dynamics—family, friendships, or community ties.
   - Develop features (e.g., person-based filtering) with a sense of relational care and caution.
   - Provide prompts or disclaimers (see [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md)) when actions could unearth sensitive content.

4. **Trauma-Informed Design**

   - Anticipate that some images may trigger painful memories.
   - Offer UI pathways to gracefully skip or hide content, especially if repeated exposure would be detrimental.
   - Document these practices so that future contributors maintain a trauma-informed perspective.

5. **Mindful Technology**

   - Avoid gamification of addictive usage patterns. Instead, encourage intentional usage.
   - Keep features like multi-person filtering or aesthetic scoring transparent and adjustable, so users remain in control.
   - Build mindful reflection points into the development cycle (e.g., code reviews that check for potential emotional or ethical pitfalls).

6. **Collaborative Systems**
   - Expand on the notion that we co-create meaning with our community.
   - Include a healthy dialogue in issue threads and documentation updates, factoring in emotional and cultural perspectives, not just technical ones.
   - Seek feedback from diverse viewpoints, ensuring the final product respects a broad user base.

---

## **Stations of the Software Apparatus**

1. **Design**

   - Start with a sense of empathy for how images can affect well-being.
   - Sketch out user flows that are easy to exit or pause if content is overwhelming.

2. **Implementation**

   - Code modularly so emotional or specialized features can be toggled or refined based on user comfort levels.
   - Maintain robust error handling that gracefully communicates potential data or user experience issues.

3. **Interaction**

   - Provide optional “emotional check-ins,” especially when browsing large sets of personal photos.
   - Label potentially intense transitions (like face recognition or time-lapse creation) with short disclaimers or soft warnings.

4. **Iteration**
   - Embrace iterative learning. Regularly check the system for relational blind spots (see [RELATIONAL-PRACTICES.md](./RELATIONAL-PRACTICES.md)).
   - Refine disclaimers, UI language, or code structure based on feedback, updated trauma-informed knowledge, or cultural changes.

---

## **Features to Prioritize**

- **Emotional Mapping**  
  Explore ways the user can note or categorize emotional significance or triggers for specific images.

- **Self-Compassion Toolkit**  
  Provide gentle reminders or prompts to step away or breathe if usage sessions become too lengthy or intense.

- **Nonviolent Communication Templates**  
  Offer respectful language suggestions for shared album annotations or group critiques.

- **Safe Spaces & Hiding Tools**  
  Possibly enable “hide from feed” features for images that might be too raw at certain times.

- **Narrative Storytelling Features**  
  Continue bridging cinematic arcs and mindful curation, allowing personal reflection in curated “photo stories.”

---

## **Ethical Commitments**

- **Privacy First**: The code respects local storage by default; network sharing is optional and user-driven.
- **Bias Awareness**: If AI or face recognition is used, remain vigilant about potential biases and correct them swiftly.
- **Cultural Sensitivity**: Recognize that images hold different meanings across diverse contexts; design inclusive labels and disclaimers.
- **Developer Accountability**: Our process includes reflection on how code changes might affect the emotional or relational experience.

---

## **Developer Guidelines**

1. **Collaborate with Empathy**  
   Provide context or emotional caution in pull requests if new features or large data sets might stir strong feelings.

2. **Document Decisions Thoughtfully**  
   In your commit messages or merges, describe not just _what_ changed but also _why_—especially if it touches on ethical or emotional aspects.

3. **Test for Relational Impact**  
   Where feasible, ask: “Could this feature inadvertently expose, highlight, or hide sensitive content?”

4. **Iterate with Care**  
   Carefully evolve the code base. If removing or renaming a feature that users might be emotionally attached to, add disclaimers.

---

## **Future Directions**

- Incorporate direct references to mental health resources or hotlines if the platform broadens to more general use.
- Gather community stories to shape new disclaimers or mindful prompts, ensuring a continuous feedback loop.

---

## **Integration with Relational Practices**

We amplify these principles further in [`RELATIONAL-PRACTICES.md`](./RELATIONAL-PRACTICES.md). That file offers practical examples for ensuring the **spirit** of compassion is upheld daily—during code reviews, user interactions, and all forms of collaboration.

**Last Updated: 2025-01-12**
```

### **./DEVELOPMENT_PLAN.md**
```
# TESTING_GUIDE.md

## Purpose

This document serves as a comprehensive guide to writing tests for the Photo Filter Application, integrating the lessons we’ve learned during development and test automation. It covers **acceptance**, **unit**, and **integration** test approaches; strategies for handling uncertain data sets; and how to ensure that tests accurately reflect real-world user flows.

---

## Table of Contents

1. [Overview of Testing Approaches](#overview-of-testing-approaches)
2. [Acceptance Tests](#acceptance-tests)
   - [Query Params and Faceted Filtering](#query-params-and-faceted-filtering)
   - [Robustness with Large or Uncertain Data](#robustness-with-large-or-uncertain-data)
   - [UI Navigation and Edge Cases](#ui-navigation-and-edge-cases)
3. [Unit Tests](#unit-tests)
4. [Integration Tests](#integration-tests)
5. [Performance Considerations](#performance-considerations)
6. [Stubbing, Mocking, and Fixture Data](#stubbing-mocking-and-fixture-data)
7. [Guidelines and Best Practices](#guidelines-and-best-practices)
8. [Further Directions](#further-directions)

---

## 1. Overview of Testing Approaches

- **Acceptance Tests**: Verify end-to-end user stories, ensuring that a user can navigate the application, toggle features, and see expected outcomes.
- **Unit Tests**: Verify isolated functionality in models, helpers, or services without external dependencies.
- **Integration Tests**: Check interactions between components or modules in partial isolation, ensuring rendering or data flows work as intended in the Ember context.

Because this project has both a **frontend (Ember)** and a **backend (Express)**, we also rely on:

- **Backend Tests (e.g., Jest)**: For controllers, utilities, data exporting, or other Node/Express logic.
- **Full-Stack Validation**: Light acceptance tests that exercise real data to confirm the entire pipeline is stable (optional, depending on your CI environment).

---

## 2. Acceptance Tests

### Query Params and Faceted Filtering

1. **Multi-Person Selection**

   - **Why**: Ensures that toggling multiple individuals in an album updates the URL’s query parameters, filters the displayed photos accordingly, and persists state on refresh.
   - **How**:
     - Use `visit('/albums')` to load the album listing.
     - Click each album link in turn until you find one that actually has recognized people.
     - Toggle the first person, confirm the URL now contains `persons=...`.
     - Toggle additional persons and check the query string for multiple values.

2. **Sorting and Ordering**
   - **Why**: Guarantee that changing `sort` and `order` modifies the photo list accordingly.
   - **How**:
     - Programmatically select from a `<select>` menu or directly manipulate query params.
     - Confirm that the displayed items re-sort, and that the final URL includes correct query param values, e.g. `sort=score.overall&order=asc`.

### Robustness with Large or Uncertain Data

- **Don’t assume the first album has data**: A key takeaway was that your test logic can’t just pick “the first album” to test person toggles. Instead, loop through albums until you find one with recognized faces.
- **Fallback**: If you never find an album with persons, gracefully skip or assert “no persons found.” This ensures tests remain robust against real-world data that might be sparse or inconsistent.

### UI Navigation and Edge Cases

1. **Navigation**

   - Check that transitions are correct (e.g., after clicking an album link, you land on `/albums/:album_id`).
   - Confirm elements like the `.grid` or `.card` appear in the DOM to validate that photos are actually rendered.

2. **Edge Cases**
   - If some albums have zero photos or zero recognized persons, ensure your test doesn’t blow up.
   - If you rely on ephemeral data, consider whether to stub or mock for truly deterministic runs.

---

## 3. Unit Tests

- **Models** (e.g., `album-test.js`, `photo-test.js`): Confirm that each model can be created and that key relationships or computed properties work as intended.
- **Helpers**: Small, pure JavaScript transformations (e.g., `capitalize`, `replace`, `contains`) can be tested quickly.
- **Services**: Check that your “current-album” or “selection” services manage state as expected.

**Key Lessons**:

- Keep unit tests narrow in scope; they should fail only if their logic changes, not if external data or routes shift.

---

## 4. Integration Tests

- Typically used to test how Ember components (and their templates) interact with one another in partial isolation.
- Great for validating that a component properly renders a list of photos, or that toggling a local state affects CSS or child components.

**Considerations**:

- If your components heavily rely on the store or route data, weigh whether an acceptance test might be more suitable.
- For purely presentational logic (e.g., show/hide states), integration tests are ideal.

---

## 5. Performance Considerations

- **Large Albums**

  - Ember acceptance tests can cause timeouts or memory usage issues if you load thousands of photos.
  - Use pagination or a limit query param if necessary, or rely on specialized acceptance tests for smaller sample data.

- **Server-Side**
  - Jest tests for Express code should also consider performance. For instance, if you’re exporting thousands of images, ensure you only test the logic in a controlled scenario (or mock the file system calls).

---

## 6. Stubbing, Mocking, and Fixture Data

- **Why**: Real data can be unpredictable (some albums might have no recognized persons).
- **How**:
  - Use **fixtures** or **mocks** in acceptance tests for deterministic coverage when possible.
  - For example, Ember can intercept server requests with Pretender or Mirage (though this project hasn’t fully integrated them yet).
  - On the backend, you can temporarily mock `fs-extra` or `osxphotos` calls to test edge cases.

**Balance**: Keep some acceptance tests fully “live” with real data to confirm production usage, but rely on mocks or fixtures for consistent local coverage.

---

## 7. Guidelines and Best Practices

1. **Write Tests Alongside Features**

   - As soon as you add a new route or feature, create acceptance or integration tests.
   - Keep tests passing at each commit to maintain momentum.

2. **Small, Focused Assertions**

   - Each test should have a clear “Given, When, Then” structure. Avoid overloading a single test with too many steps.

3. **Don’t Overly Depend on Data Hard-Coded Indices**

   - Instead of “click the first album,” try to filter or search for an album with the property you need.
   - This approach is more robust if data changes in the future.

4. **Observe and Log**

   - Pepper your acceptance tests with small console logs or debug steps (like your “Found X album links…”). This helps diagnose data-based issues.

5. **Check the URL**

   - Ember’s query params are crucial for your filtering. Confirm the final `currentURL()` includes the expected param changes.

6. **Clean Up After**
   - If your test scripts alter data, ensure you restore or reset state (if relevant).
   - Typically, acceptance tests revert to default by reloading the page or using `visit()` again.

---

## 8. Further Directions

1. **Automated Mocking**

   - Tools like [Ember Mirage](https://github.com/miragejs/ember-cli-mirage) can generate a fake API for acceptance tests, ensuring consistent datasets.

2. **Advanced Performance Testing**

   - Investigate tests that specifically measure how the app handles large volumes of photos (time to render, memory usage).
   - Could be part of your CI pipeline with a special “stress test” mode.

3. **Visual Regression Testing**

   - For a photo-centric application, consider snapshot or visual-diff testing to catch unexpected UI changes.

4. **CI Integration**
   - Ensure all tests run in your GitHub Actions or other CI. If you have a large test suite, parallelize or selectively skip certain large-data tests by default.

---

## Conclusion

The overarching goal is to keep your tests realistic, robust to changes in data, and short enough to remain maintainable. By following these guidelines—writing acceptance tests that adapt to dynamic data, layering in unit tests for smaller logic, and employing integration tests for component interactions—you’ll maintain confidence in your system as it grows.

Feel free to add, modify, or refine these sections to match your team’s specific workflow. When in doubt, **test early** and **test often**.

---

**Last Updated**: 2025-01-12  
**Maintainer**: [Your Name or Team]

---

**How to Use**

1. Place this file in the root of your monorepo as `TESTING_GUIDE.md` (or adapt the file name as you wish).
2. Keep it updated whenever you refine test strategies or introduce new complexities.
3. Reference it in your pull requests or issue templates so everyone can stay aligned on test-writing best practices.

---

_End of `TESTING_GUIDE.md`_
```

### **./TIMELINE_TAXONOMY.md**
```
# Development Plan

### December 14, 2024: Tailwind & DaisyUI Integration Update

**Decision & Implementation:**

- Removed `@import` of Tailwind CSS files in `app.scss` and replaced them with:
  ```scss
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  ```

### Update: Transition to Query-Param-Based Faceted Person Filtering

**Date:** December 12, 2024

**Decision:**

- Move from nested person-specific routes toward a unified album route that uses query parameters to filter by selected individuals.
- The UI will display a list of people in the left navigation under the currently active album. Users can toggle individuals on or off (via checkboxes or links), and the album’s displayed photos will filter to include only photos with all selected individuals.
- Remove the separate “View People in this Album” link and the “Back to Albums” link, as album navigation and person filtering are now integrated in the left nav.
- Eventually incorporate a front-end UI framework (like Bootstrap or Material Design) for a more cohesive look and feel.

**Rationale:**

- **Integrated Navigation:** Having all filtering (by album, by people) and sorting in one unified route simplifies the user experience.
- **Improved UX:** No need to navigate to a separate persons sub-route. People-based filtering is just another facet of the main album view.
- **Scalability:** Query params enable easy multi-person filtering. As the user selects multiple names, they appear in the URL’s query params, making the filtering state shareable and bookmarkable.
- **Future-Ready:** Paves the way to easily add other facets (like tags, locations, or events) as query-parameter-based filters.

**Implementation Steps:**

1. **Remove Person Sub-Routes**  
   No longer need `albums/album/persons` or `albums/album/persons/person/:person_name`.
2. **Update Album Route to Use Query Params**  
   Add a `people` query param to `albums.album`, update toggles, etc.
3. **UI Updates**  
   People filters appear in the left nav, integrated with album listing.
4. **Backend**  
   The backend remains largely the same. For multi-person queries, client-side filtering is primary; future server optimization possible.
5. **Documentation**  
   Update relevant docs: `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `README.md`.
6. **Testing and Validation**  
   Confirm query params work and that reloading with persons in the URL is stable.

**Potential Challenges:**

- Complex filtering for large libraries might need caching or indexing.
- UI complexity if many persons are toggled.

---

### Previous Updates

- **December 7, 2024**: Initial person-level sub-routes conceived.
- **November 12, 2024**: Introduced nested routes, left nav, and sorting.
- **November 1, 2024**: Added cache invalidation for data freshness.
- **October 30, 2024**: Adopted JSON:API serializer.

---

## Project Goal

Create an intuitive, facet-based photo exploration tool integrated with macOS Photos data, enabling advanced sorting, selection, exporting, and multi-person filtering.

---

## Current State

- **Frontend**: Ember.js with album-level sorting and filtering done on the frontend for performance.
- **Backend**: Express.js, JSON:API, data from `osxphotos`.
- **Data Handling**: `osxphotos` extracts metadata; `photos.json` captures results for each album.
- **Selection & Export**: In progress.
- **Documentation & Styling**: Ongoing enhancements.

---

## Next Steps

1. **Implement Multi-Person Filtering with Query Params**  
   Completed the initial approach; further refinements ongoing.
2. **Improve Export Feature**  
   Integrate actual export logic on the backend, plus UI feedback during export.
3. **UX and Performance**  
   Potentially add an indexed DB or partial caching for large datasets; also set up a refresh route.
4. **Testing & Quality Assurance**  
   Strengthen acceptance tests (e.g. `person-filtering-test.js`).
5. **Documentation & Cleanup**  
   Keep all docs updated; refactor code for maintainability.

---

## Cinematic Montages and Artistic Workflow

With the emerging cinematic use cases (see `CINEMATIC-VISION.md` for deeper discussion):

- **Facilitating “Short Films”**  
  Users often drag out ~150 images, place them into an external video editor (Final Cut Pro or similar), and generate micro-animations or time-lapse sequences. Our sorting by aesthetic score or by recognized faces can help them find key frames or ensure coverage of all event participants.

- **Montage Tools**  
  While advanced timeline editing is best left to specialized video software, the Photo Filter app can provide “proto-montage” capabilities:

  - Exporting images in a “chronological yet selective” order.
  - Tagging or marking intervals for quick selection in FCPX.
  - Potential future feature: “mini-sequence preview,” letting the user quickly flip through frames in the app (like a mechanical film editor’s spool).

- **Long-Term Vision**
  - Possibly integrate a “Montage Editor” overlay in the Ember frontend for a quick drag-and-drop sequence.
  - Provide “story arc” filters (e.g., stable lighting vs. highly varied frames).
  - Output an “XML timeline” or JSON for direct import into editing software.

This alignment of photography with micro-cinema underscores our commitment to bridging the still and moving image realms. By continuing to refine filtering and selection tools, we enable both everyday photographers and fine-art practitioners to unearth new narrative possibilities.

---

## **Time Taxonomy Feature (Planned)**

**Date:** January 12, 2025

**Overview:**
We will implement a **time-based hierarchy** in the left nav, similar to how we list people or albums. The system will only show Year → Month → Week → Day nodes if photos exist for those nodes. Clicking them filters the photo grid accordingly.

**Key Steps:**

1. **Metadata Aggregation**

   - Parse each photo’s date/time.
   - Populate a “time index” table or JSON structure, grouping by year, month, etc.

2. **Backend Endpoint**

   - A new route, e.g. `GET /api/time-index`, returns a hierarchical JSON of available years/months/weeks/days.

3. **Frontend UI**

   - In Ember, create a “Time” section in the left nav. Expand/collapse each year, month, etc.
   - Multi-select logic, updating query params with the chosen date slices.

4. **Querying**

   - Combine date filters with existing person/album filters. For instance, `dates=2024-12-07,2024-12-08` plus `persons=Margaret,Douglas`.

5. **Testing & Documentation**
   - Acceptance tests for multi-date selection.
   - Document in `TIMELINE_TAXONOMY.md`.

**Potential Roadblocks:**

- Large date range or scattered photos might complicate the UI. We’ll consider partial or lazy loading.
- Weeks are tricky—defining them consistently and avoiding user confusion.

**Schedule Estimate:**

- Implementation to begin after finishing the multi-person filtering enhancements (by mid-January 2025).
- Initial release by early February 2025, with refinements continuing.

---
```

### **./ISSUES.md**
```
# TIMELINE_TAXONOMY.md

## Purpose

This document describes our upcoming feature for a time-based navigation tree in the Photo Filter Application. We aim to let the user drill into Years → Months → Weeks → Days, but **only** for nodes that actually contain photos. This dynamic approach ensures we don’t clutter the UI with empty categories.

## Scope of the Feature

1. **Comprehensive Metadata Export**

   - We will export all available date/time metadata for each photo.
   - This may require a one-time or periodic “full scan” of the Apple Photos library to create an internal database/table for efficient lookups.

2. **Hierarchical Time Tree**

   - **Years**: Display each year that has at least one photo.
   - **Months**: Nested under each year, only show months that have photos.
   - **Weeks**: Potentially optional, but we’re considering an ISO week definition (e.g., week #1 is the week with Jan 4).
   - **Days**: Nested under each month or week, only if photos exist.

3. **UI/UX Goals**

   - **Left Nav Tree**: The user sees a collapsible tree (like a folder structure).
   - **Multi-Select**: The user can shift-click or ctrl/cmd-click multiple time nodes (e.g., 2024 + “December 12, 2024”).
   - **Album-Like Grid**: All selected nodes are combined into a single photo feed on the right side, akin to how we handle multi-person filtering.

4. **Backend/Database Changes**

   - We’ll likely store a separate table or index keyed by date (year, month, day). Possibly more columns for week or combined date parts.
   - Queries need to handle multiple disjoint sets of date criteria (like multiple days across multiple months).

5. **Performance Considerations**

   - We might have 100k+ photos. Building the entire tree on the fly could be slow.
   - Precompute or incrementally update a time index so the UI can quickly load partial aggregates.

6. **Multi-Level Selection**

   - **Example**: The user clicks “2024” in the tree → sees 7,000 photos for 2024 in the main area.
   - Then they expand “December 2024,” see each day. They select “December 7” and “December 8,” which refines the main area to 250 photos from just those days.
   - They can also simultaneously keep “2024” selected to add all of 2024. Or they can uncheck “2024” if they only want the two days.

7. **Integration with Person / Location Filters**

   - This time-based approach will integrate with the existing query-param-based filtering. So the user can do `dates=2024-12-07,2024-12-08` plus `persons=Margaret,Douglas` plus `locations=Vienna,Cambridge`.
   - In Ember, we might handle multiple query params or a combined param. This is still open for discussion.

8. **Roadmap**
   1. Build out the data structure for a “time index” in the backend.
   2. Extend the existing Ember app to add a Time nav section (like we do for People).
   3. Implement multi-select checkboxes or toggles for each date node.
   4. Combine the logic so that the final photo grid merges all selected times with any selected people, location, or aesthetic filters.

## Example JSON Snippet

We might store or return data like:

```json
{
  "years": [
    {
      "year": 2022,
      "months": [
        {
          "month": 5,
          "days": [12, 13, 18]
        }
      ]
    },
    {
      "year": 2024,
      "months": [
        {
          "month": 12,
          "weeks": [49, 50],
          "days": [7, 8, 9, 15, 30]
        }
      ]
    }
  ]
}
```

Note: **Whether** we nest weeks inside months or keep them separate is still under consideration.

## Next Steps

- Update `DEVELOPMENT_PLAN.md` to reference this approach.
- Start building actual endpoints that return the “time index.”
- Add a left nav UI in Ember that can request and display this index, with multi-select capability.

---

_Last updated: 2025-01-12_
```

### **./TYPESCRIPT_GUIDE.md**
```
# Issues and Resolutions

This file logs open issues and their statuses. Update it as new issues arise and existing ones progress.

---

## Issue 16: PostCSS "File not found: /app/styles/app.css" Error

**Opened By:** Jamie, Dec 14, 2024  
**Status:** In Progress

### Description

Encountered a build error because PostCSS didn’t find `app.css` after SCSS changes.

### Actions

- Installed `ember-cli-sass` to compile `app.scss` into `app.css`.
- Updated `app.scss` to use `@tailwind` directives instead of `@import`.
- (Alternative) Renamed `app.scss` to `app.css` and removed `ember-cli-sass`.

### Next Steps

- Verify build succeeds (`ember serve`).
- If successful, mark as Resolved after testing in production-like scenarios.

---

## Issue 15: Nested Routes Not Rendering Child Templates

**Opened By:** [Your Name], Nov 12, 2024  
**Status:** **Resolved**

### Description

`albums/album` route’s template not rendering correctly.

### Resolution

- Added `{{outlet}}` to `albums.hbs`.
- Verified proper rendering.

---

## Issue 14: 404 Error When Fetching Album Data

**Opened By:** [Your Name], Nov 10, 2024  
**Status:** **Resolved**

### Description

`GET /api/albums/:albumUUID` returned 404.

### Resolution

- Implemented `GET /api/albums/:albumUUID`.
- Confirmed endpoint now works as expected.

---

## Issue 8: Implementing Interactive Photo Selection and Persistence

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need multi-photo selection persistence across sorting and filtering changes.

### Actions

- Created `selection.js` service to manage selected photos.
- Selections persist when changing sort order or navigating within the album.

### Next Steps

- Integrate with multi-person filtering now that filtering is query-param-based.
- Ensure that selected photos remain selected as users toggle people filters.
- Write more comprehensive tests for selection persistence.

---

## Issue 9: Adding Actions for Selected Photos (Export Functionality)

**Opened By:** [Your Name], Oct 27, 2024  
**Status:** **In Progress**

### Description

Need to export selected photos from the backend once chosen on the frontend.

### Actions

- Created `/api/photos/export` endpoint.
- Frontend can send selected photo IDs to initiate export.
- Basic user alerts implemented to inform the user of export status.

### Next Steps

- Implement actual export logic on the backend.
- Add progress indicators (e.g., a progress bar) in the UI.
- Validate that exported filenames handle duplicates properly.

---

## Issue 16: Filename Collisions in Exports

**Opened By:** [Your Name], Dec 11, 2024  
**Status:** **Open** (Reopened Dec 12, 2024)

### Description

When exporting images, sometimes duplicate filenames occur.

### Current Approach

- Prepend date/time to filenames.
- Append counters for duplicates.

### Next Steps

- Confirm that this approach truly prevents collisions.
- Test extensively in a real environment before marking resolved.

---

## Newly Considered Issue: Replacing Person Sub-Routes with Query Params

**Opened By:** [Your Name], Dec 12, 2024  
**Status:** **In Planning**

### Description

We initially implemented `albums/album/persons` sub-routes. We now want to remove them in favor of query params on the main album route. This will unify navigation and filtering, removing the need for “Back” or “View People” links.

### Actions

- Update `DEVELOPMENT_PLAN.md` to reflect query-param-based person filtering.
- Adjust frontend UI to list people under the album in the left nav.
- Remove old person sub-route code once the new system is tested.

### Next Steps

- Implement toggles for people in the sidebar.
- Update the album route model hook to filter photos by selected people.
- Fully test the new approach.

---

## Issue 17: Persons Not Appearing in Album UI

**Opened By:** [Your Name], Dec 13, 2024  
**Status:** **Open**

### Description

Even though the backend returns `persons` as included data when fetching an album, they do not appear in the UI. In Ember Inspector, we see `album.persons` is present, but on the active controller, `persons` remains empty because the PromiseManyArray was not awaited before use.

### Actions

- In `app/routes/albums/album.js`, awaited `album.persons` before mapping/filtering.
- Once verified and tested, we can mark this issue resolved.

### Next Steps

- Verify persons now appear as expected.

---

## New Issue: `photoPersonNames` Always Empty in Controller

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** **Open**

### Description

We’re trying to filter photos by selected persons. However, `photoPersonNames` in `albums/album.js` controller logging always returns an empty array. The reason seems to be that `photo.persons` is not properly populated with Person model instances. Even though we have `@hasMany('person')` defined, the `persons` data might be coming in as raw strings rather than proper JSON:API relationships.

### Proposed Frontend-Only Fix

We can create a custom serializer for `photo` on the frontend that transforms the raw `persons` attribute into proper JSON:API relationships. This ensures Ember Data recognizes the `persons` as PersonModel instances.

### Next Steps

- Implement a `photo.js` serializer in `app/serializers/photo.js` that modifies the `normalize` response, converting `persons` strings into relationship objects and (optionally) included person records.
- Test if `photo.persons` now returns actual Person models.
- Confirm that `photoPersonNames` is no longer empty.

---

## Performance Impact from Re-Fetching Large Albums on Sort/Filter Changes

**Opened By:** [Your Name], Dec 15, 2024  
**Status:** Open

### Description

Changing sorting/filtering previously caused large album re-fetches, leading to delays. We implemented front-end-only sorting/filtering to avoid unnecessary re-fetches.

### Actions

- Moved sorting and filtering logic to the frontend.
- Initial load might be slower, but subsequent operations are fast.

### Next Steps

- Consider indexed DB, cache invalidation strategies, pagination, or lazy loading for scalability.
- Monitor performance and refine as needed.

---

## Issue 19: Chrome "Aw, Snap!" Crash on Large Albums

**Opened By:** [Your Name], Dec 21, 2024  
**Status:** **Resolved**

### Description

When an album contains a very large number of photos (hundreds or thousands), Chrome sometimes crashes with an “Aw, Snap!” error code 5. This typically indicates the browser is running out of memory or hitting some resource limit.

### Resolution

- **Implemented a default limit (e.g., 200 photos) when requesting an album** to prevent the UI from trying to render or sort thousands of photos at once.
- Added a `limit` query param so advanced users can pull more photos if needed (with caution).

### Next Steps

- For truly large datasets, implement full pagination instead of a single “limit” slice.
- Monitor memory usage when increasing `limit`.

---

## Issue 20: Time Taxonomy in Left Nav

**Opened By:** [Your Name], Jan 12, 2025  
**Status:** Open

### Description

We want to add a new time-based taxonomy (Years → Months → Weeks → Days) in the left nav. Only show nodes with existing photos. Let the user multi-select date ranges to form a combined album view on the right side, possibly also filtering by people.

### Proposed Actions

1. **Add a new `time-index` endpoint** returning a hierarchical JSON of years, months, weeks, days.
2. **Implement a new Ember route and left nav section** for the time taxonomy.
3. **Support multi-select** (like checkboxes).
4. **Combine with existing person filters**.

### Next Steps

- Add documentation (`TIMELINE_TAXONOMY.md`) describing the data structure.
- Add a proof of concept for generating a time index from our photo metadata.
- Build or update acceptance tests to ensure multi-time-slice selection works.

---
```

### **./MINDFUL-DISCLAIMERS.md**
```
# TypeScript Integration Guide

Welcome to the Photo Filter Application’s TypeScript integration guide. This document explains how we are progressively introducing TypeScript into both our **backend** (Express.js) and **frontend** (Ember.js) projects, including linting, Prettier, and shared data interface practices.

---

## Table of Contents

1. **Motivation**
2. **Backend (Express) Setup**
   - Installing Dependencies
   - Creating `tsconfig.json`
   - Updating `package.json` Scripts
   - Renaming `.js` to `.ts`
3. **Frontend (Ember) Setup**
   - Installing Ember TypeScript
   - Creating or Modifying `tsconfig.json`
   - Typical File Renaming Strategy
4. **Shared Data Interfaces**
5. **Linting & Prettier**
6. **Phased Migration Strategy**
7. **References & Next Steps**

---

## 1. Motivation

- **Consistency**: Make the codebase approachable across backend and frontend.
- **Safety**: Catch type mismatches, especially around date values, route params, and Photos metadata.
- **Collaboration**: Provide a single source of truth for shared data interfaces.

We are doing a **phased** approach: not rewriting everything in TypeScript at once, but introducing `.ts` or `.d.ts` files as we modify or create new files.

---

## 2. Backend (Express) Setup

### 2.1 Installing Dependencies

At the **root** of your `backend/` folder, run:

```bash
cd backend
npm install --save-dev typescript @types/node @types/express
```

If you also want to type-assert your tests (e.g., Jest), add:

```bash
npm install --save-dev @types/jest
```

### 2.2 Creating `tsconfig.json`

In `backend/`, create a file called `tsconfig.json` (see example below).

### 2.3 Updating `package.json` Scripts

In the `backend/package.json`, add or update scripts like:

```jsonc
{
  "scripts": {
    // ...
    "build:ts": "tsc --build",
    "start:ts": "npm run build:ts && node dist/server.js"
  }
}
```

This way, you can compile your `.ts` files into a `dist/` folder, then run them.

### 2.4 Renaming `.js` to `.ts`

- Start small: pick a single file, e.g. `server.js`. Rename it to `server.ts` and fix the imports.
- Update your imports to use TypeScript/ES modules style if needed, e.g.:
  ```ts
  import express from "express";
  ```
- Over time, continue converting controllers or utility files from `.js` → `.ts`.

---

## 3. Frontend (Ember) Setup

### 3.1 Installing Ember TypeScript

Inside your Ember app folder (`frontend/photo-filter-frontend`), run:

```bash
cd frontend/photo-filter-frontend
ember install ember-cli-typescript
```

This will create or modify certain TypeScript configuration files (like `tsconfig.json`), add the TypeScript compiler, and wire up Ember to handle `.ts` files.

### 3.2 Creating or Modifying `tsconfig.json`

If `ember-cli-typescript` doesn’t create a `tsconfig.json`, you can add one. (We provide a sample below.) Typically, `ember-cli-typescript` does the heavy lifting. Just ensure it references your desired TypeScript settings.

### 3.3 Typical File Renaming Strategy

- Start by renaming one or two Ember files, e.g. a service or a component, from `.js` → `.ts`.
- Fix the import statements and specify the class property types. For example:

  ```ts
  import Service from "@ember/service";

  export default class CurrentAlbumService extends Service {
    isAlbumRoute = false;
    albumTitle: string | null = null;
    // ...
  }
  ```

- If you see errors about “Cannot find module ...”, try re-running `npm run start` or `npm run lint`. The Ember CLI often picks up the new `.ts` files automatically.

---

## 4. Shared Data Interfaces

We frequently pass data between the Node backend and the Ember frontend in JSON. For instance, we have `Photo` or `Album` objects. We want a single source of truth, so we can do either:

1. **A Shared Folder** (e.g. `shared-types/` at the top-level) with `.d.ts` or `.ts` files that define `interface PhotoData { ... }`.
2. Then import them into `backend/` for Node usage, and also reference them in Ember.

**Example**:

```ts
// shared-types/PhotoData.ts
export interface PhotoData {
  uuid: string;
  originalFilename: string;
  date: string; // or Date if we handle parsing
  persons?: string[];
  // ...
}
```

**In backend**:

```ts
import { PhotoData } from "../../shared-types/PhotoData";

function processPhoto(photo: PhotoData) {
  // ...
}
```

**In Ember**:

```ts
import PhotoData from "photo-filter-frontend/shared-types/PhotoData";

// Then use PhotoData in a typed model or utility
```

This ensures the same shape is recognized across the stack.

---

## 5. Linting & Prettier

We already use ESLint + Prettier. Add or verify in `.eslintrc.js` that TypeScript is recognized:

```js
// Example snippet
module.exports = {
  parser: "@typescript-eslint/parser",
  extends: [
    "eslint:recommended",
    "plugin:ember/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended",
  ],
  // ...
};
```

**Prettier**: Make sure your `.prettierrc.js` also covers `.ts`:

```js
module.exports = {
  overrides: [
    {
      files: "*.{ts,js,json}",
      options: {
        singleQuote: true,
        // ...
      },
    },
  ],
};
```

---

## 6. Phased Migration Strategy

1. **Backend**: Convert `server.js` → `server.ts`, then your controllers, then your utilities.
2. **Frontend**: After `ember-cli-typescript` is installed, rename a small but crucial file (like a service or a component).
3. **Shared Types**: Start with a minimal `PhotoData` or `AlbumData` interface. Evolve it as you unify the codebase.

We encourage the approach: **“Convert as you touch.”** Each time you need to fix a bug in a file, rename it to `.ts` or add types. Over time, your coverage increases organically.

---

## 7. References & Next Steps

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [ember-cli-typescript Docs](https://emberjs.github.io/ember-cli-typescript/)
- [@typescript-eslint](https://typescript-eslint.io/) for linting
- **WIP**: We may eventually compile a single “combined” type definitions library used by the Python layer too, ensuring Apple Photos metadata is typed end-to-end.

_That’s it!_ If you have any issues or want clarifications, see the [ISSUES.md](./ISSUES.md) file or open a new discussion with your questions.
```

## Backend Files

# MINDFUL-DISCLAIMERS.md

## Purpose

This file centralizes all disclaimers and precautionary statements so that contributors, users, and stakeholders fully understand the relational and emotional considerations of working with photo-based data in the Photo Filter Application.

---

## 1. Emotional Sensitivity Disclaimer

**Context**  
Photography often contains memories with significant emotional resonance—family events, personal milestones, or reminders of loss. Filtering through large volumes of images may trigger unexpected memories or emotional responses.

**Disclaimer**  
While the Photo Filter Application aims to facilitate creative exploration, we acknowledge that certain imagery may evoke stress, sadness, or trauma. We encourage users and team members to practice self-care, take breaks, and seek supportive resources if distress arises.

---

## 2. Trauma-Informed User Interactions

**Context**  
Trauma-informed design helps us avoid re-traumatizing users inadvertently. The app occasionally surfaces old photos or personal moments that may intersect with difficult past experiences.

**Disclaimer**  
This software does not replace professional mental health support. If reviewing or sorting photos triggers severe emotional distress, please reach out to a qualified professional or mental health resource. The development team has integrated mindful language and gentle UI prompts, but we cannot predict or prevent all triggers.

---

## 3. Privacy and Data Sensitivity

**Context**  
The Photo Filter Application processes metadata from a user’s personal photo library. This metadata can include date/time, location, and face recognition data, all of which is sensitive.

**Disclaimer**  
Users are responsible for ensuring they comply with relevant privacy regulations and best practices. The code, as provided, does not collect or store your images on third-party servers beyond your local environment—unless explicitly connected to an external service by you. If you deploy the application in a shared or cloud environment, you must configure secure access controls.

---

## 4. Ethical Use of Visual AI

**Context**  
The platform can support or integrate with AI-based analytics (face detection, aesthetic scoring, etc.).

**Disclaimer**  
We caution contributors and end-users to assess whether these AI features align with their ethical standards. We assume no liability for misuse of AI-driven capabilities. Always audit your data processing flows for potential bias or discriminatory outcomes.

---

## 5. Developers’ Emotional Wellbeing

**Context**  
Much like users, developers can feel overwhelmed if managing intense or large-scale photo sets or dealing with emotional user stories. This is especially true when debugging or manually verifying large emotional archives.

**Disclaimer**  
We encourage all contributors to adopt healthy boundaries—take breaks, practice mindfulness, and communicate openly with the team if tasks feel personally distressing. We have formal guidelines in [COMPASSION.md](./COMPASSION.md) and [RELATIONAL-PRACTICES.md](./RELATIONAL-PRACTICES.md).

---

## 6. Iteration and Evolution

We intend these disclaimers to be living elements of the project. If new disclaimers become relevant, please add them here. We welcome feedback, suggestions, or expansions as the app evolves.

**Last Updated:** 2025-01-12
```

### **./project-guidelines.md**
```
Project Guidelines

Table of Contents

- Project Philosophy
- Keeping Up with Dependencies
- Data Formats
- Data Synchronization and Caching
- Ensuring Complete Project Overviews
- Coding Standards
- Naming Conventions
- Directory Structure
- Documentation Practices
- Privacy and Data Handling
- Project State and Continuity
- Issue Tracking and Debugging
- Collaboration Guidelines
- Environment and Dependency Management
- Error Handling and Logging
- Security Best Practices
- Testing
- Deployment and Operations
- Performance Optimization

---

## Project Philosophy

- User-Centric Design, Interactivity, Clarity, Modularity, Consistency.
- Ember.js Conventions: Follow Ember.js patterns.
- Privacy, Security, Performance, Scalability.
- Embrace Iterative Understanding: Treat solutions as provisional and open to revision.

## Keeping Up with Dependencies

- Stay informed of the latest versions and updates.
- Test thoroughly after upgrading dependencies.
- Document changes and version notes.

## Data Formats

- Use JSON:API for backend/frontend integration.
- Utilize `jsonapi-serializer` on the backend.

## Data Synchronization and Caching

- Implement cache invalidation using timestamps.
- Balance data freshness with performance.

## Ensuring Complete Project Overviews

- Include all relevant files in generated overviews.
- Update `generate-overview.sh` as the project evolves.
- Regularly review project-overview.txt for accuracy.

## Coding Standards

- Consistent indentation (2 spaces).
- camelCase for variables/functions, PascalCase for classes, UPPER_SNAKE_CASE for constants.
- Avoid globals; use modules.
- Follow Ember.js coding conventions where applicable.

## Naming Conventions

- Dasherized filenames (e.g., `photo-controller.js`).
- Descriptive and concise filenames.

## Directory Structure

- `backend/`: Express.js server and APIs
- `frontend/`: Ember.js app
- `data/`, `exports/`, `scripts/`, `utils/`, `tests/`
- Keep structure organized and consistent.

## Documentation Practices

- Update `README.md`, `DEVELOPMENT_PLAN.md`, `ISSUES.md`, `project-guidelines.md`.
- Use inline code comments and JSDoc.
- Maintain a changelog and consider `ARCHITECTURE.md` for big-picture decisions.
- Include “Questions to Consider” to highlight uncertainties.

## Privacy and Data Handling

- Do not store personal data in git.
- Be transparent about data processing.

## Project State and Continuity

- Self-contained documentation.
- Reflect current state, pending tasks, and future plans within the project files.

## Issue Tracking and Debugging

- Log issues in `ISSUES.md`.
- Document steps taken and current status.
- **Do Not Mark Issues as Resolved Until Verified**:  
  **No issue should be marked as "Resolved" until the fix is actually applied by the real person managing the system, and tested to confirm it works in reality.**
- Use "Uncertain" tags if needed to highlight unresolved aspects.
- Treat resolutions as provisional truths.

## Collaboration Guidelines

- Communicate clearly and concisely.
- Provide full file replacements for verifiable changes.
- Keep project composed of smaller files for easy copy-paste integration.
- Include clear commit messages.

## Environment and Dependency Management

- Use `.nvmrc` for Node.js versions.
- Keep dependencies updated and tested.
- Store config in environment variables.
- Adhere to JSON:API specs to ensure frontend-backend compatibility.

## Error Handling and Logging

- Implement robust error handling in async code.
- Provide meaningful error messages.
- Use logging for debugging and monitoring.

## Security Best Practices

- No sensitive info in version control.
- Validate/sanitize user inputs.
- Use environment variables for credentials.

## Testing

- Comprehensive test coverage: unit, integration, acceptance.
- Use Jest (backend) and Ember CLI testing tools (frontend).
- Mock external dependencies.
- Write tests alongside code changes.
- Keep tests reliable and maintainable.

## Deployment and Operations

- Document deployment processes.
- Use environment-specific configs.
- Monitor performance and errors in production.

## Performance Optimization

- Optimize large dataset handling.
- Use caching and lazy loading.
- Profile resource usage.
```

### **./README.md**
```
# Photo Filter Application Monorepo

## Overview

This monorepo contains both the Ember.js frontend and the Express.js backend of the Photo Filter Application. It enables browsing, filtering, and exporting photos from your macOS Photos library.

## Project Structure

- **backend/**: Express.js backend application.
- **frontend/**: Ember.js frontend application.
- **DEVELOPMENT_PLAN.md**: Roadmap and implementation details.
- **ISSUES.md**: Issues, debugging steps, and resolutions.
- **project-guidelines.md**: Collaboration and coding standards.

## Features

- **Album Navigation**: Browse albums via a left-side navigation column.
- **Photo Display**: View photos in selected albums with various sort options.
- **Faceted Person-Based Filtering**:  
  Under the currently active album, see a list of all recognized people.
  - **Single Person Filter**: Click one person’s name to display only photos with that individual.
  - **Multiple People Filter**: Select additional names to narrow photos down to those containing _all_ the chosen individuals, enabling powerful faceted search.
- **Sorting**: Sort photos by various attributes (e.g., aesthetic scores).
- **Photo Selection**: Select multiple photos; selections persist across sorting changes.
- **Export Functionality**: Export selected photos to a directory.

## Data Synchronization and Freshness

- The backend checks for changes in the Photos library.
- Cache invalidation ensures up-to-date album and photo data.

## Performance and Optimization

- JSON:API compliance for seamless Ember Data integration.
- Plans to implement lazy loading and indexing for improved performance.

## UI/UX

- Nested routes (`{{outlet}}`) for clarity.
- Future enhancements include more intuitive multi-person selection interfaces and better export feedback.

## Post-Photo-Filter Export Workflow: Preparing Photos for Video Editing

Once you have exported a directory of photos from the Photo Filter application, you may want to prepare them for video editing in Final Cut Pro X (FCPX) or another professional non-linear editor. The following steps outline how to normalize image orientation, generate a consistent file list, determine dimensions, and create a ProRes video file that preserves aspect ratios for all images.

**Prerequisites:**

- [ImageMagick](https://imagemagick.org/index.php)
- [FFmpeg](https://ffmpeg.org/) and its associated tools (e.g., \`ffprobe\`)
- A directory of \`.jpg\` images exported from the Photo Filter app

### 1. Ensure All Images Have the Correct Orientation

Use ImageMagick to apply rotation metadata directly to the pixel data. This ensures that downstream tools see the images correctly oriented:

\`\`\`bash
brew install imagemagick
mogrify -auto-orient \*.jpg
\`\`\`

### 2. Generate a File List for ffmpeg

First, list all \`.jpg\` images in the current directory:

\`\`\`bash
ls -1 \*.jpg > file_list.txt
\`\`\`

Then convert that listing into a format ffmpeg can parse:

\`\`\`bash
awk '{print "file \x27" $0 "\x27"}' file_list.txt > formatted_list.txt
\`\`\`

### 3. Determine the Dimensions of the First Image

Check the width and height of one of your images using ffprobe. Replace \`DSCF8482.jpg\` with an actual image filename from your directory:

\`\`\`bash
ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 DSCF8482.jpg
\`\`\`

Suppose this returns \`6240,4160\`. These will be your reference dimensions.

### 4. Convert Images to a Video with Preserved Aspect Ratios

Use ffmpeg to generate a ProRes \`.mov\` file. Scale and pad each image to fit the chosen dimensions (e.g., \`6240x4160\`) without distortion. Replace \`6240\` and \`4160\` with the values obtained above:

\`\`\`bash
ffmpeg -f concat -safe 0 -i formatted_list.txt \
-vf "scale='min(iw\*4160/ih,6240)':4160,setsar=1,pad=6240:4160:(6240-iw)/2:(4160-ih)/2" \
-framerate 16 -c:v prores -pix_fmt yuv422p output_preserved_aspect.mov
\`\`\`

**What This Does:**

- **Scale:** Adjusts each image so that it fits within the 6240x4160 frame, preserving its aspect ratio.
- **Pad:** Centers the scaled image by adding black bars if needed.
- **ProRes Encoding:** Outputs a high-quality \`.mov\` file suitable for editing in Final Cut Pro or other professional NLEs.
- **Framerate:** Sets the video to 16 frames per second, which you can adjust as desired.

### Additional Tips

- **Adjust the Frame Rate:**  
  Change \`-framerate 16\` to your desired frame rate (e.g., \`-framerate 24\`).

- **Change the Output Codec:**  
  Prefer a different codec (e.g., H.264 for smaller file sizes)? Replace \`-c:v prores -pix_fmt yuv422p\` with \`-c:v libx264 -crf 18\`.

- **Further Refinements:**  
  If you have specific creative requirements (e.g., adding transitions, stabilizing footage, or applying filters), you can incorporate those steps into your ffmpeg pipeline or perform them later in your video editing software.

## Installation and Setup

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/yourusername/photo-filter.git
   cd photo-filter

   2.	Backend Setup:
   ```

cd backend
npm install
npm run setup
npm run dev

    3.	Frontend Setup:

Open a new terminal window:

cd frontend/photo-filter-frontend
npm install
npm run start

    4.	Access the Application:

Visit http://localhost:4200.

Contributing
• Use clear and descriptive commit messages.
• Track issues in ISSUES.md.
• Follow guidelines in project-guidelines.md.

Testing
• Backend: Use Jest for tests (npm run test in backend/).
• Frontend: Use Ember CLI testing (npm run test in frontend/).

License

This project is licensed under the MIT License.

### 2025‑06‑16 — UTC filename upgrade

> **Breaking change:** After clearing `backend/data/albums`, all newly exported
> images will have a UTC timestamp prefix (see `docs/FILE‑NAMING.md`).
> Old caches can safely be deleted; no user‑visible paths changed.
```

### **./RELATIONAL-PRACTICES.md**
```
# RELATIONAL-PRACTICES.md

This document outlines the cultural and mindful norms for collaboration—among humans, AI systems, or any other stakeholders. It expands on our Compassion Software Principles and clarifies how disclaimers in [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md) are woven into daily operations.

---

## 1. Guiding Principles

1. **User Ownership of Memories**

   - Acknowledge that photos can be precious or vulnerable data.
   - If an update (e.g., to the filtering UI) might inadvertently surface sensitive imagery, we must carefully label the change and tie it to disclaimers.

2. **Shared Authorship**

   - All contributors—team members, open-source participants, advisors, AI assistants—co-create the code, docs, and user experience.
   - This means we also _share responsibility_ for ensuring disclaimers stay current and that the code remains mindful.

3. **Transparent Communication**

   - Propose new disclaimers or feature updates openly.
   - Use “emotional check” markers in issue threads to highlight potential triggers or emotional complexities.

4. **Mindful Interactions**
   - **AI Involvement**: Whenever AI helps generate code, note it in commit messages or comments. This fosters trust and traceability.
   - **Conflict Mediation**: If a design choice might be emotionally charged—like defaulting to AI-based face identification—take a short reflection period. Possibly label the pull request as “Mindful Review Requested.”

---

## 2. Recommended Practices

- **Code Reviews**

  - Evaluate PRs with an eye toward how disclaimers or mindful language might be updated.
  - Encourage short, gentle feedback rather than abrupt rejections.

- **Issue Discussions**

  - Mark potential sensitive tasks with `[Emotional Load]` or `[Trigger Warning]`.
  - If uncertain about user impact, reference [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md) or ask another contributor to do a relational check.

- **Documentation Updates**
  - Where possible, embed short disclaimers or notes directly in relevant doc sections.
  - Link to broader disclaimers in [MINDFUL-DISCLAIMERS.md](./MINDFUL-DISCLAIMERS.md) so readers can easily find more detail.

---

## 3. Integrations with `COMPASSION.md`

- **Emotional Mapping**: If we add or change how the user can label photos with emotional markers, we reflect that in the disclaimers and ensure contributors realize the potential sensitivity in triaging emotional data.
- **Self-Compassion Toolkit**: Encourage devs and testers to notice if they’re pushing themselves too hard. Use or adapt “Take a mindful pause” prompts in the code review template.

---

## 4. Practical Examples

### Example A: Submitting a PR That Adds a New Person-Recognition Feature

1. Update `MINDFUL-DISCLAIMERS.md` with a short note that recognition may reveal old or painful memories.
2. In your PR, mention potential emotional triggers from unexpectedly seeing certain faces.

### Example B: Changing Default Sort Behavior

1. If you default to “score.overall,” clarify that photos with high aesthetic scores might overshadow meaningful but less “perfect” pictures.
2. Consider how disclaimers in the UI can remind the user that aesthetic scoring is subjective and not a measure of personal value.

### Example C: Renaming an Album or Photo Key

1. If the name has cultural or personal significance, note the reason for renaming in your commit.
2. Flag it for mindful review if the rename might distress certain user groups.

---

## 5. Respectful Off-Ramps

- **When a Collaborator Needs a Break**

  - They can take a “mindful pause” from tasks, ensuring someone else can temporarily cover or postpone.
  - Avoid penalizing or stigmatizing these breaks; we assume best intentions and protect each other’s well-being.

- **User Data and Boundaries**
  - If a user decides to _not_ see certain content, we respect that choice.
  - In code or design discussions, never override user-set preferences for the sake of a “cool new feature” without a thorough relational check.

---

## 6. Encouraging a Broad Community Dialogue

- **Periodic Check-Ins**
  - Host short “town halls” or Slack threads for feedback on disclaimers or emotional features.
- **Educational Materials**
  - Provide short tutorials on “emotional filtering” or “mindful cinematic transitions” so new devs see how we combine technical and relational awareness.

---

## 7. Looking Ahead

1. **Multi-Language Disclaimers**:
   - As the user base diversifies, consider translations or culturally specific disclaimers.
2. **Audio-Visual Sensitivities**:
   - If the app starts offering audio or video, disclaimers should expand accordingly.
3. **Continuous Adaptation**:
   - Keep an open channel for refining disclaimers, especially if new emotional scenarios or expansions arise.

---

**Last Updated**: 2025-01-12
```

### **./TESTING_GUIDE.md**
```
# TESTING_GUIDE.md

## Purpose

This document serves as a comprehensive guide to writing tests for the Photo Filter Application, integrating the lessons we’ve learned during development and test automation. It covers **acceptance**, **unit**, and **integration** test approaches; strategies for handling uncertain data sets; and how to ensure that tests accurately reflect real-world user flows.

---

## Table of Contents

1. [Overview of Testing Approaches](#overview-of-testing-approaches)
2. [Acceptance Tests](#acceptance-tests)
   - [Query Params and Faceted Filtering](#query-params-and-faceted-filtering)
   - [Robustness with Large or Uncertain Data](#robustness-with-large-or-uncertain-data)
   - [UI Navigation and Edge Cases](#ui-navigation-and-edge-cases)
3. [Unit Tests](#unit-tests)
4. [Integration Tests](#integration-tests)
5. [Performance Considerations](#performance-considerations)
6. [Stubbing, Mocking, and Fixture Data](#stubbing-mocking-and-fixture-data)
7. [Guidelines and Best Practices](#guidelines-and-best-practices)
8. [Further Directions](#further-directions)

---

## 1. Overview of Testing Approaches

- **Acceptance Tests**: Verify end-to-end user stories, ensuring that a user can navigate the application, toggle features, and see expected outcomes.
- **Unit Tests**: Verify isolated functionality in models, helpers, or services without external dependencies.
- **Integration Tests**: Check interactions between components or modules in partial isolation, ensuring rendering or data flows work as intended in the Ember context.

Because this project has both a **frontend (Ember)** and a **backend (Express)**, we also rely on:

- **Backend Tests (e.g., Jest)**: For controllers, utilities, data exporting, or other Node/Express logic.
- **Full-Stack Validation**: Light acceptance tests that exercise real data to confirm the entire pipeline is stable (optional, depending on your CI environment).

---

## 2. Acceptance Tests

### Query Params and Faceted Filtering

1. **Multi-Person Selection**

   - **Why**: Ensures that toggling multiple individuals in an album updates the URL’s query parameters, filters the displayed photos accordingly, and persists state on refresh.
   - **How**:
     - Use `visit('/albums')` to load the album listing.
     - Click each album link in turn until you find one that actually has recognized people.
     - Toggle the first person, confirm the URL now contains `persons=...`.
     - Toggle additional persons and check the query string for multiple values.

2. **Sorting and Ordering**
   - **Why**: Guarantee that changing `sort` and `order` modifies the photo list accordingly.
   - **How**:
     - Programmatically select from a `<select>` menu or directly manipulate query params.
     - Confirm that the displayed items re-sort, and that the final URL includes correct query param values, e.g. `sort=score.overall&order=asc`.

### Robustness with Large or Uncertain Data

- **Don’t assume the first album has data**: A key takeaway was that your test logic can’t just pick “the first album” to test person toggles. Instead, loop through albums until you find one with recognized faces.
- **Fallback**: If you never find an album with persons, gracefully skip or assert “no persons found.” This ensures tests remain robust against real-world data that might be sparse or inconsistent.

### UI Navigation and Edge Cases

1. **Navigation**

   - Check that transitions are correct (e.g., after clicking an album link, you land on `/albums/:album_id`).
   - Confirm elements like the `.grid` or `.card` appear in the DOM to validate that photos are actually rendered.

2. **Edge Cases**
   - If some albums have zero photos or zero recognized persons, ensure your test doesn’t blow up.
   - If you rely on ephemeral data, consider whether to stub or mock for truly deterministic runs.

---

## 3. Unit Tests

- **Models** (e.g., `album-test.js`, `photo-test.js`): Confirm that each model can be created and that key relationships or computed properties work as intended.
- **Helpers**: Small, pure JavaScript transformations (e.g., `capitalize`, `replace`, `contains`) can be tested quickly.
- **Services**: Check that your “current-album” or “selection” services manage state as expected.

**Key Lessons**:

- Keep unit tests narrow in scope; they should fail only if their logic changes, not if external data or routes shift.

---

## 4. Integration Tests

- Typically used to test how Ember components (and their templates) interact with one another in partial isolation.
- Great for validating that a component properly renders a list of photos, or that toggling a local state affects CSS or child components.

**Considerations**:

- If your components heavily rely on the store or route data, weigh whether an acceptance test might be more suitable.
- For purely presentational logic (e.g., show/hide states), integration tests are ideal.

---

## 5. Performance Considerations

- **Large Albums**

  - Ember acceptance tests can cause timeouts or memory usage issues if you load thousands of photos.
  - Use pagination or a limit query param if necessary, or rely on specialized acceptance tests for smaller sample data.

- **Server-Side**
  - Jest tests for Express code should also consider performance. For instance, if you’re exporting thousands of images, ensure you only test the logic in a controlled scenario (or mock the file system calls).

---

## 6. Stubbing, Mocking, and Fixture Data

- **Why**: Real data can be unpredictable (some albums might have no recognized persons).
- **How**:
  - Use **fixtures** or **mocks** in acceptance tests for deterministic coverage when possible.
  - For example, Ember can intercept server requests with Pretender or Mirage (though this project hasn’t fully integrated them yet).
  - On the backend, you can temporarily mock `fs-extra` or `osxphotos` calls to test edge cases.

**Balance**: Keep some acceptance tests fully “live” with real data to confirm production usage, but rely on mocks or fixtures for consistent local coverage.

---

## 7. Guidelines and Best Practices

1. **Write Tests Alongside Features**

   - As soon as you add a new route or feature, create acceptance or integration tests.
   - Keep tests passing at each commit to maintain momentum.

2. **Small, Focused Assertions**

   - Each test should have a clear “Given, When, Then” structure. Avoid overloading a single test with too many steps.

3. **Don’t Overly Depend on Data Hard-Coded Indices**

   - Instead of “click the first album,” try to filter or search for an album with the property you need.
   - This approach is more robust if data changes in the future.

4. **Observe and Log**

   - Pepper your acceptance tests with small console logs or debug steps (like your “Found X album links…”). This helps diagnose data-based issues.

5. **Check the URL**

   - Ember’s query params are crucial for your filtering. Confirm the final `currentURL()` includes the expected param changes.

6. **Clean Up After**
   - If your test scripts alter data, ensure you restore or reset state (if relevant).
   - Typically, acceptance tests revert to default by reloading the page or using `visit()` again.

---

## 8. Further Directions

1. **Automated Mocking**

   - Tools like [Ember Mirage](https://github.com/miragejs/ember-cli-mirage) can generate a fake API for acceptance tests, ensuring consistent datasets.

2. **Advanced Performance Testing**

   - Investigate tests that specifically measure how the app handles large volumes of photos (time to render, memory usage).
   - Could be part of your CI pipeline with a special “stress test” mode.

3. **Visual Regression Testing**

   - For a photo-centric application, consider snapshot or visual-diff testing to catch unexpected UI changes.

4. **CI Integration**
   - Ensure all tests run in your GitHub Actions or other CI. If you have a large test suite, parallelize or selectively skip certain large-data tests by default.

---

## Conclusion

The overarching goal is to keep your tests realistic, robust to changes in data, and short enough to remain maintainable. By following these guidelines—writing acceptance tests that adapt to dynamic data, layering in unit tests for smaller logic, and employing integration tests for component interactions—you’ll maintain confidence in your system as it grows.

Feel free to add, modify, or refine these sections to match your team’s specific workflow. When in doubt, **test early** and **test often**.

---

**Last Updated**: 2025-01-12  
**Maintainer**: [Your Name or Team]

---

**How to Use**

1. Place this file in the root of your monorepo as `TESTING_GUIDE.md` (or adapt the file name as you wish).
2. Keep it updated whenever you refine test strategies or introduce new complexities.
3. Reference it in your pull requests or issue templates so everyone can stay aligned on test-writing best practices.

---

_End of `TESTING_GUIDE.md`_
```

### **./TIMELINE_TAXONOMY.md**
```
# TIMELINE_TAXONOMY.md

## Purpose

This document describes our upcoming feature for a time-based navigation tree in the Photo Filter Application. We aim to let the user drill into Years → Months → Weeks → Days, but **only** for nodes that actually contain photos. This dynamic approach ensures we don’t clutter the UI with empty categories.

## Scope of the Feature

1. **Comprehensive Metadata Export**

   - We will export all available date/time metadata for each photo.
   - This may require a one-time or periodic “full scan” of the Apple Photos library to create an internal database/table for efficient lookups.

2. **Hierarchical Time Tree**

   - **Years**: Display each year that has at least one photo.
   - **Months**: Nested under each year, only show months that have photos.
   - **Weeks**: Potentially optional, but we’re considering an ISO week definition (e.g., week #1 is the week with Jan 4).
   - **Days**: Nested under each month or week, only if photos exist.

3. **UI/UX Goals**

   - **Left Nav Tree**: The user sees a collapsible tree (like a folder structure).
   - **Multi-Select**: The user can shift-click or ctrl/cmd-click multiple time nodes (e.g., 2024 + “December 12, 2024”).
   - **Album-Like Grid**: All selected nodes are combined into a single photo feed on the right side, akin to how we handle multi-person filtering.

4. **Backend/Database Changes**

   - We’ll likely store a separate table or index keyed by date (year, month, day). Possibly more columns for week or combined date parts.
   - Queries need to handle multiple disjoint sets of date criteria (like multiple days across multiple months).

5. **Performance Considerations**

   - We might have 100k+ photos. Building the entire tree on the fly could be slow.
   - Precompute or incrementally update a time index so the UI can quickly load partial aggregates.

6. **Multi-Level Selection**

   - **Example**: The user clicks “2024” in the tree → sees 7,000 photos for 2024 in the main area.
   - Then they expand “December 2024,” see each day. They select “December 7” and “December 8,” which refines the main area to 250 photos from just those days.
   - They can also simultaneously keep “2024” selected to add all of 2024. Or they can uncheck “2024” if they only want the two days.

7. **Integration with Person / Location Filters**

   - This time-based approach will integrate with the existing query-param-based filtering. So the user can do `dates=2024-12-07,2024-12-08` plus `persons=Margaret,Douglas` plus `locations=Vienna,Cambridge`.
   - In Ember, we might handle multiple query params or a combined param. This is still open for discussion.

8. **Roadmap**
   1. Build out the data structure for a “time index” in the backend.
   2. Extend the existing Ember app to add a Time nav section (like we do for People).
   3. Implement multi-select checkboxes or toggles for each date node.
   4. Combine the logic so that the final photo grid merges all selected times with any selected people, location, or aesthetic filters.

## Example JSON Snippet

We might store or return data like:

```json
{
  "years": [
    {
      "year": 2022,
      "months": [
        {
          "month": 5,
          "days": [12, 13, 18]
        }
      ]
    },
    {
      "year": 2024,
      "months": [
        {
          "month": 12,
          "weeks": [49, 50],
          "days": [7, 8, 9, 15, 30]
        }
      ]
    }
  ]
}
```

Note: **Whether** we nest weeks inside months or keep them separate is still under consideration.

## Next Steps

- Update `DEVELOPMENT_PLAN.md` to reference this approach.
- Start building actual endpoints that return the “time index.”
- Add a left nav UI in Ember that can request and display this index, with multi-select capability.

---

_Last updated: 2025-01-12_
```

### **./TYPESCRIPT_GUIDE.md**
```
# TypeScript Integration Guide

Welcome to the Photo Filter Application’s TypeScript integration guide. This document explains how we are progressively introducing TypeScript into both our **backend** (Express.js) and **frontend** (Ember.js) projects, including linting, Prettier, and shared data interface practices.

---

## Table of Contents

1. **Motivation**
2. **Backend (Express) Setup**
   - Installing Dependencies
   - Creating `tsconfig.json`
   - Updating `package.json` Scripts
   - Renaming `.js` to `.ts`
3. **Frontend (Ember) Setup**
   - Installing Ember TypeScript
   - Creating or Modifying `tsconfig.json`
   - Typical File Renaming Strategy
4. **Shared Data Interfaces**
5. **Linting & Prettier**
6. **Phased Migration Strategy**
7. **References & Next Steps**

---

## 1. Motivation

- **Consistency**: Make the codebase approachable across backend and frontend.
- **Safety**: Catch type mismatches, especially around date values, route params, and Photos metadata.
- **Collaboration**: Provide a single source of truth for shared data interfaces.

We are doing a **phased** approach: not rewriting everything in TypeScript at once, but introducing `.ts` or `.d.ts` files as we modify or create new files.

---

## 2. Backend (Express) Setup

### 2.1 Installing Dependencies

At the **root** of your `backend/` folder, run:

```bash
cd backend
npm install --save-dev typescript @types/node @types/express
```

If you also want to type-assert your tests (e.g., Jest), add:

```bash
npm install --save-dev @types/jest
```

### 2.2 Creating `tsconfig.json`

In `backend/`, create a file called `tsconfig.json` (see example below).

### 2.3 Updating `package.json` Scripts

In the `backend/package.json`, add or update scripts like:

```jsonc
{
  "scripts": {
    // ...
    "build:ts": "tsc --build",
    "start:ts": "npm run build:ts && node dist/server.js"
  }
}
```

This way, you can compile your `.ts` files into a `dist/` folder, then run them.

### 2.4 Renaming `.js` to `.ts`

- Start small: pick a single file, e.g. `server.js`. Rename it to `server.ts` and fix the imports.
- Update your imports to use TypeScript/ES modules style if needed, e.g.:
  ```ts
  import express from "express";
  ```
- Over time, continue converting controllers or utility files from `.js` → `.ts`.

---

## 3. Frontend (Ember) Setup

### 3.1 Installing Ember TypeScript

Inside your Ember app folder (`frontend/photo-filter-frontend`), run:

```bash
cd frontend/photo-filter-frontend
ember install ember-cli-typescript
```

This will create or modify certain TypeScript configuration files (like `tsconfig.json`), add the TypeScript compiler, and wire up Ember to handle `.ts` files.

### 3.2 Creating or Modifying `tsconfig.json`

If `ember-cli-typescript` doesn’t create a `tsconfig.json`, you can add one. (We provide a sample below.) Typically, `ember-cli-typescript` does the heavy lifting. Just ensure it references your desired TypeScript settings.

### 3.3 Typical File Renaming Strategy

- Start by renaming one or two Ember files, e.g. a service or a component, from `.js` → `.ts`.
- Fix the import statements and specify the class property types. For example:

  ```ts
  import Service from "@ember/service";

  export default class CurrentAlbumService extends Service {
    isAlbumRoute = false;
    albumTitle: string | null = null;
    // ...
  }
  ```

- If you see errors about “Cannot find module ...”, try re-running `npm run start` or `npm run lint`. The Ember CLI often picks up the new `.ts` files automatically.

---

## 4. Shared Data Interfaces

We frequently pass data between the Node backend and the Ember frontend in JSON. For instance, we have `Photo` or `Album` objects. We want a single source of truth, so we can do either:

1. **A Shared Folder** (e.g. `shared-types/` at the top-level) with `.d.ts` or `.ts` files that define `interface PhotoData { ... }`.
2. Then import them into `backend/` for Node usage, and also reference them in Ember.

**Example**:

```ts
// shared-types/PhotoData.ts
export interface PhotoData {
  uuid: string;
  originalFilename: string;
  date: string; // or Date if we handle parsing
  persons?: string[];
  // ...
}
```

**In backend**:

```ts
import { PhotoData } from "../../shared-types/PhotoData";

function processPhoto(photo: PhotoData) {
  // ...
}
```

**In Ember**:

```ts
import PhotoData from "photo-filter-frontend/shared-types/PhotoData";

// Then use PhotoData in a typed model or utility
```

This ensures the same shape is recognized across the stack.

---

## 5. Linting & Prettier

We already use ESLint + Prettier. Add or verify in `.eslintrc.js` that TypeScript is recognized:

```js
// Example snippet
module.exports = {
  parser: "@typescript-eslint/parser",
  extends: [
    "eslint:recommended",
    "plugin:ember/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended",
  ],
  // ...
};
```

**Prettier**: Make sure your `.prettierrc.js` also covers `.ts`:

```js
module.exports = {
  overrides: [
    {
      files: "*.{ts,js,json}",
      options: {
        singleQuote: true,
        // ...
      },
    },
  ],
};
```

---

## 6. Phased Migration Strategy

1. **Backend**: Convert `server.js` → `server.ts`, then your controllers, then your utilities.
2. **Frontend**: After `ember-cli-typescript` is installed, rename a small but crucial file (like a service or a component).
3. **Shared Types**: Start with a minimal `PhotoData` or `AlbumData` interface. Evolve it as you unify the codebase.

We encourage the approach: **“Convert as you touch.”** Each time you need to fix a bug in a file, rename it to `.ts` or add types. Over time, your coverage increases organically.

---

## 7. References & Next Steps

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [ember-cli-typescript Docs](https://emberjs.github.io/ember-cli-typescript/)
- [@typescript-eslint](https://typescript-eslint.io/) for linting
- **WIP**: We may eventually compile a single “combined” type definitions library used by the Python layer too, ensuring Apple Photos metadata is typed end-to-end.

_That’s it!_ If you have any issues or want clarifications, see the [ISSUES.md](./ISSUES.md) file or open a new discussion with your questions.
```

## Backend Files

### **./backend/.babelrc**
```
{
  "presets": ["@babel/preset-env"]
}
```

### **./backend/.babelrc**
```
### **./backend/test_albums.json**
```
{
  "presets": ["@babel/preset-env"]
}
```

{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle 🎞️ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour — People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie ◍ Jamie": 4976, "Dominic ◍ Jamie": 4415, "Rosa Menkman ◍ Jamie Burkart": 2821, "Transfer ◍ Jamie Burkart": 2821, "Sondy ◍ Jamie": 2542, "Chad ◍ Jamie": 1830, "Lera Tarasenko ◍ Jamie Burkart": 1636, "Mir ◍ 196 Artists Residency": 1156, "Carper ◍ Burkart": 717, "Lydia ◍ Jamie": 380, "Jessi ◍ Mike ◍ Jamie": 347, "Jack ◍ Jamie": 332, "Lera Show ◍ Jamie Burkart": 310, "Patrick Weaver ◍ Jamie Burkart": 162, "Hayley ◍ Jamie": 149, "Claudette ◍ Jamie": 143, "Greta ◍ Shan ◍ Jamie": 137, "Zhen Li ◍ Jamie Burkart": 83, "Bobby ◍ Madeleine ◍ Jamie": 60, "Abby ◍ Jamie": 57, "Isabel Santos ◍ Jamie Burkart": 50, "Laura Mattingly ◍ Jamie Burkart": 45, "Thor ◍ Jamie": 35, "Stewart ◍ Jamie": 29, "Jessi ◍ Jamie Fashion Concepts &;-)": 26, "Gabi ◍ Michael ◍ Jamie": 17, "Melody ◍ Jamie": 13, "Michael ◍ Jamie": 9, "Em Gift ◍ Jamie Burkart": 1, "Bridget ◍ Jamie": 0}}
```

### **./backend/server.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
### **./backend/test_albums.json**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };{"albums": {"FujiFilm x100v: All, Full Res": 59919, "FUJIFILM X100V": 39610, "iMessage": 6346, "Sold the building": 4902, "Charlie": 3959, "Flickr: Fredenburg": 3442, "Flickr": 2947, "Transfer": 2821, "Film: Luster Photo": 2590, "At or Near the Building": 1274, "Jamie": 1149, "Halloween 2024": 1084, "Instagram": 858, "Kc": 773, "Penny Party P4": 683, "Dawn Riddle 🎞️ On a Roll": 581, "Snow Day": 542, "KCTH Building Tour": 512, "Harold Mason": 491, "Fun day all": 360, "Rosa Transfer": 350, "Olympia": 344, "Lera Show": 309, "WhatsApp": 289, "Saved from Flickr": 244, "Mason Deed": 221, "Beacon 9-2024": 194, "APNG": 188, "Make New Pictures": 163, "Netherlands": 126, "September MacOS Screenshots": 120, "Building problems": 113, "KCTH Building Tour — People": 86, "Birthday": 67, "Berlin": 55, "Dream City": 50, "Jamie Shirt": 50, "Divorced": 48, "GIF": 47, "Jamie Hair": 45, "Mia-Ben-Arrival": 44, "Moving": 43, "Jamie CC": 41, "Paris Downstairs": 40, "Passport": 40, "Animated": 36, "Mir Faves": 35, "New Year's Day": 33, "2012-12-15": 32, "Espinal": 31, "Ali Coleman": 31, "Olympia house": 30, "FLIR ONE": 30, "Philadelphia": 30, "Christmas 2022": 26, "Glitch Sotheby's": 26, "Good times": 21, "Washer Drier": 20, "Film: Walgreens": 20, "Olympia's Birthday": 20, "Beacon": 19, "Utility": 18, "438": 18, "2024-04-03": 17, "Mom": 17, "Gordon Matta Clarke": 17, "Skate": 16, "Claudette AR": 16, "Jb kc building": 16, "Collaborative": 16, "Rachel Walther": 16, "SceneViewer": 16, "Tyler": 15, "Misha": 14, "Bridget Basket Beacon": 13, "2022-canoe-mo-shared": 13, "Kc work": 12, "Flip books": 12, "Mir": 12, "Pompa": 12, "2022-canoe-Mo": 12, "Lighting Refresh": 11, "Moving Pictures": 10, "Notes": 10, "Bobby Anspach": 10, "Sheep": 9, "Earl Mason Jonathan": 9, "By Dawn Riddle": 9, "Tire Extraction": 8, "Twitter": 8, "2022-11-22-red": 8, "Dominic": 8, "Bookshelves": 8, "Emily Sphere": 7, "Stairs": 7, "Flowers": 7, "Drive": 7, "Inner Space": 6, "LoVid": 6, "Canoe Car": 6, "Close friends": 6, "Camilla Carper": 6, "Stefania": 6, "Looms": 6, "Penelope": 5, "Elisa": 5, "Manhattan": 5, "Olympia Resume": 5, "Giphy": 5, "Dwelling makes home": 5, "Steam": 4, "My world": 4, "Babe": 4, "St Marks": 4, "Potluck": 4, "3D Photo": 4, "Carmen": 3, "Kendel & Mandi": 3, "NYC people": 3, "Hudson": 3, "Jmr": 3, "Flan": 3, "Camera": 3, "Shared with Mason & Earl": 3, "Mia Ben": 3, "To see": 2, "Jb": 2, "Charlie - We Might See": 2, "Zoom Backgrounds": 2, "Rosa": 2, "Paris": 2, "Mason": 2, "Luis": 2, "C&O Canal": 2, "Big Fun Day": 2, "Graphics": 2, "Dana": 2, "Dump": 2, "Mental Health": 2, "Old camera": 2, "Burkarts": 2, "Lisbeth": 2, "Zach": 2, "Airbnb": 2, "Fotor": 2, "Trent": 2, "Books": 1, "Really free": 1, "Tara": 1, "Catalina": 1, "196": 1, "Thor": 1, "Dominic and Antoine": 1, "Untitled Album": 1, "Documentation": 1, "KCTH": 1, "Dropbox": 1, "Kc town hall": 1, "Recently Viewed": 1, "Water Park": 0}, "shared albums": {"Charlie ◍ Jamie": 4976, "Dominic ◍ Jamie": 4415, "Rosa Menkman ◍ Jamie Burkart": 2821, "Transfer ◍ Jamie Burkart": 2821, "Sondy ◍ Jamie": 2542, "Chad ◍ Jamie": 1830, "Lera Tarasenko ◍ Jamie Burkart": 1636, "Mir ◍ 196 Artists Residency": 1156, "Carper ◍ Burkart": 717, "Lydia ◍ Jamie": 380, "Jessi ◍ Mike ◍ Jamie": 347, "Jack ◍ Jamie": 332, "Lera Show ◍ Jamie Burkart": 310, "Patrick Weaver ◍ Jamie Burkart": 162, "Hayley ◍ Jamie": 149, "Claudette ◍ Jamie": 143, "Greta ◍ Shan ◍ Jamie": 137, "Zhen Li ◍ Jamie Burkart": 83, "Bobby ◍ Madeleine ◍ Jamie": 60, "Abby ◍ Jamie": 57, "Isabel Santos ◍ Jamie Burkart": 50, "Laura Mattingly ◍ Jamie Burkart": 45, "Thor ◍ Jamie": 35, "Stewart ◍ Jamie": 29, "Jessi ◍ Jamie Fashion Concepts &;-)": 26, "Gabi ◍ Michael ◍ Jamie": 17, "Melody ◍ Jamie": 13, "Michael ◍ Jamie": 9, "Em Gift ◍ Jamie Burkart": 1, "Bridget ◍ Jamie": 0}}
```

### **./backend/tests/utils/precise-timestamp.test.js**
```
```

### **./backend/server.js**
```
import { utcTimestampForFile } from "../../backend/utils/precise-timestamp.js";
import { exiftool } from "exiftool-vendored";

// Mock exiftool.read so we don’t hit the binary during CI
jest.mock("exiftool-vendored", () => {
  return {
    exiftool: {
      read: jest.fn(),
    },
  };
});

describe("utcTimestampForFile", () => {
  it("handles OffsetTimeOriginal with sub‑seconds", async () => {
    exiftool.read.mockResolvedValue({
      DateTimeOriginal: "2025:05:31 13:45:41",
      SubSecTimeOriginal: "540000",
      OffsetTimeOriginal: "-06:00",
    });

    const ts = await utcTimestampForFile("/dummy.jpg");
    expect(ts).toBe("20250531T194541540000Z"); // 13:45‑06 → 19:45Z
  });

  it("falls back to CreateDate & local zone when no offset", async () => {
    // pretend local tz is UTC‑4
    process.env.TZ = "America/New_York";

    exiftool.read.mockResolvedValue({
      CreateDate: "2025:01:02 03:04:05",
      SubSecTime: "1",
    });

    const ts = await utcTimestampForFile("/dummy.jpg");
    expect(ts.startsWith("20250102T070405")).toBe(true); // 03:04 EDT + 4 h
    expect(ts.endsWith("000001Z")).toBe(true);
  });
});
```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// backend/server.js

import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import exphbs from "express-handlebars";
import routes from "./routes/index.js";
import fs from "fs-extra";
import cors from "cors"; // Import cors

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable CORS for all routes
app.use(cors());

// Set up Handlebars with custom helpers
const hbs = exphbs.create({
  extname: ".hbs",
  helpers: {
    eq: (a, b) => a === b,
    getNestedProperty: (obj, propertyPath) => {
      if (!propertyPath || typeof propertyPath !== "string") {
        return null;
      }
      return propertyPath
        .split(".")
        .reduce(
          (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
          obj
        );
    },
    capitalize: (str) => {
      if (typeof str !== "string") return "";
      return str
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ");
    },
    concat: (...args) => {
      args.pop(); // Remove Handlebars options object
      return args.join("");
    },
    replace: (str, find, replace) => {
      return str.replace(find, replace);
    },
  },
});

app.engine(".hbs", hbs.engine);
app.set("view engine", ".hbs");
app.set("views", path.join(__dirname, "views"));

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// Dynamic image serving middleware
app.use("/images/:albumUUID/:imageName", async (req, res) => {
  const { albumUUID, imageName } = req.params;
  const imagesDir = path.join(__dirname, "data", "albums", albumUUID, "images");

  try {
    const imagePath = path.join(imagesDir, imageName);
    if (await fs.pathExists(imagePath)) {
      res.sendFile(imagePath);
    } else {
      res.status(404).send("Image not found");
    }
  } catch (error) {
    console.error("Error serving image:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Use routes
app.use("/", routes);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### **./backend/jest.config.js**
```
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/jest.config.js

export default {
    testEnvironment: 'node',
    transform: {},
    extensionsToTreatAsEsm: ['.js'],
  };```

### **./backend/tests/utils/precise-timestamp.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
import { utcTimestampForFile } from "../../backend/utils/precise-timestamp.js";
import { exiftool } from "exiftool-vendored";

// Mock exiftool.read so we don’t hit the binary during CI
jest.mock("exiftool-vendored", () => {
  return {
    exiftool: {
      read: jest.fn(),
    },
  };
});

describe("utcTimestampForFile", () => {
  it("handles OffsetTimeOriginal with sub‑seconds", async () => {
    exiftool.read.mockResolvedValue({
      DateTimeOriginal: "2025:05:31 13:45:41",
      SubSecTimeOriginal: "540000",
      OffsetTimeOriginal: "-06:00",
    });

    const ts = await utcTimestampForFile("/dummy.jpg");
    expect(ts).toBe("20250531T194541540000Z"); // 13:45‑06 → 19:45Z
  });

  it("falls back to CreateDate & local zone when no offset", async () => {
    // pretend local tz is UTC‑4
    process.env.TZ = "America/New_York";

    exiftool.read.mockResolvedValue({
      CreateDate: "2025:01:02 03:04:05",
      SubSecTime: "1",
    });

    const ts = await utcTimestampForFile("/dummy.jpg");
    expect(ts.startsWith("20250102T070405")).toBe(true); // 03:04 EDT + 4 h
    expect(ts.endsWith("000001Z")).toBe(true);
  });
});
```

### **./backend/utils/run-python-script.js**
```
```

### **./backend/tests/controllers/api/photos-controller.test.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
// backend/tests/controllers/api/photos-controller.test.js

import { jest } from "@jest/globals";
import { getPhotosByAlbumData } from "../../../controllers/api/photos-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getPhotosByAlbumData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return photos data in JSON:API format", async () => {
    const req = httpMocks.createRequest({
      params: {
        albumUUID: "album-1",
      },
      query: {
        sort: "score.overall",
        order: "desc",
      },
    });
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const samplePhotos = [
      {
        uuid: "photo-1",
        original_filename: "photo1.jpg",
        score: { overall: 0.9 },
      },
      {
        uuid: "photo-2",
        original_filename: "photo2.jpg",
        score: { overall: 0.8 },
      },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(samplePhotos);
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getPhotosByAlbumData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "photo");
    expect(data.data[0]).toHaveProperty("id", "photo-1");
    expect(data.data[0].attributes).toHaveProperty("originalName", "photo1");
    expect(data.data[0].attributes.score).toHaveProperty("overall", 0.9);
  });
});
```

### **./backend/utils/exec-command.js**
```
```

### **./backend/tests/controllers/api/albums-controller.test.js**
```
// backend/tests/controllers/api/albums-controller.test.js

import { jest } from "@jest/globals";
import { getAlbumsData } from "../../../controllers/api/albums-controller.js";
import httpMocks from "node-mocks-http";
import fs from "fs-extra";
import path from "path";

describe("getAlbumsData", () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("should return albums data in JSON:API format", async () => {
    // Mock request and response
    const req = httpMocks.createRequest();
    const res = httpMocks.createResponse();

    // Mock fs.readJson to return sample data
    const sampleData = [
      { uuid: "album-1", title: "Album 1" },
      { uuid: "album-2", title: "Album 2" },
    ];

    jest.spyOn(fs, "readJson").mockResolvedValue(sampleData);

    // Mock fs.pathExists to return true
    jest.spyOn(fs, "pathExists").mockResolvedValue(true);

    await getAlbumsData(req, res);

    const data = res._getJSONData();

    expect(res.statusCode).toBe(200);
    expect(data.data).toBeDefined();
    expect(data.data.length).toBe(2);
    expect(data.data[0]).toHaveProperty("type", "album");
    expect(data.data[0]).toHaveProperty("id", "album-1");
    expect(data.data[0].attributes).toHaveProperty("title", "Album 1");
  });
});
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```

### **./backend/utils/run-python-script.js**
```
```

### **./backend/utils/get-photos-library-last-modified.js**
```
// ./utils/run-python-script.js

import { exec } from "child_process";
import fs from "fs-extra";

export async function runPythonScript(
  pythonPath,
  scriptPath,
  args = [],
  outputPath
) {
  const command = `"${pythonPath}" "${scriptPath}" ${args.join(" ")}`;
  console.log(`Executing command:\n${command}`);

  return new Promise((resolve, reject) => {
    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      async (error, stdout, stderr) => {
        if (error) {
          console.error(
            `Error executing Python script ${scriptPath}:\n${stderr}`
          );
          reject(error);
          return;
        }
        // Write stdout to the outputPath
        try {
          await fs.writeFile(outputPath, stdout, "utf-8");
          console.log(`Output written to ${outputPath}`);
          resolve();
        } catch (writeError) {
          console.error(
            `Error writing output to ${outputPath}:\n${writeError}`
          );
          reject(writeError);
        }
      }
    );
  });
}
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```

### **./backend/utils/exec-command.js**
```
```

### **./backend/utils/precise-timestamp.js**
```
/**
 * precise‑timestamp.js
 * --------------------
 * Two related utilities that build micro‑second‑precise **UTC** stamps
 * used as filename prefixes.
 *
 *   • formatPreciseTimestamp(dateLike)
 *       └─ Robustly parses several Photos‑style date strings.
 *
 *   • utcTimestampForFile(filePath)
 *       └─ Reads EXIF (with exiftool‑vendored) and delegates to Luxon.
 *
 * Both return the canonical 27‑character form:
 *        YYYYMMDDTHHMMSSffffffZ
 * Example:
 *        20250531T174503000123Z
 */

import { exiftool } from "exiftool-vendored";
import { DateTime } from "luxon";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Convert a Date or one of Photos’ date string variants into our canonical
 * UTC stamp.  Accepts:
 *
 *   • ISO‑8601  →  2025‑05‑31T13:45:41‑06:00
 *   • SQL       →  2025‑05‑31 13:45:41‑06:00   (space instead of “T”)
 *   • EXIF      →  2025:05:31 13:45:41         (colon‑separated date, no TZ)
 *
 * @param {string|Date} dateLike
 * @returns {string} e.g. "20250531T174503123000Z"
 */
export function formatPreciseTimestamp(dateLike) {
  let dt;

  // 1. Already a Date object ------------------------------------------------
  if (dateLike instanceof Date) {
    dt = DateTime.fromJSDate(dateLike, { zone: "utc" });
  } else if (typeof dateLike === "string") {
    // 2. ISO 8601 -----------------------------------------------------------
    dt = DateTime.fromISO(dateLike, { setZone: true });

    // 3. SQL format  (Photos DB default)  -----------------------------------
    if (!dt.isValid) {
      dt = DateTime.fromSQL(dateLike, { setZone: true });
    }

    // 4. EXIF “YYYY:MM:DD HH:MM:SS”  ----------------------------------------
    if (!dt.isValid) {
      dt = DateTime.fromFormat(
        dateLike,
        "yyyy:MM:dd HH:mm:ss",
        { zone: "local" } // assume local if no offset supplied
      );
    }

    // 5. As a last resort let JS Date try -----------------------------------
    if (!dt.isValid) {
      const jsDate = new Date(dateLike);
      if (!isNaN(jsDate.getTime())) {
        dt = DateTime.fromJSDate(jsDate, { zone: "utc" });
      }
    }

    // (if still invalid we fall through and raise)
  } else {
    throw new TypeError(
      `formatPreciseTimestamp(): expected Date or string, got ${typeof dateLike}`
    );
  }

  if (!dt.isValid) {
    throw new Error(
      `formatPreciseTimestamp(): invalid input (“${dateLike}” – ${dt.invalidReason})`
    );
  }

  // Luxon gives millisecond precision; multiply to micro‑seconds.
  const micro = String(dt.millisecond * 1_000).padStart(6, "0");

  return dt.toUTC().toFormat("yyyyLLdd'T'HHmmss") + micro + "Z";
}

// ---------------------------------------------------------------------------
// utcTimestampForFile()  – unchanged
// ---------------------------------------------------------------------------

/**
 * Read EXIF and build the canonical UTC timestamp.
 *
 * @param {string} filePath – absolute image path
 * @returns {Promise<string>}
 */
export async function utcTimestampForFile(filePath) {
  const tags = await exiftool.read(filePath);

  const base =
    tags.DateTimeOriginal || tags.CreateDate || tags.ModifyDate || null;
  if (!base) {
    throw new Error(`No date field in EXIF for ${filePath}`);
  }

  // Sub‑seconds → six digits
  const subsec = (
    (tags.SubSecTimeOriginal || tags.SubSecTime || "0").toString() + "000000"
  ).slice(0, 6);

  const offset = tags.OffsetTimeOriginal || tags.OffsetTime || null;

  const dtLocal = DateTime.fromFormat(base, "yyyy:MM:dd HH:mm:ss", {
    zone: offset ?? "local",
  }).plus({ microseconds: Number(subsec) });

  if (!dtLocal.isValid) {
    throw new Error(
      `Invalid date in EXIF for ${filePath}: ${dtLocal.invalidExplanation}`
    );
  }

  return dtLocal.toUTC().toFormat("yyyyLLdd'T'HHmmss") + subsec + "Z";
}
// ./utils/exec-command.js

import { exec } from "child_process";

// Helper function to execute shell commands
export function execCommand(command, errorMessage) {
  return new Promise((resolve, reject) => {
    console.log(`Executing command:\n${command}`);

    exec(
      command,
      { env: process.env, maxBuffer: 1024 * 1024 * 1024 * 2 },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`${errorMessage}\nError: ${error.message}`);
          if (stderr) {
            console.error(`stderr:\n${stderr}`);
          }
          reject(error);
          return;
        }
        if (stdout) {
          console.log(`stdout:\n${stdout}`);
        }
        if (stderr) {
          console.error(`stderr:\n${stderr}`);
        }
        resolve({ stdout, stderr });
      }
    );
  });
}
```
```


### **./backend/utils/get-photos-library-last-modified.js**
### **./backend/utils/helpers.js**
```
```
// backend/utils/helpers.js
//
// Shared one-liners.  We re-export `formatPreciseTimestamp` so callers
// can keep a single import path for most utilities.

import { formatPreciseTimestamp } from "./precise-timestamp.js";

export { formatPreciseTimestamp };

export function getNestedProperty(obj, propertyPath) {
  if (!propertyPath || typeof propertyPath !== "string") return null;
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

export function capitalizeAttributeName(attributeName) {
  const bits = attributeName.split(".");
  const last = bits[bits.length - 1];
  return last
    .split("_")
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

// …other re‑exports remain
export { utcTimestampForFile } from "./precise-timestamp.js";
// export { renameWithUtcPrefix } from "./export-images.js";
// ./utils/get-photos-library-last-modified.js

import fs from "fs-extra";
import path from "path";
import os from "os";

export async function getPhotosLibraryLastModified() {
  const photosLibraryPath = path.join(
    os.homedir(),
    "Pictures",
    "Photos Library.photoslibrary"
  );

  const stats = await fs.stat(photosLibraryPath);
  return stats.mtime;
}
```
```


### **./backend/utils/precise-timestamp.js**
### **./backend/utils/export-images.js**
```
```
/**
 * precise‑timestamp.js
 * --------------------
 * Two related utilities that build micro‑second‑precise **UTC** stamps
 * used as filename prefixes.
 *
 *   • formatPreciseTimestamp(dateLike)
 *       └─ Robustly parses several Photos‑style date strings.
 *
 *   • utcTimestampForFile(filePath)
 *       └─ Reads EXIF (with exiftool‑vendored) and delegates to Luxon.
 *
 * Both return the canonical 27‑character form:
 *        YYYYMMDDTHHMMSSffffffZ
 * Example:
 *        20250531T174503000123Z
 */

import { exiftool } from "exiftool-vendored";
import { DateTime } from "luxon";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Convert a Date or one of Photos’ date string variants into our canonical
 * UTC stamp.  Accepts:
 *
 *   • ISO‑8601  →  2025‑05‑31T13:45:41‑06:00
 *   • SQL       →  2025‑05‑31 13:45:41‑06:00   (space instead of “T”)
 *   • EXIF      →  2025:05:31 13:45:41         (colon‑separated date, no TZ)
 *
 * @param {string|Date} dateLike
 * @returns {string} e.g. "20250531T174503123000Z"
 */
export function formatPreciseTimestamp(dateLike) {
  let dt;

  // 1. Already a Date object ------------------------------------------------
  if (dateLike instanceof Date) {
    dt = DateTime.fromJSDate(dateLike, { zone: "utc" });
  } else if (typeof dateLike === "string") {
    // 2. ISO 8601 -----------------------------------------------------------
    dt = DateTime.fromISO(dateLike, { setZone: true });

    // 3. SQL format  (Photos DB default)  -----------------------------------
    if (!dt.isValid) {
      dt = DateTime.fromSQL(dateLike, { setZone: true });
    }

    // 4. EXIF “YYYY:MM:DD HH:MM:SS”  ----------------------------------------
    if (!dt.isValid) {
      dt = DateTime.fromFormat(
        dateLike,
        "yyyy:MM:dd HH:mm:ss",
        { zone: "local" } // assume local if no offset supplied
      );
    }

    // 5. As a last resort let JS Date try -----------------------------------
    if (!dt.isValid) {
      const jsDate = new Date(dateLike);
      if (!isNaN(jsDate.getTime())) {
        dt = DateTime.fromJSDate(jsDate, { zone: "utc" });
      }
    }

    // (if still invalid we fall through and raise)
  } else {
    throw new TypeError(
      `formatPreciseTimestamp(): expected Date or string, got ${typeof dateLike}`
    );
  }

  if (!dt.isValid) {
    throw new Error(
      `formatPreciseTimestamp(): invalid input (“${dateLike}” – ${dt.invalidReason})`
    );
  }

  // Luxon gives millisecond precision; multiply to micro‑seconds.
  const micro = String(dt.millisecond * 1_000).padStart(6, "0");

  return dt.toUTC().toFormat("yyyyLLdd'T'HHmmss") + micro + "Z";
}

// ---------------------------------------------------------------------------
// utcTimestampForFile()  – unchanged
// ---------------------------------------------------------------------------

/**
 * Read EXIF and build the canonical UTC timestamp.
 *
 * @param {string} filePath – absolute image path
 * @returns {Promise<string>}
 */
export async function utcTimestampForFile(filePath) {
  const tags = await exiftool.read(filePath);

  const base =
    tags.DateTimeOriginal || tags.CreateDate || tags.ModifyDate || null;
  if (!base) {
    throw new Error(`No date field in EXIF for ${filePath}`);
  }

  // Sub‑seconds → six digits
  const subsec = (
    (tags.SubSecTimeOriginal || tags.SubSecTime || "0").toString() + "000000"
  ).slice(0, 6);

  const offset = tags.OffsetTimeOriginal || tags.OffsetTime || null;

  const dtLocal = DateTime.fromFormat(base, "yyyy:MM:dd HH:mm:ss", {
    zone: offset ?? "local",
  }).plus({ microseconds: Number(subsec) });

  if (!dtLocal.isValid) {
    throw new Error(
      `Invalid date in EXIF for ${filePath}: ${dtLocal.invalidExplanation}`
    );
  }

  return dtLocal.toUTC().toFormat("yyyyLLdd'T'HHmmss") + subsec + "Z";
}
// backend/utils/export-images.js
//
// Export JPEGs from an album with **UTC‑based, micro‑second‑precise** names:
//
//     20250531T174503000123Z‑DSCF7309.jpg
//
// ‑ UTC eliminates cross‑camera drift
// ‑ Micro‑seconds guarantee uniqueness
// ‑ The prefix sorts lexicographically == chronologically
//
// Requires Jamie’s fork of osxphotos (branch
// `codex/implement-utc-and-local-postfix-for-template-datetime`), which adds
// the “.utc” secondary field to every datetime template variable:
//        {created.utc.strftime,%Y%m%dT%H%M%S%fZ}

import fs from "fs-extra";
import path from "path";
import { execCommand } from "./exec-command.js";

/**
 * Export JPEGs for the given album.
 *
 * @param {string} osxphotosPath absolute path to the `osxphotos` binary
 * @param {string} albumUUID     Photos album UUID
 * @param {string} imagesDir     destination directory
 * @param {string} photosPath    path to the album’s photos.json
 */
export async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // ------------------------------------------------------------------
  // 1 · Write the list of UUIDs that belong to this album
  // ------------------------------------------------------------------
  const photos = await fs.readJson(photosPath);
  const uuidsFile = path.join(imagesDir, "uuids.txt");

  await fs.ensureDir(imagesDir);
  await fs.writeFile(uuidsFile, photos.map((p) => p.uuid).join("\n"), "utf8");

  // ------------------------------------------------------------------
  // 2 · Export the actual images
  // ------------------------------------------------------------------
  const filenameTemplate =
    "{created.utc.strftime,%Y%m%dT%H%M%S%fZ}-{original_name}";

  const cmd = `"${osxphotosPath}" export "${imagesDir}" \
--uuid-from-file "${uuidsFile}" \
--filename "${filenameTemplate}" \
--convert-to-jpeg --jpeg-ext jpg`;

  await execCommand(cmd, "osxphotos image export failed:");
}
```

### **./backend/utils/helpers.js**
```
```

### **./backend/models/photoModel.js**
```
// backend/utils/helpers.js
//
// Shared one-liners.  We re-export `formatPreciseTimestamp` so callers
// can keep a single import path for most utilities.

import { formatPreciseTimestamp } from "./precise-timestamp.js";

export { formatPreciseTimestamp };

export function getNestedProperty(obj, propertyPath) {
  if (!propertyPath || typeof propertyPath !== "string") return null;
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}

export function capitalizeAttributeName(attributeName) {
  const bits = attributeName.split(".");
  const last = bits[bits.length - 1];
  return last
    .split("_")
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(" ");
}

// …other re‑exports remain
export { utcTimestampForFile } from "./precise-timestamp.js";
// export { renameWithUtcPrefix } from "./export-images.js";
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/utils/export-images.js**
```
```

### **./backend/public/stylesheets/scss/style.scss**
```
// backend/utils/export-images.js
//
// Export JPEGs from an album with **UTC‑based, micro‑second‑precise** names:
//
//     20250531T174503000123Z‑DSCF7309.jpg
//
// ‑ UTC eliminates cross‑camera drift
// ‑ Micro‑seconds guarantee uniqueness
// ‑ The prefix sorts lexicographically == chronologically
//
// Requires Jamie’s fork of osxphotos (branch
// `codex/implement-utc-and-local-postfix-for-template-datetime`), which adds
// the “.utc” secondary field to every datetime template variable:
//        {created.utc.strftime,%Y%m%dT%H%M%S%fZ}

import fs from "fs-extra";
import path from "path";
import { execCommand } from "./exec-command.js";

/**
 * Export JPEGs for the given album.
 *
 * @param {string} osxphotosPath absolute path to the `osxphotos` binary
 * @param {string} albumUUID     Photos album UUID
 * @param {string} imagesDir     destination directory
 * @param {string} photosPath    path to the album’s photos.json
 */
export async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // ------------------------------------------------------------------
  // 1 · Write the list of UUIDs that belong to this album
  // ------------------------------------------------------------------
  const photos = await fs.readJson(photosPath);
  const uuidsFile = path.join(imagesDir, "uuids.txt");

  await fs.ensureDir(imagesDir);
  await fs.writeFile(uuidsFile, photos.map((p) => p.uuid).join("\n"), "utf8");

  // ------------------------------------------------------------------
  // 2 · Export the actual images
  // ------------------------------------------------------------------
  const filenameTemplate =
    "{created.utc.strftime,%Y%m%dT%H%M%S%fZ}-{original_name}";

  const cmd = `"${osxphotosPath}" export "${imagesDir}" \
--uuid-from-file "${uuidsFile}" \
--filename "${filenameTemplate}" \
--convert-to-jpeg --jpeg-ext jpg`;

  await execCommand(cmd, "osxphotos image export failed:");
}
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

```
### **./backend/models/photoModel.js**

```
// ./models/photoModel.js

// Represents the semantic structure of a photo's data
export class Photo {
  constructor(data) {
    this.uuid = data.uuid;
    this.filename = data.filename;
    this.albumUUIDs = data.albums;
    this.metadata = data.exif_info;
    this.aestheticScore = data.score.overall;
    this.semanticLabels = data.labels;
    this.location = data.location;
    this.dateTaken = data.date;
    // ... additional properties as needed
  }

  // Semantically meaningful method to determine if photo meets criteria
  matchesCriteria(criteria) {
    // Implement logic based on criteria object
    // For example, check if aestheticScore exceeds a threshold
    return this.aestheticScore >= criteria.minScore;
  }
}
```

### **./backend/public/stylesheets/scss/style.scss**
```
### **./backend/package.json**
```
// ./public/stylesheets/scss/style.scss

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

h1 {
  text-align: center;
  margin-top: 20px;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

.photo-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  padding: 10px;
}

.photo-item {
  margin: 10px;
  text-align: center;
}

.photo-item img {
  max-width: 300px;
  height: auto;
  border: 1px solid #ccc;
}

.photo-item p {
  margin-top: 5px;
}

.album-list {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.album-item {
  margin: 10px;
  font-size: 1.2em;
}

form {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 20px;
}

form label {
  margin-right: 10px;
}

form select {
  margin-right: 20px;
}

form button {
  padding: 5px 10px;
}
```

{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "express-handlebars": "^8.0.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "test:watch": "node --experimental-vm-modules node_modules/.bin/jest --watch",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
```

### **./backend/.nvmrc**
```
20
```

### **./backend/scripts/detect_cameras.js**
```
### **./backend/package.json**
```
{
  "name": "photo-filter-backend",
  "version": "1.0.0",
  "main": "server.js",
  "license": "MIT",
  "type": "module",
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "express-handlebars": "^8.0.1",
    "fs-extra": "^11.2.0",
    "jsonapi-serializer": "^3.6.7",
    "osx-tag": "^0.4.9",
    "plist": "^3.1.0"
  },
  "devDependencies": {
    "concurrently": "^9.0.1",
    "jest": "^29.7.0",
    "nodemon": "^3.1.7"
  },
  "scripts": {
    "setup": "node ./scripts/setup.js",
    "start": "node server.js",
    "dev": "nodemon --ignore 'data/*' server.js",
    "test": "node --experimental-vm-modules node_modules/.bin/jest",
    "test:watch": "node --experimental-vm-modules node_modules/.bin/jest --watch",
    "generate-overview": "../generate-overview.sh",
    "postinstall": "node ./scripts/setup.js"
  }
}
/**
 * List all distinct physical cameras that contributed to an album.
 *
 * USAGE
 *   node detect_cameras.js <ALBUM_UUID> [--json]
 *
 * OUTPUT
 *   By default: a nice aligned table.
 *   With --json:  JSON { cameraKey: count, ... } to stdout.
 *
 * A “cameraKey” is:  `${make}|${model}|${serial}`  where
 *   make   – EXIF "Make"  (or "Unknown")
 *   model  – EXIF "Model" (or "Unknown")
 *   serial – first non‑empty of BodySerialNumber, SerialNumber,
 *            InternalSerialNumber, CameraSerialNumber, else "Unknown"
 *
 * The script is intentionally defensive – *any* missing or non‑string
 * metadata ends up as "Unknown", never crashes the run.
 */

import { exiftool } from "exiftool-vendored";
import fg from "fast-glob";
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Return a trimmed string or 'Unknown' when falsy / non‑string */
const safe = (v) =>
  typeof v === "string"
    ? v.replace(/\0/g, "").trim() || "Unknown"
    : v === undefined || v === null
      ? "Unknown"
      : String(v).trim() || "Unknown";

/** Build the physical‑camera key from an EXIF object */
function buildCameraKey(meta) {
  const make = safe(meta.Make);
  const model = safe(meta.Model ?? meta.CameraModelName);
  const serial = safe(
    meta.BodySerialNumber ??
      meta.SerialNumber ??
      meta.InternalSerialNumber ??
      meta.CameraSerialNumber
  );

  return `${make}|${model}|${serial}`;
}

/** Human‑friendly padding */
const pad = (s, n) => s + " ".repeat(Math.max(0, n - s.length));

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  const [, , albumUuid, ...rest] = process.argv;
  if (!albumUuid) {
    console.error("Usage: node detect_cameras.js <ALBUM_UUID> [--json]");
    process.exit(1);
  }
  const asJson = rest.includes("--json");

  // images live under backend/data/albums/<uuid>/images/…
  const imagesDir = path.join(
    __dirname,
    "..",
    "data",
    "albums",
    albumUuid,
    "images"
  );
  const patterns = ["**/*.{jpg,jpeg,JPG,JPEG,png,PNG,heic,HEIC}"];
  const imagePaths = await fg(patterns, {
    cwd: imagesDir,
    absolute: true,
    followSymbolicLinks: false,
  });

  const counts = Object.create(null);

  for (const img of imagePaths) {
    try {
      const meta = await exiftool.read(img, ["-fast"]); // faster: no huge maker notes
      const key = buildCameraKey(meta);
      counts[key] = (counts[key] ?? 0) + 1;
    } catch (err) {
      // exiftool-vendored already logs warnings; we just keep going
      console.warn(
        `⚠️  EXIF read failed for ${path.basename(img)}: ${err.message}`
      );
    }
  }

  await exiftool.end(); // close daemon

  if (asJson) {
    console.log(JSON.stringify(counts, null, 2));
  } else {
    const w1 = Math.max(...Object.keys(counts).map((k) => k.length), 10);
    const w2 = Math.max(
      ...Object.values(counts).map((n) => String(n).length),
      5
    );
    console.log(pad("Camera (Make|Model|Serial)", w1), pad("Count", w2));
    console.log("-".repeat(w1 + 1 + w2));
    for (const [k, n] of Object.entries(counts).sort((a, b) => b[1] - a[1])) {
      console.log(pad(k, w1), pad(String(n), w2));
    }
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

### **./backend/.nvmrc**
```
```

### **./backend/scripts/detect_sources.js**
```
#!/usr/bin/env node
/**
 * Detect distinct camera / device sources in an album and report counts.
 *
 * Usage:
 *   node backend/scripts/detect_sources.js <ALBUM_UUID> [--json]
 *
 * With --json it prints a machine‑readable object; otherwise a table.
 */

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { normaliseDevice } from "./helper/deviceName.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---------------- helpers ----------------
function fmt(str) {
  return str ? String(str).trim() : "";
}

function heuristicFromFilename(name) {
  if (!name) return null;
  const upper = name.toUpperCase();
  if (upper.startsWith("DSCF")) return "Fujifilm (filename heuristic)";
  if (upper.startsWith("IMG_")) return "Apple iOS (filename heuristic)";
  if (upper.startsWith("DSC_")) return "Nikon (filename heuristic)";
  if (upper.match(/^P\d{7}/)) return "Panasonic (filename heuristic)";
  return null;
}
// -----------------------------------------

async function main() {
  const [albumUUID, flag] = process.argv.slice(2);
  if (!albumUUID) {
    console.error("❌  Please provide an album UUID");
    process.exit(1);
  }
  const albumDir = path.join(__dirname, "..", "data", "albums", albumUUID);
  const photosPath = path.join(albumDir, "photos.json");

  if (!(await fs.pathExists(photosPath))) {
    console.error(`❌  ${photosPath} not found – export the album first.`);
    process.exit(1);
  }

  const photos = await fs.readJson(photosPath);
  const tally = new Map();

  for (const p of photos) {
    const make = fmt(p.exif_info?.make);
    const model = fmt(p.exif_info?.model);
    let key =
      normaliseDevice(fmt(p.exif_info?.lens_model)) ??
      normaliseDevice(`${make} ${model}`) ??
      (make || model ? `${make} ${model}`.trim() : "");

    if (!key) {
      // Try lens_model
      key = fmt(p.exif_info?.lens_model);
    }
    if (!key) {
      key = heuristicFromFilename(p.original_filename);
    }
    if (!key) key = "Unknown";

    tally.set(key, (tally.get(key) || 0) + 1);
  }

  const result = Object.fromEntries(
    [...tally.entries()].sort((a, b) => b[1] - a[1])
  );

  if (flag === "--json") {
    console.log(JSON.stringify(result, null, 2));
  } else {
    console.log("\nCamera / device sources in album", albumUUID);
    console.log("=".repeat(48));
    for (const [k, v] of Object.entries(result)) {
      console.log(k.padEnd(35), v.toString().padStart(6));
    }
    console.log("=".repeat(48), "\nTotal photos:", photos.length);
  }
}
main().catch((err) => {
  console.error(err);
  process.exit(1);
});
20
```

### **./backend/scripts/setup.js**
```
```

### **./backend/scripts/detect_cameras.js**
```
/**
 * List all distinct physical cameras that contributed to an album.
 *
 * USAGE
 *   node detect_cameras.js <ALBUM_UUID> [--json]
 *
 * OUTPUT
 *   By default: a nice aligned table.
 *   With --json:  JSON { cameraKey: count, ... } to stdout.
 *
 * A “cameraKey” is:  `${make}|${model}|${serial}`  where
 *   make   – EXIF "Make"  (or "Unknown")
 *   model  – EXIF "Model" (or "Unknown")
 *   serial – first non‑empty of BodySerialNumber, SerialNumber,
 *            InternalSerialNumber, CameraSerialNumber, else "Unknown"
 *
 * The script is intentionally defensive – *any* missing or non‑string
 * metadata ends up as "Unknown", never crashes the run.
 */

import { exiftool } from "exiftool-vendored";
import fg from "fast-glob";
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Return a trimmed string or 'Unknown' when falsy / non‑string */
const safe = (v) =>
  typeof v === "string"
    ? v.replace(/\0/g, "").trim() || "Unknown"
    : v === undefined || v === null
      ? "Unknown"
      : String(v).trim() || "Unknown";

/** Build the physical‑camera key from an EXIF object */
function buildCameraKey(meta) {
  const make = safe(meta.Make);
  const model = safe(meta.Model ?? meta.CameraModelName);
  const serial = safe(
    meta.BodySerialNumber ??
      meta.SerialNumber ??
      meta.InternalSerialNumber ??
      meta.CameraSerialNumber
  );

  return `${make}|${model}|${serial}`;
}

/** Human‑friendly padding */
const pad = (s, n) => s + " ".repeat(Math.max(0, n - s.length));

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  const [, , albumUuid, ...rest] = process.argv;
  if (!albumUuid) {
    console.error("Usage: node detect_cameras.js <ALBUM_UUID> [--json]");
    process.exit(1);
  }
  const asJson = rest.includes("--json");

  // images live under backend/data/albums/<uuid>/images/…
  const imagesDir = path.join(
    __dirname,
    "..",
    "data",
    "albums",
    albumUuid,
    "images"
  );
  const patterns = ["**/*.{jpg,jpeg,JPG,JPEG,png,PNG,heic,HEIC}"];
  const imagePaths = await fg(patterns, {
    cwd: imagesDir,
    absolute: true,
    followSymbolicLinks: false,
  });

  const counts = Object.create(null);

  for (const img of imagePaths) {
    try {
      const meta = await exiftool.read(img, ["-fast"]); // faster: no huge maker notes
      const key = buildCameraKey(meta);
      counts[key] = (counts[key] ?? 0) + 1;
    } catch (err) {
      // exiftool-vendored already logs warnings; we just keep going
      console.warn(
        `⚠️  EXIF read failed for ${path.basename(img)}: ${err.message}`
      );
    }
  }

  await exiftool.end(); // close daemon

  if (asJson) {
    console.log(JSON.stringify(counts, null, 2));
  } else {
    const w1 = Math.max(...Object.keys(counts).map((k) => k.length), 10);
    const w2 = Math.max(
      ...Object.values(counts).map((n) => String(n).length),
      5
    );
    console.log(pad("Camera (Make|Model|Serial)", w1), pad("Count", w2));
    console.log("-".repeat(w1 + 1 + w2));
    for (const [k, n] of Object.entries(counts).sort((a, b) => b[1] - a[1])) {
      console.log(pad(k, w1), pad(String(n), w2));
    }
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
// ./backend/scripts/setup.js
//
// Prepares the Python virtual‑env used by the Express backend:
//
//   • creates backend/venv with Python 3.11 if it does not exist
//   • installs (or upgrades) **osxphotos**
//       – by default pulls Jamie’s fork/branch that adds `.utc/.local`
//         datetime postfix support for filename templates
//       – set the env‑var  OSXPHOTOS_SPEC=osxphotos  to fall back to PyPI
//
// Run automatically by `npm install` via the “postinstall” script.
//

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

/** absolute path helpers */
const venvDir = path.join(process.cwd(), "venv");
const venvPython = path.join(venvDir, "bin", "python3");
const venvPip = path.join(venvDir, "bin", "pip");

/** which Python binary to create the venv with */
const PYTHON_EXE = "python3.11";

/** default pip‑install spec for Jamie’s experimental branch */
const DEFAULT_FORK_SPEC =
  "git+https://github.com/openhouse/osxphotos.git" +
  "@codex/implement-utc-and-local-postfix-for-template-datetime" +
  "#egg=osxphotos";

/** caller can override with  OSXPHOTOS_SPEC=… */
const OSXPHOTOS_SPEC = process.env.OSXPHOTOS_SPEC || DEFAULT_FORK_SPEC;

/** tiny helper for console blocks */
function banner(msg) {
  console.log("\n" + "─".repeat(72) + `\n${msg}\n` + "─".repeat(72));
}

(async () => {
  try {
    // ---------------------------------------------------------------------
    // 1 · Ensure virtual‑env exists
    // ---------------------------------------------------------------------
    const venvExists = await fs.pathExists(venvPython);
    if (!venvExists) {
      banner(`Creating Python virtual‑env   (${PYTHON_EXE})`);
      await execAsync(`${PYTHON_EXE} -m venv venv`);
    } else {
      console.log("✔ virtual‑env already present – skipping creation");
    }

    // ---------------------------------------------------------------------
    // 2 · Install / upgrade osxphotos from the requested spec
    // ---------------------------------------------------------------------
    banner(`Installing osxphotos from:  ${OSXPHOTOS_SPEC}`);
    await execAsync(`"${venvPip}" install --upgrade "${OSXPHOTOS_SPEC}"`);

    banner("Setup succeeded – backend Python tooling ready.");
  } catch (err) {
    console.error("❌ backend/scripts/setup.js failed:", err);
    process.exit(1);
  }
})();
```
```


### **./backend/scripts/detect_sources.js**
### **./backend/scripts/helper/deviceName.js**
```
```
#!/usr/bin/env node
/**
 * Detect distinct camera / device sources in an album and report counts.
 *
 * Usage:
 *   node backend/scripts/detect_sources.js <ALBUM_UUID> [--json]
 *
 * With --json it prints a machine‑readable object; otherwise a table.
 */

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { normaliseDevice } from "./helper/deviceName.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ---------------- helpers ----------------
function fmt(str) {
  return str ? String(str).trim() : "";
}

function heuristicFromFilename(name) {
  if (!name) return null;
  const upper = name.toUpperCase();
  if (upper.startsWith("DSCF")) return "Fujifilm (filename heuristic)";
  if (upper.startsWith("IMG_")) return "Apple iOS (filename heuristic)";
  if (upper.startsWith("DSC_")) return "Nikon (filename heuristic)";
  if (upper.match(/^P\d{7}/)) return "Panasonic (filename heuristic)";
  return null;
}
// -----------------------------------------

async function main() {
  const [albumUUID, flag] = process.argv.slice(2);
  if (!albumUUID) {
    console.error("❌  Please provide an album UUID");
    process.exit(1);
  }
  const albumDir = path.join(__dirname, "..", "data", "albums", albumUUID);
  const photosPath = path.join(albumDir, "photos.json");

  if (!(await fs.pathExists(photosPath))) {
    console.error(`❌  ${photosPath} not found – export the album first.`);
    process.exit(1);
  }

  const photos = await fs.readJson(photosPath);
  const tally = new Map();

  for (const p of photos) {
    const make = fmt(p.exif_info?.make);
    const model = fmt(p.exif_info?.model);
    let key =
      normaliseDevice(fmt(p.exif_info?.lens_model)) ??
      normaliseDevice(`${make} ${model}`) ??
      (make || model ? `${make} ${model}`.trim() : "");

    if (!key) {
      // Try lens_model
      key = fmt(p.exif_info?.lens_model);
    }
    if (!key) {
      key = heuristicFromFilename(p.original_filename);
    }
    if (!key) key = "Unknown";

    tally.set(key, (tally.get(key) || 0) + 1);
  }

  const result = Object.fromEntries(
    [...tally.entries()].sort((a, b) => b[1] - a[1])
  );

  if (flag === "--json") {
    console.log(JSON.stringify(result, null, 2));
  } else {
    console.log("\nCamera / device sources in album", albumUUID);
    console.log("=".repeat(48));
    for (const [k, v] of Object.entries(result)) {
      console.log(k.padEnd(35), v.toString().padStart(6));
    }
    console.log("=".repeat(48), "\nTotal photos:", photos.length);
  }
}
main().catch((err) => {
  console.error(err);
  process.exit(1);
});
// helper/deviceName.js
export function normaliseDevice(raw) {
  if (!raw) return null;
  // Apple devices -------------------------------------------------
  const mApple = raw.match(/iPhone (\d+(?: Pro| Pro Max| mini|))?/i);
  if (mApple) return `Apple ${mApple[0]}`.replace(/\s+/g, " ").trim();

  // Google Pixel --------------------------------------------------
  const mPixel = raw.match(/Pixel (\d+)/i);
  if (mPixel) return `Google Pixel ${mPixel[1]}`;

  return null; // let caller fall back to heuristic / Unknown
}
```

### **./backend/scripts/setup.js**
```
```

// ./backend/scripts/setup.js
//
// Prepares the Python virtual‑env used by the Express backend:
//
//   • creates backend/venv with Python 3.11 if it does not exist
//   • installs (or upgrades) **osxphotos**
//       – by default pulls Jamie’s fork/branch that adds `.utc/.local`
//         datetime postfix support for filename templates
//       – set the env‑var  OSXPHOTOS_SPEC=osxphotos  to fall back to PyPI
//
// Run automatically by `npm install` via the “postinstall” script.
//

import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs-extra";
import path from "path";

const execAsync = promisify(exec);

/** absolute path helpers */
const venvDir = path.join(process.cwd(), "venv");
const venvPython = path.join(venvDir, "bin", "python3");
const venvPip = path.join(venvDir, "bin", "pip");

/** which Python binary to create the venv with */
const PYTHON_EXE = "python3.11";

/** default pip‑install spec for Jamie’s experimental branch */
const DEFAULT_FORK_SPEC =
  "git+https://github.com/openhouse/osxphotos.git" +
  "@codex/implement-utc-and-local-postfix-for-template-datetime" +
  "#egg=osxphotos";

/** caller can override with  OSXPHOTOS_SPEC=… */
const OSXPHOTOS_SPEC = process.env.OSXPHOTOS_SPEC || DEFAULT_FORK_SPEC;

/** tiny helper for console blocks */
function banner(msg) {
  console.log("\n" + "─".repeat(72) + `\n${msg}\n` + "─".repeat(72));
}

(async () => {
  try {
    // ---------------------------------------------------------------------
    // 1 · Ensure virtual‑env exists
    // ---------------------------------------------------------------------
    const venvExists = await fs.pathExists(venvPython);
    if (!venvExists) {
      banner(`Creating Python virtual‑env   (${PYTHON_EXE})`);
      await execAsync(`${PYTHON_EXE} -m venv venv`);
    } else {
      console.log("✔ virtual‑env already present – skipping creation");
    }

    // ---------------------------------------------------------------------
    // 2 · Install / upgrade osxphotos from the requested spec
    // ---------------------------------------------------------------------
    banner(`Installing osxphotos from:  ${OSXPHOTOS_SPEC}`);
    await execAsync(`"${venvPip}" install --upgrade "${OSXPHOTOS_SPEC}"`);

    banner("Setup succeeded – backend Python tooling ready.");
  } catch (err) {
    console.error("❌ backend/scripts/setup.js failed:", err);
    process.exit(1);
  }
})();
```

### **./backend/scripts/helper/deviceName.js**
```
### **./backend/tsconfig.json**
```
// helper/deviceName.js
export function normaliseDevice(raw) {
  if (!raw) return null;
  // Apple devices -------------------------------------------------
  const mApple = raw.match(/iPhone (\d+(?: Pro| Pro Max| mini|))?/i);
  if (mApple) return `Apple ${mApple[0]}`.replace(/\s+/g, " ").trim();

  // Google Pixel --------------------------------------------------
  const mPixel = raw.match(/Pixel (\d+)/i);
  if (mPixel) return `Google Pixel ${mPixel[1]}`;

  return null; // let caller fall back to heuristic / Unknown
}
```

{
  "compilerOptions": {
    /* Language and Environment */
    "target": "ES2021", // or "ES2022"
    "lib": ["ES2021", "DOM"],
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,

    /* CommonJS if you prefer older Node style:
         "module": "CommonJS", 
      */

    /* Source Maps & Declarations */
    "outDir": "dist",
    "rootDir": "src",
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    /* Strictness */
    "strict": true,
    "skipLibCheck": true,

    /* Additional Node.js Options */
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["node_modules"]
}
```

### **./backend/controllers/api-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );

      // After exporting, rename files to prepend the photo's capture date
      await renameExportedImages(imagesDir, photosPath);
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Rename exported images with date-based filenames
async function renameExportedImages(imagesDir, photosPath) {
  const photosData = await fs.readJson(photosPath);

  for (const photo of photosData) {
    const originalName = path.parse(photo.original_filename).name; // e.g., DSCF1191
    const photoDate = new Date(photo.date); // Parse the photo’s date field
    const formattedDate = formatPhotoDate(photoDate); // YYYYMMDD-HHMMSS
    const oldPath = path.join(imagesDir, `${originalName}.jpg`);

    if (await fs.pathExists(oldPath)) {
      let newFilename = `${formattedDate}-${originalName}.jpg`;
      let finalPath = path.join(imagesDir, newFilename);

      // Check for collisions
      let counter = 1;
      while (await fs.pathExists(finalPath)) {
        newFilename = `${formattedDate}-${originalName}-${counter}.jpg`;
        finalPath = path.join(imagesDir, newFilename);
        counter++;
      }

      await fs.rename(oldPath, finalPath);
      console.log(`Renamed ${originalName}.jpg to ${newFilename}`);
    } else {
      console.warn(`File not found for rename: ${oldPath}`);
    }
  }
}

// Format the photo date as YYYYMMDD-HHMMSS
function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
### **./backend/tsconfig.json**
```
```

### **./backend/controllers/get-albums.js**
```
{
  "compilerOptions": {
    /* Language and Environment */
    "target": "ES2021", // or "ES2022"
    "lib": ["ES2021", "DOM"],
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,

    /* CommonJS if you prefer older Node style:
         "module": "CommonJS", 
      */

    /* Source Maps & Declarations */
    "outDir": "dist",
    "rootDir": "src",
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    /* Strictness */
    "strict": true,
    "skipLibCheck": true,

    /* Additional Node.js Options */
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*", "tests/**/*"],
  "exclude": ["node_modules"]
}
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

```
### **./backend/controllers/api-controller.js**

### **./backend/controllers/people-legacy-controller.js**
```
```
// backend/controllers/people-legacy-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { getNestedProperty } from "../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Show all people in an album
export const getPeopleInAlbumLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Gather all distinct people
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    const people = Array.from(allPersons).sort();

    // Render persons.hbs view
    res.render("persons", { albumUUID, people });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Show photos of a single person in the album
export const getPhotosByPersonLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by person
    const filteredPhotos = photosData.filter((photo) => {
      return Array.isArray(photo.persons) && photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      // No photos of this person
      return res.render("person", {
        albumUUID,
        personName,
        photos: [],
        scoreAttributes: [],
        sortAttribute,
        sortOrder,
      });
    }

    // Add original_name property
    filteredPhotos.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from the first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort photos based on the requested attribute
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Render person.hbs view
    res.render("person", {
      albumUUID,
      personName,
      photos: filteredPhotos,
      scoreAttributes,
      sortAttribute,
      sortOrder,
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

### **./backend/controllers/photo-controller.js**
```
// backend/controllers/api/photos-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ensure 'type' is 'photo' and prevent pluralization
const PhotoSerializer = new Serializer("photo", {
  id: "uuid", // Use 'uuid' as the 'id' field
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album", // Use singular 'album' for the relationship
    },
  },
  pluralizeType: false, // Prevent automatic pluralization
});

export const getPhotosByAlbumData = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall"; // Default sort attribute
    const sortOrder = req.query.order || "desc"; // Default sort order

    // Paths
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    // Ensure directories exist
    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    // Check if photos.json exists
    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );

      // After exporting, rename files to prepend the photo's capture date
      await renameExportedImages(imagesDir, photosPath);
    }

    // Read photos data
    const photosData = await fs.readJson(photosPath);

    // Add 'originalName' property to each photo
    photosData.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    // Extract the list of score attributes
    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort photos based on the requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      if (sortOrder === "asc") {
        return aValue - bValue;
      } else {
        return bValue - aValue;
      }
    });

    // Add album relationship
    photosData.forEach((photo) => {
      photo.album = albumUUID;
    });

    // Serialize data
    const jsonApiData = PhotoSerializer.serialize(photosData);

    // Send JSON response with photos and available score attributes
    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Helper function to export images using osxphotos
async function runOsxphotosExportImages(
  osxphotosPath,
  albumUUID,
  imagesDir,
  photosPath
) {
  // Read photo UUIDs from photos.json
  const photosData = await fs.readJson(photosPath);
  const uuids = photosData.map((photo) => photo.uuid).join("\n");
  const uuidsFilePath = path.join(imagesDir, "uuids.txt");

  // Ensure imagesDir exists
  await fs.ensureDir(imagesDir);

  // Write UUIDs to uuids.txt
  await fs.writeFile(uuidsFilePath, uuids, "utf-8");

  // Use {original_name} template to avoid double extensions
  const commandImages = `"${osxphotosPath}" export "${imagesDir}" --uuid-from-file "${uuidsFilePath}" --filename "{original_name}" --convert-to-jpeg --jpeg-ext jpg`;

  console.log(`Executing command:\n${commandImages}`);
  await execCommand(commandImages, "Error exporting album images:");
}

// Rename exported images with date-based filenames
async function renameExportedImages(imagesDir, photosPath) {
  const photosData = await fs.readJson(photosPath);

  for (const photo of photosData) {
    const originalName = path.parse(photo.original_filename).name; // e.g., DSCF1191
    const photoDate = new Date(photo.date); // Parse the photo’s date field
    const formattedDate = formatPhotoDate(photoDate); // YYYYMMDD-HHMMSS
    const oldPath = path.join(imagesDir, `${originalName}.jpg`);

    if (await fs.pathExists(oldPath)) {
      let newFilename = `${formattedDate}-${originalName}.jpg`;
      let finalPath = path.join(imagesDir, newFilename);

      // Check for collisions
      let counter = 1;
      while (await fs.pathExists(finalPath)) {
        newFilename = `${formattedDate}-${originalName}-${counter}.jpg`;
        finalPath = path.join(imagesDir, newFilename);
        counter++;
      }

      await fs.rename(oldPath, finalPath);
      console.log(`Renamed ${originalName}.jpg to ${newFilename}`);
    } else {
      console.warn(`File not found for rename: ${oldPath}`);
    }
  }
}

// Format the photo date as YYYYMMDD-HHMMSS
function formatPhotoDate(dateObj) {
  const YYYY = dateObj.getFullYear();
  const MM = String(dateObj.getMonth() + 1).padStart(2, "0");
  const DD = String(dateObj.getDate()).padStart(2, "0");
  const HH = String(dateObj.getHours()).padStart(2, "0");
  const mm = String(dateObj.getMinutes()).padStart(2, "0");
  const ss = String(dateObj.getSeconds()).padStart(2, "0");
  return `${YYYY}${MM}${DD}-${HH}${mm}${ss}`;
}

// Helper function to get nested properties safely
function getNestedProperty(obj, propertyPath) {
  return propertyPath
    .split(".")
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj
    );
}
```

### **./backend/controllers/get-albums.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
// ./controllers/get-albums.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to get the list of albums
export const getAlbums = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_albums.py"
    );

    // Ensure data directory exists
    await fs.ensureDir(dataDir);

    // Check if albums.json exists
    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");

      // Export albums using the Python script
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    // Read albums data
    const albumsData = await fs.readJson(albumsPath);

    // Render albums view
    res.render("albums", { albums: albumsData });
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).send("Internal Server Error");
  }
};
```

```
### **./backend/controllers/api/albums-controller.js**

```
### **./backend/controllers/people-legacy-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const AlbumSerializer = new Serializer("album", {
  id: "uuid",
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
  relationships: {
    persons: {
      type: "person",
    },
  },
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    await fs.ensureDir(dataDir);

    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    const albumsData = await fs.readJson(albumsPath);
    const jsonApiData = AlbumSerializer.serialize(albumsData);
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    const albumsData = await fs.readJson(albumsPath);
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    let persons = [];
    if (await fs.pathExists(photosPath)) {
      const photosData = await fs.readJson(photosPath);
      const allPersons = new Set();
      photosData.forEach((photo) => {
        if (Array.isArray(photo.persons)) {
          photo.persons.forEach((name) => allPersons.add(name));
        }
      });
      persons = Array.from(allPersons).map((name) => {
        return {
          id: slugifyName(name),
          name: name,
        };
      });
    }

    const albumRecord = {
      uuid: album.uuid,
      title: album.title,
    };

    let albumJsonApi = AlbumSerializer.serialize(albumRecord);
    albumJsonApi.data.relationships = albumJsonApi.data.relationships || {};
    albumJsonApi.data.relationships.persons = {
      data: persons.map((p) => ({ type: "person", id: p.id })),
    };

    const personJsonApi = PersonSerializer.serialize(persons);

    const merged = {
      data: albumJsonApi.data,
      included: personJsonApi.data,
      meta: {},
    };

    res.json(merged);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
// backend/controllers/people-legacy-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { getNestedProperty } from "../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Show all people in an album
export const getPeopleInAlbumLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Gather all distinct people
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    const people = Array.from(allPersons).sort();

    // Render persons.hbs view
    res.render("persons", { albumUUID, people });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).send("Internal Server Error");
  }
};

// Show photos of a single person in the album
export const getPhotosByPersonLegacy = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).send("Album not found or no photos available");
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by person
    const filteredPhotos = photosData.filter((photo) => {
      return Array.isArray(photo.persons) && photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      // No photos of this person
      return res.render("person", {
        albumUUID,
        personName,
        photos: [],
        scoreAttributes: [],
        sortAttribute,
        sortOrder,
      });
    }

    // Add original_name property
    filteredPhotos.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    // Extract score attributes from the first photo
    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    // Sort photos based on the requested attribute
    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    // Render person.hbs view
    res.render("person", {
      albumUUID,
      personName,
      photos: filteredPhotos,
      scoreAttributes,
      sortAttribute,
      sortOrder,
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).send("Internal Server Error");
  }
};
```
```


### **./backend/controllers/api/index.js**
```
### **./backend/controllers/photo-controller.js**
```
// ./controllers/photo-controller.js

import { getAlbums } from "./get-albums.js";
import { getPhotosByAlbum } from "./get-photos-by-album.js";

export { getAlbums, getPhotosByAlbum };
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
```

### **./backend/controllers/api/albums-controller.js**
```
```

### **./backend/controllers/api/time-controller.js**
```
// backend/controllers/api/albums-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const AlbumSerializer = new Serializer("album", {
  id: "uuid",
  attributes: ["title"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
  relationships: {
    persons: {
      type: "person",
    },
  },
});

export const getAlbumsData = async (req, res) => {
  try {
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_albums.py"
    );

    await fs.ensureDir(dataDir);

    if (!(await fs.pathExists(albumsPath))) {
      console.log("albums.json not found. Exporting albums using osxphotos...");
      await runPythonScript(pythonPath, scriptPath, [], albumsPath);
    }

    const albumsData = await fs.readJson(albumsPath);
    const jsonApiData = AlbumSerializer.serialize(albumsData);
    res.json(jsonApiData);
  } catch (error) {
    console.error("Error fetching albums:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

export const getAlbumById = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumsPath = path.join(dataDir, "albums.json");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    const albumsData = await fs.readJson(albumsPath);
    const album = albumsData.find((a) => a.uuid === albumUUID);

    if (!album) {
      return res.status(404).json({ errors: [{ detail: "Album not found" }] });
    }

    let persons = [];
    if (await fs.pathExists(photosPath)) {
      const photosData = await fs.readJson(photosPath);
      const allPersons = new Set();
      photosData.forEach((photo) => {
        if (Array.isArray(photo.persons)) {
          photo.persons.forEach((name) => allPersons.add(name));
        }
      });
      persons = Array.from(allPersons).map((name) => {
        return {
          id: slugifyName(name),
          name: name,
        };
      });
    }

    const albumRecord = {
      uuid: album.uuid,
      title: album.title,
    };

    let albumJsonApi = AlbumSerializer.serialize(albumRecord);
    albumJsonApi.data.relationships = albumJsonApi.data.relationships || {};
    albumJsonApi.data.relationships.persons = {
      data: persons.map((p) => ({ type: "person", id: p.id })),
    };

    const personJsonApi = PersonSerializer.serialize(persons);

    const merged = {
      data: albumJsonApi.data,
      included: personJsonApi.data,
      meta: {},
    };

    res.json(merged);
  } catch (error) {
    console.error("Error fetching album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

function slugifyName(name) {
  return name
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/api/index.js**
```
// backend/controllers/api/time-controller.js

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";

/**
 * getTimeIndex
 *
 * Returns a hierarchical time-based index of all photos known to the system:
 *   {
 *     "years": [
 *       {
 *         "year": 2024,
 *         "months": [
 *           {
 *             "month": 12,
 *             "days": [5, 6, 7]
 *           }
 *         ]
 *       }
 *     ]
 *   }
 *
 * Only includes years/months/days that actually have photos. Does not currently handle weeks.
 */
export async function getTimeIndex(req, res) {
  try {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "..", "data", "albums");
    // We'll iterate through all album folders, parse each photos.json,
    // and accumulate date info in a structured way.

    const yearMap = new Map();
    // yearMap[year] = {
    //   <monthNumber>: Set([dayNumbers]),
    //   ...
    // }

    const albumDirs = await fs.readdir(dataDir, { withFileTypes: true });

    for (const dirEnt of albumDirs) {
      if (!dirEnt.isDirectory()) continue;
      const albumUUID = dirEnt.name;
      const photosJsonPath = path.join(dataDir, albumUUID, "photos.json");

      if (!(await fs.pathExists(photosJsonPath))) {
        continue;
      }

      const photosData = await fs.readJson(photosJsonPath);
      for (const photo of photosData) {
        // Date parse
        const dateObj = new Date(photo.date);
        if (isNaN(dateObj.getTime())) {
          continue; // skip if invalid date
        }

        const y = dateObj.getFullYear();
        const m = dateObj.getMonth() + 1; // 1-based
        const d = dateObj.getDate();

        if (!yearMap.has(y)) {
          yearMap.set(y, new Map());
        }
        const monthMap = yearMap.get(y);

        if (!monthMap.has(m)) {
          monthMap.set(m, new Set());
        }
        const daySet = monthMap.get(m);
        daySet.add(d);
      }
    }

    // Now convert that Map-of-Maps-of-Sets into a JSON-friendly object
    const yearsArray = [];
    // Sort the years ascending, e.g., 2019, 2020, etc.
    const sortedYears = Array.from(yearMap.keys()).sort((a, b) => a - b);

    for (const year of sortedYears) {
      const monthsArray = [];
      const monthMap = yearMap.get(year);

      // Sort months ascending
      const sortedMonths = Array.from(monthMap.keys()).sort((a, b) => a - b);
      for (const month of sortedMonths) {
        const daysArray = Array.from(monthMap.get(month)).sort((a, b) => a - b);
        monthsArray.push({
          month,
          days: daysArray,
        });
      }

      yearsArray.push({
        year,
        months: monthsArray,
      });
    }

    const finalIndex = { years: yearsArray };

    return res.json(finalIndex);
  } catch (error) {
    console.error("Error building time index:", error);
    return res.status(500).json({ errors: [{ detail: error.message }] });
  }
}
```

### **./backend/controllers/api/people-controller.js**
```
// ./controllers/api/index.js

export { getAlbumsData, getAlbumById } from "./albums-controller.js";
export { getPhotosByAlbumData } from "./photos-controller.js";
// backend/controllers/api/people-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
    "persons",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

// List all people in an album
export const getPeopleInAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Extract all persons from all photos
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    res.json({ data: Array.from(allPersons) });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Get photos of a specific person in the album
export const getPhotosByPerson = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by personName
    const filteredPhotos = photosData.filter((photo) => {
      if (!Array.isArray(photo.persons)) return false;
      return photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      return res.json({
        data: [],
        meta: {
          albumUUID,
          personName,
          sortAttribute,
          sortOrder,
          scoreAttributes: [],
        },
      });
    }

    // Add originalName property
    filteredPhotos.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    filteredPhotos.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(filteredPhotos);

    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        personName,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

### **./backend/controllers/api/time-controller.js**
```
```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/time-controller.js

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";

/**
 * getTimeIndex
 *
 * Returns a hierarchical time-based index of all photos known to the system:
 *   {
 *     "years": [
 *       {
 *         "year": 2024,
 *         "months": [
 *           {
 *             "month": 12,
 *             "days": [5, 6, 7]
 *           }
 *         ]
 *       }
 *     ]
 *   }
 *
 * Only includes years/months/days that actually have photos. Does not currently handle weeks.
 */
export async function getTimeIndex(req, res) {
  try {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "..", "data", "albums");
    // We'll iterate through all album folders, parse each photos.json,
    // and accumulate date info in a structured way.

    const yearMap = new Map();
    // yearMap[year] = {
    //   <monthNumber>: Set([dayNumbers]),
    //   ...
    // }

    const albumDirs = await fs.readdir(dataDir, { withFileTypes: true });

    for (const dirEnt of albumDirs) {
      if (!dirEnt.isDirectory()) continue;
      const albumUUID = dirEnt.name;
      const photosJsonPath = path.join(dataDir, albumUUID, "photos.json");

      if (!(await fs.pathExists(photosJsonPath))) {
        continue;
      }

      const photosData = await fs.readJson(photosJsonPath);
      for (const photo of photosData) {
        // Date parse
        const dateObj = new Date(photo.date);
        if (isNaN(dateObj.getTime())) {
          continue; // skip if invalid date
        }

        const y = dateObj.getFullYear();
        const m = dateObj.getMonth() + 1; // 1-based
        const d = dateObj.getDate();

        if (!yearMap.has(y)) {
          yearMap.set(y, new Map());
        }
        const monthMap = yearMap.get(y);

        if (!monthMap.has(m)) {
          monthMap.set(m, new Set());
        }
        const daySet = monthMap.get(m);
        daySet.add(d);
      }
    }

    // Now convert that Map-of-Maps-of-Sets into a JSON-friendly object
    const yearsArray = [];
    // Sort the years ascending, e.g., 2019, 2020, etc.
    const sortedYears = Array.from(yearMap.keys()).sort((a, b) => a - b);

    for (const year of sortedYears) {
      const monthsArray = [];
      const monthMap = yearMap.get(year);

      // Sort months ascending
      const sortedMonths = Array.from(monthMap.keys()).sort((a, b) => a - b);
      for (const month of sortedMonths) {
        const daysArray = Array.from(monthMap.get(month)).sort((a, b) => a - b);
        monthsArray.push({
          month,
          days: daysArray,
        });
      }

      yearsArray.push({
        year,
        months: monthsArray,
      });
    }

    const finalIndex = { years: yearsArray };

    return res.json(finalIndex);
  } catch (error) {
    console.error("Error building time index:", error);
    return res.status(500).json({ errors: [{ detail: error.message }] });
  }
}
// backend/controllers/api/photos-controller.js
//
// Builds `exportedFilename` from the *same* micro-second timestamp that
// osxphotos embedded, so the frontend can construct <img src> without
// touching the filesystem.
//
// NB: any older duplicate controller (e.g. “-photos-controller.js”)
//     should be deleted to prevent route-loader ambiguity.

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../../utils/export-images.js";
import {
  formatPreciseTimestamp,
  getNestedProperty,
} from "../../utils/helpers.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/* ---------- JSON:API serializers ---------- */

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "exportedFilename",
    "score",
    "exifInfo",
  ],
  relationships: {
    album: { type: "album" },
    persons: { type: "person" },
  },
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

/* ---------- main controller ---------- */

export const getPhotosByAlbumData = async (req, res) => {
  try {
    /* paths & params */
    const albumUUID = req.params.albumUUID;
    const sortAttr = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumDir = path.join(dataDir, "albums", albumUUID);
    const photosJSON = path.join(albumDir, "photos.json");
    const imagesDir = path.join(albumDir, "images");

    const venvDir = path.join(__dirname, "..", "..", "venv");
    const python = path.join(venvDir, "bin", "python3");
    const pyExport = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotos = path.join(venvDir, "bin", "osxphotos");

    /* (1) Ensure exports exist */
    await fs.ensureDir(imagesDir);
    if (!(await fs.pathExists(photosJSON))) {
      await runPythonScript(python, pyExport, [albumUUID], photosJSON);
      await runOsxphotosExportImages(
        osxphotos,
        albumUUID,
        imagesDir,
        photosJSON
      );
    }

    /* (2) Load data & enrich */
    let photos = await fs.readJson(photosJSON);

    const personsMap = new Map(); // slug -> {id,name}

    photos.forEach((p) => {
      /* derive names & filenames */
      p.originalName = path.parse(p.original_filename).name;
      const tsSegment = formatPreciseTimestamp(p.date);
      p.exportedFilename = `${tsSegment}-${p.originalName}.jpg`;

      /* normalise persons */
      p.persons = Array.isArray(p.persons) ? p.persons : [];

      p.personsData = p.persons.map((name) => {
        const slug = slugify(name);
        if (!personsMap.has(slug)) personsMap.set(slug, { id: slug, name });
        return { type: "person", id: slug };
      });

      p.album = albumUUID;
    });

    /* (3) sort */
    photos.sort((a, b) => {
      const va = getNestedProperty(a, sortAttr);
      const vb = getNestedProperty(b, sortAttr);
      if (va === undefined || va === null) return 1;
      if (vb === undefined || vb === null) return -1;
      return sortOrder === "asc" ? va - vb : vb - va;
    });

    /* (4) serialise */
    const jsonPhotos = PhotoSerializer.serialize(photos);
    const jsonPersons = PersonSerializer.serialize([...personsMap.values()]);

    // attach person relationships
    jsonPhotos.data.forEach((d) => {
      const src = photos.find((p) => p.uuid === d.id);
      d.relationships = d.relationships || {};
      d.relationships.persons = { data: src.personsData };
    });

    res.json({
      data: jsonPhotos.data,
      included: jsonPersons.data,
      meta: {
        albumUUID,
        sortAttribute: sortAttr,
        sortOrder,
        scoreAttributes:
          photos.length && photos[0].score ? Object.keys(photos[0].score) : [],
      },
    });
  } catch (err) {
    console.error("photos-controller:", err);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

/* ---------- util ---------- */
function slugify(str) {
  return str
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/api/people-controller.js**
```
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";
import plist from "plist";
import { exec } from "child_process";
import os from "os";
import { createRequire } from "module";
import {
  getNestedProperty,
  capitalizeAttributeName,
} from "../utils/helpers.js";

const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images with osxphotos (directly uses date/time prefix)
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 60;

    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    const photoTags = {};

    attributesToProcess.forEach(({ name, order, limit }) => {
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);
        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;
        return order === "asc" ? aValue - bValue : bValue - aValue;
      });

      const topPhotos = sortedPhotos.slice(0, limit);
      topPhotos.forEach((photo) => {
        if (!photoTags[photo.uuid]) {
          photoTags[photo.uuid] = [];
        }
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photo.uuid].includes(attributeDisplayName)) {
          photoTags[photo.uuid].push(attributeDisplayName);
        }
      });
    });

    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort the photos by requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);
      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;
      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];
    if (tags.length === 0) continue;

    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
// backend/controllers/api/people-controller.js

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { execCommand } from "../../utils/exec-command.js";
import { Serializer } from "jsonapi-serializer";
import { getNestedProperty } from "../../utils/helpers.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "filename",
    "score",
    "exifInfo",
    "persons",
  ],
  keyForAttribute: "camelCase",
  relationships: {
    album: {
      type: "album",
    },
  },
  pluralizeType: false,
});

// List all people in an album
export const getPeopleInAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Extract all persons from all photos
    const allPersons = new Set();
    for (const photo of photosData) {
      if (Array.isArray(photo.persons)) {
        photo.persons.forEach((p) => allPersons.add(p));
      }
    }

    res.json({ data: Array.from(allPersons) });
  } catch (error) {
    console.error("Error fetching people in album:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

// Get photos of a specific person in the album
export const getPhotosByPerson = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const personName = req.params.personName;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");

    if (!(await fs.pathExists(photosPath))) {
      return res.status(404).json({
        errors: [{ detail: "Album not found or no photos available" }],
      });
    }

    const photosData = await fs.readJson(photosPath);

    // Filter photos by personName
    const filteredPhotos = photosData.filter((photo) => {
      if (!Array.isArray(photo.persons)) return false;
      return photo.persons.includes(personName);
    });

    if (filteredPhotos.length === 0) {
      return res.json({
        data: [],
        meta: {
          albumUUID,
          personName,
          sortAttribute,
          sortOrder,
          scoreAttributes: [],
        },
      });
    }

    // Add originalName property
    filteredPhotos.forEach((photo) => {
      photo.originalName = path.parse(photo.original_filename).name;
    });

    const scoreAttributes = Object.keys(filteredPhotos[0].score);

    filteredPhotos.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    filteredPhotos.forEach((photo) => {
      photo.album = albumUUID;
    });

    const jsonApiData = PhotoSerializer.serialize(filteredPhotos);

    res.json({
      ...jsonApiData,
      meta: {
        albumUUID,
        personName,
        sortAttribute,
        sortOrder,
        scoreAttributes,
      },
    });
  } catch (error) {
    console.error("Error fetching photos for person:", error);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};
```

```

### **./backend/controllers/api/photos-controller.js**
```
// backend/controllers/api/photos-controller.js
//
// Builds `exportedFilename` from the *same* micro-second timestamp that
// osxphotos embedded, so the frontend can construct <img src> without
// touching the filesystem.
//
// NB: any older duplicate controller (e.g. “-photos-controller.js”)
//     should be deleted to prevent route-loader ambiguity.

import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import { runPythonScript } from "../../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../../utils/export-images.js";
import {
  formatPreciseTimestamp,
  getNestedProperty,
} from "../../utils/helpers.js";
import { Serializer } from "jsonapi-serializer";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/* ---------- JSON:API serializers ---------- */

const PersonSerializer = new Serializer("person", {
  id: "id",
  attributes: ["name"],
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

const PhotoSerializer = new Serializer("photo", {
  id: "uuid",
  attributes: [
    "originalName",
    "originalFilename",
    "exportedFilename",
    "score",
    "exifInfo",
  ],
  relationships: {
    album: { type: "album" },
    persons: { type: "person" },
  },
  keyForAttribute: "camelCase",
  pluralizeType: false,
});

/* ---------- main controller ---------- */

export const getPhotosByAlbumData = async (req, res) => {
  try {
    /* paths & params */
    const albumUUID = req.params.albumUUID;
    const sortAttr = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const dataDir = path.join(__dirname, "..", "..", "data");
    const albumDir = path.join(dataDir, "albums", albumUUID);
    const photosJSON = path.join(albumDir, "photos.json");
    const imagesDir = path.join(albumDir, "images");

    const venvDir = path.join(__dirname, "..", "..", "venv");
    const python = path.join(venvDir, "bin", "python3");
    const pyExport = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotos = path.join(venvDir, "bin", "osxphotos");

    /* (1) Ensure exports exist */
    await fs.ensureDir(imagesDir);
    if (!(await fs.pathExists(photosJSON))) {
      await runPythonScript(python, pyExport, [albumUUID], photosJSON);
      await runOsxphotosExportImages(
        osxphotos,
        albumUUID,
        imagesDir,
        photosJSON
      );
    }

    /* (2) Load data & enrich */
    let photos = await fs.readJson(photosJSON);

    const personsMap = new Map(); // slug -> {id,name}

    photos.forEach((p) => {
      /* derive names & filenames */
      p.originalName = path.parse(p.original_filename).name;
      const tsSegment = formatPreciseTimestamp(p.date);
      p.exportedFilename = `${tsSegment}-${p.originalName}.jpg`;

      /* normalise persons */
      p.persons = Array.isArray(p.persons) ? p.persons : [];

      p.personsData = p.persons.map((name) => {
        const slug = slugify(name);
        if (!personsMap.has(slug)) personsMap.set(slug, { id: slug, name });
        return { type: "person", id: slug };
      });

      p.album = albumUUID;
    });

    /* (3) sort */
    photos.sort((a, b) => {
      const va = getNestedProperty(a, sortAttr);
      const vb = getNestedProperty(b, sortAttr);
      if (va === undefined || va === null) return 1;
      if (vb === undefined || vb === null) return -1;
      return sortOrder === "asc" ? va - vb : vb - va;
    });

    /* (4) serialise */
    const jsonPhotos = PhotoSerializer.serialize(photos);
    const jsonPersons = PersonSerializer.serialize([...personsMap.values()]);

    // attach person relationships
    jsonPhotos.data.forEach((d) => {
      const src = photos.find((p) => p.uuid === d.id);
      d.relationships = d.relationships || {};
      d.relationships.persons = { data: src.personsData };
    });

    res.json({
      data: jsonPhotos.data,
      included: jsonPersons.data,
      meta: {
        albumUUID,
        sortAttribute: sortAttr,
        sortOrder,
        scoreAttributes:
          photos.length && photos[0].score ? Object.keys(photos[0].score) : [],
      },
    });
  } catch (err) {
    console.error("photos-controller:", err);
    res.status(500).json({ errors: [{ detail: "Internal Server Error" }] });
  }
};

/* ---------- util ---------- */
function slugify(str) {
  return str
    .toLowerCase()
    .replace(/[\s+]/g, "-")
    .replace(/[^a-z0-9-]/g, "");
}
```

### **./backend/controllers/get-photos-by-album.js**
```
// ./controllers/get-photos-by-album.js

import path from "path";
import { fileURLToPath } from "url";
import fs from "fs-extra";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";
import plist from "plist";
import { exec } from "child_process";
import os from "os";
import { createRequire } from "module";
import {
  getNestedProperty,
  capitalizeAttributeName,
} from "../utils/helpers.js";

const require = createRequire(import.meta.url);
const tag = require("osx-tag");

async function setFinderTags(filePath, tags) {
  return new Promise((resolve, reject) => {
    tag.setTags(filePath, tags, (err) => {
      if (err) {
        console.error(`Error setting Finder tags for ${filePath}:`, err);
        reject(err);
      } else {
        console.log(`Tags set successfully for ${filePath}.`);
        resolve();
      }
    });
  });
}

export const getPhotosByAlbum = async (req, res) => {
  try {
    const albumUUID = req.params.albumUUID;
    const sortAttribute = req.query.sort || "score.overall";
    const sortOrder = req.query.order || "desc";

    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const dataDir = path.join(__dirname, "..", "data");
    const photosDir = path.join(dataDir, "albums", albumUUID);
    const photosPath = path.join(photosDir, "photos.json");
    const imagesDir = path.join(photosDir, "images");
    const venvDir = path.join(__dirname, "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    await fs.ensureDir(photosDir);
    await fs.ensureDir(imagesDir);

    if (!(await fs.pathExists(photosPath))) {
      // Export photos metadata
      await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
      // Export images with osxphotos (directly uses date/time prefix)
      await runOsxphotosExportImages(
        osxphotosPath,
        albumUUID,
        imagesDir,
        photosPath
      );
    }

    const photosData = await fs.readJson(photosPath);

    // Add 'original_name' property
    photosData.forEach((photo) => {
      photo.original_name = path.parse(photo.original_filename).name;
    });

    const limit = 60;

    const attributesToProcess = [
      { name: "score.overall", order: "desc", limit: limit },
      { name: "score.curation", order: "desc", limit: limit },
      { name: "score.highlight_visibility", order: "desc", limit: limit },
      { name: "score.harmonious_color", order: "desc", limit: limit },
      { name: "score.immersiveness", order: "desc", limit: limit },
      { name: "score.interaction", order: "desc", limit: limit },
      { name: "score.interesting_subject", order: "desc", limit: limit },
      { name: "score.intrusive_object_presence", order: "asc", limit: limit },
      { name: "score.lively_color", order: "desc", limit: limit },
      { name: "score.noise", order: "desc", limit: Math.ceil(limit / 4) },
      { name: "score.pleasant_camera_tilt", order: "desc", limit: limit },
      { name: "score.pleasant_composition", order: "desc", limit: limit },
      { name: "score.pleasant_lighting", order: "desc", limit: limit },
      { name: "score.pleasant_pattern", order: "desc", limit: limit },
      { name: "score.pleasant_perspective", order: "desc", limit: limit },
      { name: "score.pleasant_post_processing", order: "desc", limit: limit },
      { name: "score.pleasant_reflection", order: "desc", limit: limit },
      { name: "score.pleasant_symmetry", order: "desc", limit: limit },
      { name: "score.sharply_focused_subject", order: "desc", limit: limit },
      { name: "score.tastefully_blurred", order: "desc", limit: limit },
      { name: "score.well_chosen_subject", order: "desc", limit: limit },
      { name: "score.well_framed_subject", order: "desc", limit: limit },
      { name: "score.well_timed_shot", order: "desc", limit: limit },
    ];

    const photoTags = {};

    attributesToProcess.forEach(({ name, order, limit }) => {
      const sortedPhotos = [...photosData].sort((a, b) => {
        const aValue = getNestedProperty(a, name);
        const bValue = getNestedProperty(b, name);
        if (aValue === undefined || aValue === null) return 1;
        if (bValue === undefined || bValue === null) return -1;
        return order === "asc" ? aValue - bValue : bValue - aValue;
      });

      const topPhotos = sortedPhotos.slice(0, limit);
      topPhotos.forEach((photo) => {
        if (!photoTags[photo.uuid]) {
          photoTags[photo.uuid] = [];
        }
        const attributeDisplayName = capitalizeAttributeName(name);
        if (!photoTags[photo.uuid].includes(attributeDisplayName)) {
          photoTags[photo.uuid].push(attributeDisplayName);
        }
      });
    });

    photosData.forEach((photo) => {
      photo.tags = photoTags[photo.uuid] || [];
    });

    const scoreAttributes = Object.keys(photosData[0].score);

    // Sort the photos by requested attribute
    photosData.sort((a, b) => {
      const aValue = getNestedProperty(a, sortAttribute);
      const bValue = getNestedProperty(b, sortAttribute);
      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;
      return sortOrder === "asc" ? aValue - bValue : bValue - aValue;
    });

    res.render("index", {
      photos: photosData,
      albumUUID,
      sortAttribute,
      sortOrder,
      scoreAttributes,
    });

    // After rendering, set Finder tags on the exported images
    await setTagsOnExportedImages(imagesDir, photosData);
  } catch (error) {
    console.error("Error fetching photos for album:", error);
    res.status(500).send("Internal Server Error");
  }
};

async function setTagsOnExportedImages(imagesDir, photosData) {
  for (const photo of photosData) {
    const tags = photo.tags || [];
    if (tags.length === 0) continue;

    const countTag = `${tags.length} Tags`;
    tags.push(countTag);

    const imageFileName = `${photo.original_name}.jpg`;
    const imagePath = path.join(imagesDir, imageFileName);

    if (await fs.pathExists(imagePath)) {
      try {
        await setFinderTags(imagePath, tags);
        console.log(`Set tags for ${imageFileName}: ${tags.join(", ")}`);
      } catch (error) {
        console.error(`Error setting tags for ${imageFileName}:`, error);
      }
    } else {
      console.warn(`Image not found: ${imageFileName}`);
    }
  }
}
```

### **./backend/data/albums/240AEA0E-D789-44BB-9BCF-AFCCC122A4EA/photos.json**
```json
[
    {
        "albums": [
            "2025-06-07",
            "2025-06-07 Olympia's Birthday!",
            "2025-06-07 Recently",
            "2025-06-09 Recently",
            "2025-06-14 Recently",
            "2025-06-20 Recently",
            "FUJIFILM X100V-02"
        ],
        "burst": false,
        "cloud_guid": "AbsgxDO0xQI9rVajO3tBZkTCqf2s",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-06-06 23:41:24.109617-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-06-06 16:33:02-05:00",
        "description": null,
...
```

### **./backend/data/albums/240AEA0E-D789-44BB-9BCF-AFCCC122A4EA/photos.json**
```json
[
    {
        "albums": [
            "2025-06-07",
            "2025-06-07 Olympia's Birthday!",
            "2025-06-07 Recently",
            "2025-06-09 Recently",
            "2025-06-14 Recently",
            "2025-06-20 Recently",
            "FUJIFILM X100V-02"
        ],
        "burst": false,
        "cloud_guid": "AbsgxDO0xQI9rVajO3tBZkTCqf2s",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-06-06 23:41:24.109617-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-06-06 16:33:02-05:00",
        "description": null,
...
```

### **./backend/data/albums/0EB23188-CA33-4FDA-BA27-A3B290466224/photos.json**
```json
[
    {
        "albums": [
            "2025-06-14 Recently",
            "Kendell & Mandy's Wedding \u2014 All",
            "Kendell & Mandy's Wedding \u2014 Tyler's Photos",
            "Tyler James (@firsthandaccount)"
        ],
        "burst": false,
        "cloud_guid": "AecEJ3fHgl8rcXzrmlzSFduquoAs",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-06-08 09:12:25.848879-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-05-30 08:52:35.160000-06:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 800,
...
```

### **./backend/data/albums/0EB23188-CA33-4FDA-BA27-A3B290466224/photos.json**
```json
[
    {
        "albums": [
            "2025-06-14 Recently",
            "Kendell & Mandy's Wedding \u2014 All",
            "Kendell & Mandy's Wedding \u2014 Tyler's Photos",
            "Tyler James (@firsthandaccount)"
        ],
        "burst": false,
        "cloud_guid": "AecEJ3fHgl8rcXzrmlzSFduquoAs",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-06-08 09:12:25.848879-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-05-30 08:52:35.160000-06:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 800,
...
```

### **./backend/data/albums/B8F95C71-AF41-47E2-95F5-635AD81101E4/photos.json**
```json
[
    {
        "albums": [
            "2025-06-20",
            "2025-06-20 Recently"
        ],
        "burst": false,
        "cloud_guid": "AT2lRQynuV/E6ash79TaX0Jl5f+E",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-06-20 09:06:56.488953-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-06-15 13:31:51-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 160,
            "metering_mode": 5,
            "sample_rate": null,
...
```

### **./backend/data/albums/B8F95C71-AF41-47E2-95F5-635AD81101E4/photos.json**
```json
### **./backend/data/albums/13F82066-89B7-44D1-B42E-C6D139EDB3EA/photos.json**
```json
[
    {
        "albums": [
            "2025-06-20",
            "2025-06-20 Recently"
        ],
        "burst": false,
        "cloud_guid": "AT2lRQynuV/E6ash79TaX0Jl5f+E",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2025-06-20 09:06:56.488953-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2025-06-15 13:31:51-04:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": 160,
            "metering_mode": 5,
            "sample_rate": null,
...
```

[
    {
        "albums": [
            "Inner Space"
        ],
        "burst": false,
        "cloud_guid": "Aaed7ns2sh3tSO5kS2ThMSfIMwIS",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-06-16 17:09:19.390949-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2019-11-29 11:22:40-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": null,
            "metering_mode": null,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/13F82066-89B7-44D1-B42E-C6D139EDB3EA/photos.json**
```json
[
    {
        "albums": [
            "Inner Space"
        ],
        "burst": false,
        "cloud_guid": "Aaed7ns2sh3tSO5kS2ThMSfIMwIS",
        "cloud_owner_hashed_id": null,
        "comments": [],
        "date_added": "2024-06-16 17:09:19.390949-04:00",
        "date_modified": null,
        "date_trashed": null,
        "date": "2019-11-29 11:22:40-05:00",
        "description": null,
        "exif_info": {
            "flash_fired": false,
            "iso": null,
            "metering_mode": null,
            "sample_rate": null,
            "track_format": null,
...
```

### **./backend/data/albums/A6B54487-D9FC-4F22-981D-3B521EBE2B67/photos.json**
```json
[
    {
        "albums": [
            "2025-04-10 recently",
            "2025-04-15 recently",
            "2025-04-17 recently",
            "2025-04-18 recently",
            "2025-04-19 recently",
            "2025-04-20 recently",
            "2025-04-22 recently",
            "2025-04-23 Past Month",
            "2025-04-23 Spring + Symposia",
            "2025-04-23 recently",
            "2025-05-03 Recently",
            "2025-05-04 Recently",
            "2025-05-05 Recently",
            "2025-05-07 Recently",
            "2025-05-10 Recently",
            "2025-05-15 Recently",
            "2025-05-16 Recently",
...
```

### **./backend/views/albums.hbs**
```
### **./backend/data/albums/A6B54487-D9FC-4F22-981D-3B521EBE2B67/photos.json**
```json
<h1 class="text-3xl font-bold mb-4">Select an Album</h1>

<div class="flex flex-row h-screen">
  <!-- Sidebar -->
  <div
    class="w-64 bg-base-100 border-r border-base-300 h-full overflow-y-auto p-4"
  >
    <ul class="menu w-full">
      {{#each this.model as |album|}}
        <li class="mb-1">
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-base-300"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <div class="flex-1 p-6">
    {{outlet}}
  </div>
</div>```

### **./backend/views/index.hbs**
```
[
    {
        "albums": [
            "2025-04-10 recently",
            "2025-04-15 recently",
            "2025-04-17 recently",
            "2025-04-18 recently",
            "2025-04-19 recently",
            "2025-04-20 recently",
            "2025-04-22 recently",
            "2025-04-23 Past Month",
            "2025-04-23 Spring + Symposia",
            "2025-04-23 recently",
            "2025-05-03 Recently",
            "2025-05-04 Recently",
            "2025-05-05 Recently",
            "2025-05-07 Recently",
            "2025-05-10 Recently",
            "2025-05-15 Recently",
            "2025-05-16 Recently",
...
```

### **./backend/views/albums.hbs**
```
<!-- backend/views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a> | 
<a href="/album/{{albumUUID}}/persons">View People in this Album</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.exported_filename}}"
        alt="{{this.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.exported_filename}}

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<h1 class="text-3xl font-bold mb-4">Select an Album</h1>

<div class="flex flex-row h-screen">
  <!-- Sidebar -->
  <div
    class="w-64 bg-base-100 border-r border-base-300 h-full overflow-y-auto p-4"
  >
    <ul class="menu w-full">
      {{#each this.model as |album|}}
        <li class="mb-1">
          <LinkTo
            @route="albums.album"
            @model={{album.id}}
            class="rounded hover:bg-base-300"
          >
            {{album.title}}
          </LinkTo>
        </li>
      {{/each}}
    </ul>
  </div>

  <div class="flex-1 p-6">
    {{outlet}}
  </div>
</div>```

### **./backend/views/index.hbs**
```
<!-- ./views/layouts/main.hbs -->

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/views/person.hbs**
```
<!-- backend/views/index.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos in Album</h1>
<a href="/">Back to Albums</a> | 
<a href="/album/{{albumUUID}}/persons">View People in this Album</a>

<form method="GET" action="/album/{{albumUUID}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{this.exported_filename}}"
        alt="{{this.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{this.exported_filename}}

        {{#if this.tags}}
          <p class="tags">
            {{#each this.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property this ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/layouts/main.hbs**
```
<!-- ./views/person.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos of {{personName}} in Album</h1>
<a href="/album/{{albumUUID}}/persons">Back to People</a>

<form method="GET" action="/album/{{albumUUID}}/person/{{personName}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{photo.exported_filename}}"
        alt="{{photo.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{photo.exported_filename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property photo ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/persons.hbs**
```
<!-- ./views/layouts/main.hbs -->

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Photo Filter App</title>
    <link rel="stylesheet" href="/stylesheets/css/style.css" />
  </head>
  <body>
    {{{body}}}
  </body>
</html>```

### **./backend/views/person.hbs**
```
<!-- ./views/persons.hbs -->

<h1>People in Album</h1>
<a href="/album/{{albumUUID}}">Back to Album</a>

<ul>
  {{#each people as |person|}}
    <li><a href="/album/{{../albumUUID}}/person/{{person}}">{{person}}</a></li>
  {{/each}}
</ul>```

### **./backend/routes/index.js**
```
<!-- ./views/person.hbs -->
<style>
  img {
    width: 30rem;
    max-width: 100%;
  }

  .tags {
    margin-top: 5px;
  }

  .tag {
    display: inline-block;
    background-color: #eee;
    padding: 2px 5px;
    margin: 2px;
    border-radius: 3px;
    font-size: 0.9em;
  }
</style>
<h1>Photos of {{personName}} in Album</h1>
<a href="/album/{{albumUUID}}/persons">Back to People</a>

<form method="GET" action="/album/{{albumUUID}}/person/{{personName}}">
  <label for="sortAttribute">Sort by:</label>
  <select name="sort" id="sortAttribute">
    {{#each scoreAttributes}}
      <option value="score.{{this}}" {{#if (eq ../sortAttribute (concat "score." this))}}selected{{/if}}>
        {{capitalize this}}
      </option>
    {{/each}}
  </select>

  <label for="sortOrder">Order:</label>
  <select name="order" id="sortOrder">
    <option value="desc" {{#if (eq sortOrder 'desc')}}selected{{/if}}>Descending</option>
    <option value="asc" {{#if (eq sortOrder 'asc')}}selected{{/if}}>Ascending</option>
  </select>

  <button type="submit">Sort</button>
</form>

<div class="photo-grid">
  {{#each photos as |photo|}}
    <div class="photo-item">
      <img
        src="/images/{{../albumUUID}}/{{photo.exported_filename}}"
        alt="{{photo.exported_filename}}"
        loading="lazy"
      />
      <p>
        <span style="opacity: 0.38">{{@index}} -</span> {{photo.exported_filename}}

        {{#if photo.tags}}
          <p class="tags">
            {{#each photo.tags}}
              <span class="tag">{{this}}</span>
            {{/each}}
          </p>
        {{/if}}

        {{capitalize (replace ../sortAttribute "score." "")}}: {{get-nested-property photo ../sortAttribute}}
      </p>
    </div>
  {{/each}}
</div>```

### **./backend/views/persons.hbs**
```
// backend/routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";
import {
  getPeopleInAlbumLegacy,
  getPhotosByPersonLegacy,
} from "../controllers/people-legacy-controller.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// New legacy routes for persons
router.get("/album/:albumUUID/persons", getPeopleInAlbumLegacy);
router.get("/album/:albumUUID/person/:personName", getPhotosByPersonLegacy);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
<!-- ./views/persons.hbs -->

<h1>People in Album</h1>
<a href="/album/{{albumUUID}}">Back to Album</a>

<ul>
  {{#each people as |person|}}
    <li><a href="/album/{{../albumUUID}}/person/{{person}}">{{person}}</a></li>
  {{/each}}
</ul>```

### **./backend/routes/index.js**
```
// backend/routes/api.js

import express from "express";
import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";
import {
  getPeopleInAlbum,
  getPhotosByPerson,
} from "../controllers/api/people-controller.js";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";

// === Import our new time controller
import { getTimeIndex } from "../controllers/api/time-controller.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const apiRouter = express.Router();

// ======================
//   Existing Endpoints
// ======================

// Albums
apiRouter.get("/albums", getAlbumsData);
apiRouter.get("/albums/:albumUUID", getAlbumById);
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

// People
apiRouter.get("/albums/:albumUUID/persons", getPeopleInAlbum);
apiRouter.get("/albums/:albumUUID/person/:personName", getPhotosByPerson);

// ======================
//   TIME-INDEX ENDPOINT
// ======================
apiRouter.get("/time-index", getTimeIndex);

// ======================
//   REFRESH Endpoint
// ======================
apiRouter.post("/albums/:albumUUID/refresh", async (req, res) => {
  try {
    const { albumUUID } = req.params;
    const dataDir = path.join(
      __dirname,
      "..",
      "..",
      "data",
      "albums",
      albumUUID
    );
    const photosPath = path.join(dataDir, "photos.json");
    const imagesDir = path.join(dataDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    if (await fs.pathExists(photosPath)) {
      await fs.remove(photosPath);
    }
    if (await fs.pathExists(imagesDir)) {
      await fs.remove(imagesDir);
    }

    // Re-run python script
    await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
    await runOsxphotosExportImages(
      osxphotosPath,
      albumUUID,
      imagesDir,
      photosPath
    );

    return res.json({
      message: `Album ${albumUUID} metadata and images have been refreshed.`,
    });
  } catch (error) {
    console.error("Error in refresh endpoint:", error);
    res.status(500).json({ errors: [{ detail: error.message }] });
  }
});

export default apiRouter;
```

## Frontend Files

// backend/routes/index.js

import express from "express";
import {
  getAlbums,
  getPhotosByAlbum,
} from "../controllers/photo-controller.js";
import apiRouter from "./api.js";
import {
  getPeopleInAlbumLegacy,
  getPhotosByPersonLegacy,
} from "../controllers/people-legacy-controller.js";

const router = express.Router();

// Existing routes for the legacy UI
router.get("/", getAlbums);
router.get("/album/:albumUUID", getPhotosByAlbum);

// New legacy routes for persons
router.get("/album/:albumUUID/persons", getPeopleInAlbumLegacy);
router.get("/album/:albumUUID/person/:personName", getPhotosByPersonLegacy);

// Mount the API router under '/api'
router.use("/api", apiRouter);

export default router;
```

### **./backend/routes/api.js**
```
### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
// backend/routes/api.js

import express from "express";
import path from "path";
import fs from "fs-extra";
import { fileURLToPath } from "url";
import {
  getAlbumsData,
  getAlbumById,
  getPhotosByAlbumData,
} from "../controllers/api/index.js";
import {
  getPeopleInAlbum,
  getPhotosByPerson,
} from "../controllers/api/people-controller.js";
import { runPythonScript } from "../utils/run-python-script.js";
import { runOsxphotosExportImages } from "../utils/export-images.js";

// === Import our new time controller
import { getTimeIndex } from "../controllers/api/time-controller.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const apiRouter = express.Router();

// ======================
//   Existing Endpoints
// ======================

// Albums
apiRouter.get("/albums", getAlbumsData);
apiRouter.get("/albums/:albumUUID", getAlbumById);
apiRouter.get("/albums/:albumUUID/photos", getPhotosByAlbumData);

// People
apiRouter.get("/albums/:albumUUID/persons", getPeopleInAlbum);
apiRouter.get("/albums/:albumUUID/person/:personName", getPhotosByPerson);

// ======================
//   TIME-INDEX ENDPOINT
// ======================
apiRouter.get("/time-index", getTimeIndex);

// ======================
//   REFRESH Endpoint
// ======================
apiRouter.post("/albums/:albumUUID/refresh", async (req, res) => {
  try {
    const { albumUUID } = req.params;
    const dataDir = path.join(
      __dirname,
      "..",
      "..",
      "data",
      "albums",
      albumUUID
    );
    const photosPath = path.join(dataDir, "photos.json");
    const imagesDir = path.join(dataDir, "images");
    const venvDir = path.join(__dirname, "..", "..", "venv");
    const pythonPath = path.join(venvDir, "bin", "python3");
    const scriptPath = path.join(
      __dirname,
      "..",
      "..",
      "scripts",
      "export_photos_in_album.py"
    );
    const osxphotosPath = path.join(venvDir, "bin", "osxphotos");

    if (await fs.pathExists(photosPath)) {
      await fs.remove(photosPath);
    }
    if (await fs.pathExists(imagesDir)) {
      await fs.remove(imagesDir);
    }

    // Re-run python script
    await runPythonScript(pythonPath, scriptPath, [albumUUID], photosPath);
    await runOsxphotosExportImages(
      osxphotosPath,
      albumUUID,
      imagesDir,
      photosPath
    );

    return res.json({
      message: `Album ${albumUUID} metadata and images have been refreshed.`,
    });
  } catch (error) {
    console.error("Error in refresh endpoint:", error);
    res.status(500).json({ errors: [{ detail: error.message }] });
  }
});

export default apiRouter;
```

## Frontend Files

'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  let app = new EmberApp(defaults, {
    postcssOptions: {
      compile: {
        enabled: true,
        plugins: [
          require('tailwindcss')('./tailwind.config.js'),
          require('autoprefixer'),
        ],
      },
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
### **./frontend/photo-filter-frontend/ember-cli-build.js**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/types/global.d.ts**
```
'use strict';

const EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function (defaults) {
  let app = new EmberApp(defaults, {
    postcssOptions: {
      compile: {
        enabled: true,
        plugins: [
          require('tailwindcss')('./tailwind.config.js'),
          require('autoprefixer'),
        ],
      },
    },
  });

  return app.toTree();
};
```

### **./frontend/photo-filter-frontend/.stylelintrc.js**
```
// Types for compiled templates
declare module 'photo-filter-frontend/templates/*' {
  import { TemplateFactory } from 'htmlbars-inline-precompile';
  const tmpl: TemplateFactory;
  export default tmpl;
}
```

### **./frontend/photo-filter-frontend/types/ember-data/types/registries/model.d.ts**
```
'use strict';

module.exports = {
  extends: ['stylelint-config-standard', 'stylelint-prettier/recommended'],
};
```

### **./frontend/photo-filter-frontend/types/global.d.ts**
```
/**
 * Catch-all for ember-data.
 */
export default interface ModelRegistry {
  [key: string]: any;
}
```

### **./frontend/photo-filter-frontend/types/photo-filter-frontend/index.d.ts**
```
// Types for compiled templates
declare module 'photo-filter-frontend/templates/*' {
  import { TemplateFactory } from 'htmlbars-inline-precompile';
  const tmpl: TemplateFactory;
  export default tmpl;
}
```

### **./frontend/photo-filter-frontend/types/ember-data/types/registries/model.d.ts**
```
import Ember from 'ember';

declare global {
  interface Array<T> extends Ember.ArrayPrototypeExtensions<T> {}
  // interface Function extends Ember.FunctionPrototypeExtensions {}
}

export {};
```

### **./frontend/photo-filter-frontend/tailwind.config.js**
```
/**
 * Catch-all for ember-data.
 */
export default interface ModelRegistry {
  [key: string]: any;
}
```

### **./frontend/photo-filter-frontend/types/photo-filter-frontend/index.d.ts**
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.hbs',
    './app/**/*.js',
    './app/**/*.ts',
    './app/**/*.gjs',
    './app/**/*.gts',
  ],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
};
```

### **./frontend/photo-filter-frontend/app/config/environment.d.ts**
```
import Ember from 'ember';

declare global {
  interface Array<T> extends Ember.ArrayPrototypeExtensions<T> {}
  // interface Function extends Ember.FunctionPrototypeExtensions {}
}

export {};
```

### **./frontend/photo-filter-frontend/tailwind.config.js**
```
export default config;

/**
 * Type declarations for
 *    import config from 'my-app/config/environment'
 */
declare const config: {
  environment: string;
  modulePrefix: string;
  podModulePrefix: string;
  locationType: string;
  rootURL: string;
  APP: Record<string, unknown>;
};
```

### **./frontend/photo-filter-frontend/app/models/person.js**
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.hbs',
    './app/**/*.js',
    './app/**/*.ts',
    './app/**/*.gjs',
    './app/**/*.gts',
  ],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
};
```

### **./frontend/photo-filter-frontend/app/config/environment.d.ts**
```
// frontend/photo-filter-frontend/app/models/person.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class PersonModel extends Model {
  @attr('string') name;
  @hasMany('photo', { async: true, inverse: 'persons' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
export default config;

/**
 * Type declarations for
 *    import config from 'my-app/config/environment'
 */
declare const config: {
  environment: string;
  modulePrefix: string;
  podModulePrefix: string;
  locationType: string;
  rootURL: string;
  APP: Record<string, unknown>;
};
```

### **./frontend/photo-filter-frontend/app/models/person.js**
```
// frontend/photo-filter-frontend/app/models/album.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: false, inverse: 'album' }) photos;
  // Change persons to async: false since we include all data and don't want extra requests
  @hasMany('person', { async: false, inverse: null }) persons;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
// frontend/photo-filter-frontend/app/models/person.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class PersonModel extends Model {
  @attr('string') name;
  @hasMany('photo', { async: true, inverse: 'persons' }) photos;
}
```

### **./frontend/photo-filter-frontend/app/models/album.js**
```
// frontend/photo-filter-frontend/app/models/photo.js
import Model, { attr, belongsTo, hasMany } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr('string') exportedFilename;
  @attr() score;
  @attr() exifInfo;

  @belongsTo('album', { async: false, inverse: 'photos' }) album;
  // Set async: false since we include all persons in the payload
  @hasMany('person', { async: false, inverse: 'photos' }) persons;
}
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
// frontend/photo-filter-frontend/app/models/album.js
import Model, { attr, hasMany } from '@ember-data/model';

export default class AlbumModel extends Model {
  @attr('string') title;
  @attr('boolean') isSmart;
  @hasMany('photo', { async: false, inverse: 'album' }) photos;
  // Change persons to async: false since we include all data and don't want extra requests
  @hasMany('person', { async: false, inverse: null }) persons;
}
```

### **./frontend/photo-filter-frontend/app/models/photo.js**
```
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
// frontend/photo-filter-frontend/app/models/photo.js
import Model, { attr, belongsTo, hasMany } from '@ember-data/model';

export default class PhotoModel extends Model {
  @attr('string') originalName;
  @attr('string') originalFilename;
  @attr('string') filename;
  @attr('string') exportedFilename;
  @attr() score;
  @attr() exifInfo;

  @belongsTo('album', { async: false, inverse: 'photos' }) album;
  // Set async: false since we include all persons in the payload
  @hasMany('person', { async: false, inverse: 'photos' }) persons;
}
```

### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
```

### **./frontend/photo-filter-frontend/app/adapters/application.js**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
import JSONAPIAdapter from '@ember-data/adapter/json-api';
import config from 'photo-filter-frontend/config/environment';

export default class ApplicationAdapter extends JSONAPIAdapter {
  host = config.APP.apiHost || 'http://localhost:3000';
  namespace = 'api';
}
```
```


### **./frontend/photo-filter-frontend/app/adapters/photo.js**
```
### **./frontend/photo-filter-frontend/app/components/photo-grid.hbs**
```
// app/adapters/photo.js

import ApplicationAdapter from './application';

export default class PhotoAdapter extends ApplicationAdapter {
  buildURL(modelName, id, snapshot, requestType, query) {
    // Handle the query for photos by album ID
    if (requestType === 'query' && query && query.album_id) {
      const albumUUID = query.album_id;
      const url = `${this.host}/${this.namespace}/albums/${albumUUID}/photos`;

      // Remove album_id from query params to avoid duplication
      delete query.album_id;

      return url;
    } else {
      return super.buildURL(...arguments);
    }
  }
}
<div class="grid gap-6 sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-2">
  {{#each @photos as |photo index|}}
    <div class="card bg-base-100 shadow-lg">
      <figure>
        <img
          src="{{this.apiHost}}/images/{{@albumUUID}}/{{photo.exportedFilename}}"
          alt="{{photo.exportedFilename}}"
          class="max-w-full h-auto"
        />
      </figure>
      <div class="card-body">
        <h2 class="card-title text-sm">
          <span class="opacity-50">{{index}} -</span>
          {{photo.exportedFilename}}
        </h2>

        {{#if photo.tags}}
          <div class="mt-2 flex flex-wrap gap-2">
            {{#each photo.tags as |tag|}}
              <span class="badge badge-accent badge-outline">{{tag}}</span>
            {{/each}}
          </div>
        {{/if}}

        <p class="mt-2">
          {{capitalize (replace @sortAttribute "score." "")}}:
          {{get-nested-property photo @sortAttribute}}
        </p>
      </div>
    </div>
  {{/each}}
</div>```
```


### **./frontend/photo-filter-frontend/app/components/photo-grid.hbs**
```
### **./frontend/photo-filter-frontend/app/components/time-nav.ts**
```
<div class="grid gap-6 sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-2">
  {{#each @photos as |photo index|}}
    <div class="card bg-base-100 shadow-lg">
      <figure>
        <img
          src="{{this.apiHost}}/images/{{@albumUUID}}/{{photo.exportedFilename}}"
          alt="{{photo.exportedFilename}}"
          class="max-w-full h-auto"
        />
      </figure>
      <div class="card-body">
        <h2 class="card-title text-sm">
          <span class="opacity-50">{{index}} -</span>
          {{photo.exportedFilename}}
        </h2>

        {{#if photo.tags}}
          <div class="mt-2 flex flex-wrap gap-2">
            {{#each photo.tags as |tag|}}
              <span class="badge badge-accent badge-outline">{{tag}}</span>
            {{/each}}
          </div>
        {{/if}}

        <p class="mt-2">
          {{capitalize (replace @sortAttribute "score." "")}}:
          {{get-nested-property photo @sortAttribute}}
        </p>
      </div>
    </div>
  {{/each}}
</div>// frontend/photo-filter-frontend/app/components/time-nav.ts

import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';
import { inject as service } from '@ember/service';
import config from 'photo-filter-frontend/config/environment';
import type RouterService from '@ember/routing/router-service';
import { isArray as emberIsArray } from '@ember/array';

/**
 * Data structure for the time index. Because it’s dynamic JSON,
 * we define an interface that roughly matches: { years: YearObject[] }.
 */
interface TimeIndexData {
  years: YearObject[];
}

interface YearObject {
  year: number;
  months: MonthObject[];
}

interface MonthObject {
  month: number;
  days?: number[];
}

/**
 * This component fetches the time-based index (Year->Month->Day)
 * from /api/time-index, stores it in `this.timeIndex`, and
 * manages a list of `selectedDates` keys.
 */
export default class TimeNavComponent extends Component {
  @service declare router: RouterService;

  /** Raw time index data from the server. We default to null until loaded. */
  @tracked timeIndex: TimeIndexData | null = null;

  /** Flag to show “Loading…” while fetching data. */
  @tracked isLoading = true;

  /** The array of date-keys (like "2024", "2024-12", "2024-12-07") the user has selected. */
  @tracked selectedDates: string[] = [];

  constructor(owner: unknown, args: Record<string, unknown>) {
    super(owner, args);
    this.loadTimeIndex();
  }

  /**
   * Template calls this to see if a certain dateKey is in our selectedDates list.
   * Marked with @action so that Ember properly binds `this`.
   */
  @action
  selectedDatesIncludes(key: string): boolean {
    return this.selectedDates.includes(key);
  }

  /**
   * The main fetch for our /api/time-index resource.
   */
  async loadTimeIndex(): Promise<void> {
    try {
      const response = await fetch(`${config.APP.apiHost}/api/time-index`);
      const data: unknown = await response.json();

      if (!data || typeof data !== 'object') {
        console.warn('Time index response was invalid:', data);
        this.timeIndex = { years: [] };
      } else {
        const typed = data as Partial<TimeIndexData>;
        if (!emberIsArray(typed.years)) {
          console.warn('timeIndex missing "years" array:', data);
          this.timeIndex = { years: [] };
        } else {
          this.timeIndex = { years: typed.years };
        }
      }
    } catch (err) {
      console.error('Error loading time index:', err);
      this.timeIndex = { years: [] };
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * Called by checkboxes in the template to toggle a dateKey in `selectedDates`.
   * Also marked with @action for correct context binding.
   */
  @action
  toggleSelection(dateKey: string): void {
    let updated = [...this.selectedDates];
    if (updated.includes(dateKey)) {
      updated = updated.filter((d) => d !== dateKey);
    } else {
      updated.push(dateKey);
    }
    updated.sort();
    this.selectedDates = updated;

    this.updateQueryParams();
  }

  /**
   * Update the current route's query params to reflect the selected dates.
   */
  updateQueryParams(): void {
    const currentRouteName = this.router.currentRouteName;
    const albumId = this.router.currentRoute.params?.album_id as
      | string
      | undefined;
    const currentQp = this.router.currentRoute.queryParams || {};
    const datesJson = JSON.stringify(this.selectedDates);

    if (albumId) {
      this.router.transitionTo(currentRouteName, albumId, {
        queryParams: {
          ...currentQp,
          dates: datesJson,
        },
      });
    } else {
      this.router.transitionTo(currentRouteName, {
        queryParams: {
          ...currentQp,
          dates: datesJson,
        },
      });
    }
  }

  /**
   * Helper for building date keys: "YYYY", "YYYY-MM", or "YYYY-MM-DD".
   */
  buildDateKey(year: number, month?: number, day?: number): string {
    if (day !== undefined) {
      // e.g. "2025-12-31"
      return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    } else if (month !== undefined) {
      // e.g. "2025-12"
      return `${year}-${String(month).padStart(2, '0')}`;
    } else {
      // e.g. "2025"
      return String(year);
    }
  }
}
```

```
### **./frontend/photo-filter-frontend/app/components/photo-grid.js**

```
### **./frontend/photo-filter-frontend/app/components/time-nav.ts**
```
import Component from '@glimmer/component';
import config from 'photo-filter-frontend/config/environment';

/**
 * PhotoGrid Component
 *
 * Arguments:
 * - @photos: An array of photo objects.
 * - @albumUUID: The album's UUID for constructing image URLs.
 * - @sortAttribute: The current sorting attribute to display values for.
 */
export default class PhotoGridComponent extends Component {
  get apiHost() {
    return config.APP.apiHost;
  }
}
// frontend/photo-filter-frontend/app/components/time-nav.ts

import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';
import { inject as service } from '@ember/service';
import config from 'photo-filter-frontend/config/environment';
import type RouterService from '@ember/routing/router-service';
import { isArray as emberIsArray } from '@ember/array';

/**
 * Data structure for the time index. Because it’s dynamic JSON,
 * we define an interface that roughly matches: { years: YearObject[] }.
 */
interface TimeIndexData {
  years: YearObject[];
}

interface YearObject {
  year: number;
  months: MonthObject[];
}

interface MonthObject {
  month: number;
  days?: number[];
}

/**
 * This component fetches the time-based index (Year->Month->Day)
 * from /api/time-index, stores it in `this.timeIndex`, and
 * manages a list of `selectedDates` keys.
 */
export default class TimeNavComponent extends Component {
  @service declare router: RouterService;

  /** Raw time index data from the server. We default to null until loaded. */
  @tracked timeIndex: TimeIndexData | null = null;

  /** Flag to show “Loading…” while fetching data. */
  @tracked isLoading = true;

  /** The array of date-keys (like "2024", "2024-12", "2024-12-07") the user has selected. */
  @tracked selectedDates: string[] = [];

  constructor(owner: unknown, args: Record<string, unknown>) {
    super(owner, args);
    this.loadTimeIndex();
  }

  /**
   * Template calls this to see if a certain dateKey is in our selectedDates list.
   * Marked with @action so that Ember properly binds `this`.
   */
  @action
  selectedDatesIncludes(key: string): boolean {
    return this.selectedDates.includes(key);
  }

  /**
   * The main fetch for our /api/time-index resource.
   */
  async loadTimeIndex(): Promise<void> {
    try {
      const response = await fetch(`${config.APP.apiHost}/api/time-index`);
      const data: unknown = await response.json();

      if (!data || typeof data !== 'object') {
        console.warn('Time index response was invalid:', data);
        this.timeIndex = { years: [] };
      } else {
        const typed = data as Partial<TimeIndexData>;
        if (!emberIsArray(typed.years)) {
          console.warn('timeIndex missing "years" array:', data);
          this.timeIndex = { years: [] };
        } else {
          this.timeIndex = { years: typed.years };
        }
      }
    } catch (err) {
      console.error('Error loading time index:', err);
      this.timeIndex = { years: [] };
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * Called by checkboxes in the template to toggle a dateKey in `selectedDates`.
   * Also marked with @action for correct context binding.
   */
  @action
  toggleSelection(dateKey: string): void {
    let updated = [...this.selectedDates];
    if (updated.includes(dateKey)) {
      updated = updated.filter((d) => d !== dateKey);
    } else {
      updated.push(dateKey);
    }
    updated.sort();
    this.selectedDates = updated;

    this.updateQueryParams();
  }

  /**
   * Update the current route's query params to reflect the selected dates.
   */
  updateQueryParams(): void {
    const currentRouteName = this.router.currentRouteName;
    const albumId = this.router.currentRoute.params?.album_id as
      | string
      | undefined;
    const currentQp = this.router.currentRoute.queryParams || {};
    const datesJson = JSON.stringify(this.selectedDates);

    if (albumId) {
      this.router.transitionTo(currentRouteName, albumId, {
        queryParams: {
          ...currentQp,
          dates: datesJson,
        },
      });
    } else {
      this.router.transitionTo(currentRouteName, {
        queryParams: {
          ...currentQp,
          dates: datesJson,
        },
      });
    }
  }

  /**
   * Helper for building date keys: "YYYY", "YYYY-MM", or "YYYY-MM-DD".
   */
  buildDateKey(year: number, month?: number, day?: number): string {
    if (day !== undefined) {
      // e.g. "2025-12-31"
      return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
    } else if (month !== undefined) {
      // e.g. "2025-12"
      return `${year}-${String(month).padStart(2, '0')}`;
    } else {
      // e.g. "2025"
      return String(year);
    }
  }
}
```
```


### **./frontend/photo-filter-frontend/app/components/time-nav.hbs**
```
### **./frontend/photo-filter-frontend/app/components/photo-grid.js**
```
import Component from '@glimmer/component';
import config from 'photo-filter-frontend/config/environment';

/**
 * PhotoGrid Component
 *
 * Arguments:
 * - @photos: An array of photo objects.
 * - @albumUUID: The album's UUID for constructing image URLs.
 * - @sortAttribute: The current sorting attribute to display values for.
 */
export default class PhotoGridComponent extends Component {
  get apiHost() {
    return config.APP.apiHost;
  }
}
{{! frontend/photo-filter-frontend/app/components/time-nav.hbs }}
<div class="time-nav p-2 border border-gray-200 rounded">
  <h2 class="font-bold mb-2">Time</h2>

  {{#if this.isLoading}}
    <p>Loading time index...</p>
  {{else if this.timeIndex}}
    {{#if (and (eq (type-of this.timeIndex) "object") this.timeIndex.years)}}
      {{#if (is-array this.timeIndex.years)}}
        {{#if (gt this.timeIndex.years.length 0)}}
          {{! Loop over all years }}
          {{#each this.timeIndex.years as |yearObj|}}
            {{#if (and (eq (type-of yearObj) "object") yearObj.year)}}
              {{#let (this.buildDateKey yearObj.year) as |yearKey|}}
                <div class="mb-2">
                  <label>
                    <input
                      type="checkbox"
                      checked={{this.selectedDatesIncludes yearKey}}
                      {{on "change" (fn this.toggleSelection yearKey)}}
                    />
                    <strong>{{yearObj.year}}</strong>
                  </label>

                  {{#if
                    (and
                      (eq (type-of yearObj.months) "array")
                      (gt yearObj.months.length 0)
                    )
                  }}
                    <div class="ml-4 mt-1">
                      {{#each yearObj.months as |monthObj|}}
                        {{#if
                          (and (eq (type-of monthObj) "object") monthObj.month)
                        }}
                          {{#let
                            (this.buildDateKey yearObj.year monthObj.month)
                            as |monthKey|
                          }}
                            <div class="mb-1">
                              <label>
                                <input
                                  type="checkbox"
                                  checked={{this.selectedDatesIncludes
                                    monthKey
                                  }}
                                  {{on
                                    "change"
                                    (fn this.toggleSelection monthKey)
                                  }}
                                />
                                Month
                                {{monthObj.month}}
                              </label>

                              {{#if
                                (and
                                  (eq (type-of monthObj.days) "array")
                                  (gt monthObj.days.length 0)
                                )
                              }}
                                <div class="ml-5 mt-1">
                                  {{#each monthObj.days as |dayNumber|}}
                                    {{#let
                                      (this.buildDateKey
                                        yearObj.year monthObj.month dayNumber
                                      )
                                      as |dayKey|
                                    }}
                                      <label class="mr-2">
                                        <input
                                          type="checkbox"
                                          checked={{this.selectedDatesIncludes
                                            dayKey
                                          }}
                                          {{on
                                            "change"
                                            (fn this.toggleSelection dayKey)
                                          }}
                                        />
                                        {{dayNumber}}
                                      </label>
                                    {{/let}}
                                  {{/each}}
                                </div>
                              {{else}}
                                <p class="text-sm opacity-50 ml-5">
                                  No valid day array for month
                                  {{monthObj.month}}
                                </p>
                              {{/if}}
                            </div>
                          {{/let}}
                        {{/if}}
                      {{/each}}
                    </div>
                  {{else}}
                    <p class="text-sm opacity-50 ml-4">
                      No months found for year
                      {{yearObj.year}}
                    </p>
                  {{/if}}
                </div>
              {{/let}}
            {{/if}}
          {{/each}}
        {{else}}
          <p>No items: <code>timeIndex.years</code> array is empty.</p>
        {{/if}}
      {{else}}
        <p><code>timeIndex.years</code> is not an array.</p>
      {{/if}}
    {{else}}
      <p>timeIndex is missing a
        <code>years</code>
        array or is not an object.</p>
    {{/if}}
  {{else}}
    <p>No time data found.</p>
  {{/if}}
</div>```
```


### **./frontend/photo-filter-frontend/app/components/time-nav.hbs**
```
### **./frontend/photo-filter-frontend/app/router.js**
```
{{! frontend/photo-filter-frontend/app/components/time-nav.hbs }}
<div class="time-nav p-2 border border-gray-200 rounded">
  <h2 class="font-bold mb-2">Time</h2>

  {{#if this.isLoading}}
    <p>Loading time index...</p>
  {{else if this.timeIndex}}
    {{#if (and (eq (type-of this.timeIndex) "object") this.timeIndex.years)}}
      {{#if (is-array this.timeIndex.years)}}
        {{#if (gt this.timeIndex.years.length 0)}}
          {{! Loop over all years }}
          {{#each this.timeIndex.years as |yearObj|}}
            {{#if (and (eq (type-of yearObj) "object") yearObj.year)}}
              {{#let (this.buildDateKey yearObj.year) as |yearKey|}}
                <div class="mb-2">
                  <label>
                    <input
                      type="checkbox"
                      checked={{this.selectedDatesIncludes yearKey}}
                      {{on "change" (fn this.toggleSelection yearKey)}}
                    />
                    <strong>{{yearObj.year}}</strong>
                  </label>

                  {{#if
                    (and
                      (eq (type-of yearObj.months) "array")
                      (gt yearObj.months.length 0)
                    )
                  }}
                    <div class="ml-4 mt-1">
                      {{#each yearObj.months as |monthObj|}}
                        {{#if
                          (and (eq (type-of monthObj) "object") monthObj.month)
                        }}
                          {{#let
                            (this.buildDateKey yearObj.year monthObj.month)
                            as |monthKey|
                          }}
                            <div class="mb-1">
                              <label>
                                <input
                                  type="checkbox"
                                  checked={{this.selectedDatesIncludes
                                    monthKey
                                  }}
                                  {{on
                                    "change"
                                    (fn this.toggleSelection monthKey)
                                  }}
                                />
                                Month
                                {{monthObj.month}}
                              </label>

                              {{#if
                                (and
                                  (eq (type-of monthObj.days) "array")
                                  (gt monthObj.days.length 0)
                                )
                              }}
                                <div class="ml-5 mt-1">
                                  {{#each monthObj.days as |dayNumber|}}
                                    {{#let
                                      (this.buildDateKey
                                        yearObj.year monthObj.month dayNumber
                                      )
                                      as |dayKey|
                                    }}
                                      <label class="mr-2">
                                        <input
                                          type="checkbox"
                                          checked={{this.selectedDatesIncludes
                                            dayKey
                                          }}
                                          {{on
                                            "change"
                                            (fn this.toggleSelection dayKey)
                                          }}
                                        />
                                        {{dayNumber}}
                                      </label>
                                    {{/let}}
                                  {{/each}}
                                </div>
                              {{else}}
                                <p class="text-sm opacity-50 ml-5">
                                  No valid day array for month
                                  {{monthObj.month}}
                                </p>
                              {{/if}}
                            </div>
                          {{/let}}
                        {{/if}}
                      {{/each}}
                    </div>
                  {{else}}
                    <p class="text-sm opacity-50 ml-4">
                      No months found for year
                      {{yearObj.year}}
                    </p>
                  {{/if}}
                </div>
              {{/let}}
            {{/if}}
          {{/each}}
        {{else}}
          <p>No items: <code>timeIndex.years</code> array is empty.</p>
        {{/if}}
      {{else}}
        <p><code>timeIndex.years</code> is not an array.</p>
      {{/if}}
    {{else}}
      <p>timeIndex is missing a
        <code>years</code>
        array or is not an object.</p>
    {{/if}}
  {{else}}
    <p>No time data found.</p>
  {{/if}}
</div>import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });
});
```
```


### **./frontend/photo-filter-frontend/app/router.js**
### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
```
import EmberRouter from '@ember/routing/router';
import config from 'photo-filter-frontend/config/environment';

export default class Router extends EmberRouter {
  location = config.locationType;
  rootURL = config.rootURL;
}

Router.map(function () {
  this.route('albums', function () {
    this.route('album', { path: '/:album_id' });
  });
});
<h1 class="text-2xl font-bold mb-4">Albums Route</h1>
{{outlet}}```

```
### **./frontend/photo-filter-frontend/app/templates/index.hbs**

```
### **./frontend/photo-filter-frontend/app/templates/albums.hbs**
```
<h1 class="text-2xl font-bold mb-4">Albums Route</h1>
{{outlet}}<h2>Welcome to Photo Filter!</h2>
<p>Use the left nav to explore by Time or Albums.</p>```

### **./frontend/photo-filter-frontend/app/templates/index.hbs**
```
```

### **./frontend/photo-filter-frontend/app/templates/application.hbs**
```
<h2>Welcome to Photo Filter!</h2>
<p>Use the left nav to explore by Time or Albums.</p>{{page-title "PhotoFilterFrontend"}}

<div
  class="h-screen w-screen overflow-hidden bg-base-200 text-base-content relative"
>
  <!-- Fixed top nav -->
  <nav
    class="fixed top-0 left-0 right-0 h-16 z-50 bg-base-100 shadow flex items-center px-4 justify-between"
  >
    <a class="btn btn-ghost normal-case text-xl" href="/">Photo Filter</a>

    {{#if this.currentAlbum.isAlbumRoute}}
      <div class="flex items-center space-x-4">
        <!-- Current album title (if any) -->
        <h2 class="text-lg font-semibold">{{this.currentAlbum.albumTitle}}</h2>

        <!-- Sorting Options -->
        <div class="flex items-center space-x-2">
          <div class="form-control">
            <label class="label text-sm font-semibold">Sort by</label>
            <select
              id="sortAttribute"
              class="select select-xs select-bordered"
              {{on "change" (fn this.updateSortAttribute)}}
            >
              {{#each this.currentAlbum.scoreAttributes as |attribute|}}
                <option
                  value="score.{{attribute}}"
                  selected={{eq
                    this.currentAlbum.sortAttribute
                    (concat "score." attribute)
                  }}
                >
                  {{capitalize attribute}}
                </option>
              {{/each}}
            </select>
          </div>

          <div class="form-control">
            <label class="label text-sm font-semibold">Order</label>
            <select
              id="sortOrder"
              class="select select-xs select-bordered"
              {{on "change" (fn this.updateSortOrder)}}
            >
              <option
                value="desc"
                selected={{eq this.currentAlbum.sortOrder "desc"}}
              >
                Descending
              </option>
              <option
                value="asc"
                selected={{eq this.currentAlbum.sortOrder "asc"}}
              >
                Ascending
              </option>
            </select>
          </div>
        </div>
      </div>
    {{/if}}
  </nav>

  <!-- Main layout: side nav + main content -->
  <div class="h-full w-full pt-16 flex">
    <!-- Left nav area (always visible) -->
    <div
      class="w-64 bg-gray-100 border-r border-gray-300 h-full overflow-auto p-4"
    >
      {{! Time navigation }}
      <TimeNav />

      {{! Albums list: from application route model }}
      <h3 class="text-lg font-semibold mb-2 mt-4">Albums</h3>
      <ul class="menu p-0 w-full mb-4">
        {{#each this.model as |album|}}
          <li class="mb-1">
            <LinkTo
              @route="albums.album"
              @model={{album.id}}
              class="rounded hover:bg-gray-200 px-2 py-1"
            >
              {{album.title}}
            </LinkTo>
          </li>
        {{/each}}
      </ul>
    </div>

    <!-- Main content outlet -->
    <div id="main-content-area" class="flex-1 overflow-auto p-4">
      {{outlet}}
    </div>
  </div>
</div>```
```


### **./frontend/photo-filter-frontend/app/templates/application.hbs**
### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
```
{{page-title "PhotoFilterFrontend"}}

<div
  class="h-screen w-screen overflow-hidden bg-base-200 text-base-content relative"
>
  <!-- Fixed top nav -->
  <nav
    class="fixed top-0 left-0 right-0 h-16 z-50 bg-base-100 shadow flex items-center px-4 justify-between"
  >
    <a class="btn btn-ghost normal-case text-xl" href="/">Photo Filter</a>

    {{#if this.currentAlbum.isAlbumRoute}}
      <div class="flex items-center space-x-4">
        <!-- Current album title (if any) -->
        <h2 class="text-lg font-semibold">{{this.currentAlbum.albumTitle}}</h2>

        <!-- Sorting Options -->
        <div class="flex items-center space-x-2">
          <div class="form-control">
            <label class="label text-sm font-semibold">Sort by</label>
            <select
              id="sortAttribute"
              class="select select-xs select-bordered"
              {{on "change" (fn this.updateSortAttribute)}}
            >
              {{#each this.currentAlbum.scoreAttributes as |attribute|}}
                <option
                  value="score.{{attribute}}"
                  selected={{eq
                    this.currentAlbum.sortAttribute
                    (concat "score." attribute)
                  }}
                >
                  {{capitalize attribute}}
                </option>
              {{/each}}
            </select>
          </div>

          <div class="form-control">
            <label class="label text-sm font-semibold">Order</label>
            <select
              id="sortOrder"
              class="select select-xs select-bordered"
              {{on "change" (fn this.updateSortOrder)}}
            >
              <option
                value="desc"
                selected={{eq this.currentAlbum.sortOrder "desc"}}
              >
                Descending
              </option>
              <option
                value="asc"
                selected={{eq this.currentAlbum.sortOrder "asc"}}
              >
                Ascending
              </option>
            </select>
          </div>
        </div>
      </div>
    {{/if}}
  </nav>

  <!-- Main layout: side nav + main content -->
  <div class="h-full w-full pt-16 flex">
    <!-- Left nav area (always visible) -->
    <div
      class="w-64 bg-gray-100 border-r border-gray-300 h-full overflow-auto p-4"
    >
      {{! Time navigation }}
      <TimeNav />

      {{! Albums list: from application route model }}
      <h3 class="text-lg font-semibold mb-2 mt-4">Albums</h3>
      <ul class="menu p-0 w-full mb-4">
        {{#each this.model as |album|}}
          <li class="mb-1">
            <LinkTo
              @route="albums.album"
              @model={{album.id}}
              class="rounded hover:bg-gray-200 px-2 py-1"
            >
              {{album.title}}
            </LinkTo>
          </li>
        {{/each}}
      </ul>
    </div>

    <!-- Main content outlet -->
    <div id="main-content-area" class="flex-1 overflow-auto p-4">
      {{outlet}}
    </div>
  </div>
</div><div class="flex justify-center mb-4 flex-wrap gap-2">
  {{#each this.model.persons as |person|}}
    <button
      type="button"
      class="btn btn-xs rounded-full normal-case
        {{if
          (contains person this.persons)
          'btn-primary text-white'
          'btn-outline text-gray-600'
        }}"
      {{on "click" (fn this.togglePerson person)}}
    >
      {{person}}
    </button>
  {{/each}}
</div>

<!-- Remove the did-update modifier -->
<div>
  <PhotoGrid
    @photos={{this.visiblePhotos}}
    @albumUUID={{this.model.albumUUID}}
    @sortAttribute={{this.sort}}
  />
</div>```

### **./frontend/photo-filter-frontend/app/templates/albums/album.hbs**
```
```

### **./frontend/photo-filter-frontend/app/controllers/application.js**
```
<div class="flex justify-center mb-4 flex-wrap gap-2">
  {{#each this.model.persons as |person|}}
    <button
      type="button"
      class="btn btn-xs rounded-full normal-case
        {{if
          (contains person this.persons)
          'btn-primary text-white'
          'btn-outline text-gray-600'
        }}"
      {{on "click" (fn this.togglePerson person)}}
    >
      {{person}}
    </button>
  {{/each}}
</div>

<!-- Remove the did-update modifier -->
<div>
  <PhotoGrid
    @photos={{this.visiblePhotos}}
    @albumUUID={{this.model.albumUUID}}
    @sortAttribute={{this.sort}}
  />
</div>import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';

export default class ApplicationController extends Controller {
  @service router;
  @service currentAlbum;

  @action
  updateSortAttribute(event) {
    const newSort = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: newSort,
              order: this.currentAlbum.sortOrder,
            },
          },
        );
      }
    }
  }

  @action
  updateSortOrder(event) {
    const newOrder = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: this.currentAlbum.sortAttribute,
              order: newOrder,
            },
          },
        );
      }
    }
  }
}
```
```


### **./frontend/photo-filter-frontend/app/controllers/application.js**
### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
```
import Controller from '@ember/controller';
import { inject as service } from '@ember/service';
import { action } from '@ember/object';

export default class ApplicationController extends Controller {
  @service router;
  @service currentAlbum;

  @action
  updateSortAttribute(event) {
    const newSort = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: newSort,
              order: this.currentAlbum.sortOrder,
            },
          },
        );
      }
    }
  }

  @action
  updateSortOrder(event) {
    const newOrder = event.target.value;
    if (this.currentAlbum.isAlbumRoute) {
      const routeName = 'albums.album';
      const currentRoute = this.router.currentRouteName;
      if (currentRoute.startsWith('albums.album')) {
        this.router.transitionTo(
          routeName,
          this.router.currentRoute.params.album_id,
          {
            queryParams: {
              sort: this.currentAlbum.sortAttribute,
              order: newOrder,
            },
          },
        );
      }
    }
  }
}
// frontend/photo-filter-frontend/app/controllers/albums/album.js

import Controller from '@ember/controller';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumController extends Controller {
  @service router;

  // Sorting & Filtering
  @tracked sort = 'score.overall';
  @tracked order = 'desc';
  @tracked persons = [];
  @tracked dates = [];

  // Pagination
  @tracked page = 1;
  pageSize = 50;

  get allPhotos() {
    if (!this.model.isDataReady || !Array.isArray(this.model.photos)) {
      return [];
    }
    return this.model.photos;
  }

  /**
   * Return *all* photos after applying date filtering, person filtering, and sorting,
   * but before pagination.
   */
  get filteredSortedPhotos() {
    let photos = this.allPhotos.slice();

    // 1. Date-based filtering if `dates` is non-empty
    if (this.dates.length > 0) {
      photos = photos.filter((photo) => this.matchesAnySelectedDate(photo));
    }

    // 2. Person-based filtering
    if (this.persons.length > 0) {
      photos = photos.filter((photo) => {
        let photoPersonNames = photo.persons.map((p) => p.name);
        return this.persons.every((personName) =>
          photoPersonNames.includes(personName),
        );
      });
    }

    // 3. Sort by attribute
    photos.sort((a, b) => {
      const aValue = this.getNested(a, this.sort);
      const bValue = this.getNested(b, this.sort);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return this.order === 'asc' ? aValue - bValue : bValue - aValue;
    });

    return photos;
  }

  get visiblePhotos() {
    const startIndex = (this.page - 1) * this.pageSize;
    const endIndex = this.page * this.pageSize;
    return this.filteredSortedPhotos.slice(startIndex, endIndex);
  }

  /**
   * Parse the photo's date to see if it matches any of the selected date-keys:
   *   - "YYYY"
   *   - "YYYY-MM"
   *   - "YYYY-MM-DD"
   */
  matchesAnySelectedDate(photo) {
    if (!photo.exifInfo && !photo.score) {
      return false; // minimal fallback
    }
    let dateStr = photo.date; // e.g. "2024-12-07 15:30:00-05:00"
    let dObj = new Date(dateStr);
    if (isNaN(dObj.getTime())) {
      return false;
    }
    const y = dObj.getFullYear();
    const m = String(dObj.getMonth() + 1).padStart(2, '0');
    const d = String(dObj.getDate()).padStart(2, '0');

    // e.g. "2024", "2024-12", "2024-12-07"
    const yearKey = `${y}`;
    const yearMonthKey = `${y}-${m}`;
    const fullDayKey = `${y}-${m}-${d}`;

    // If ANY of these matches is in this.dates, we pass
    if (this.dates.includes(yearKey)) {
      return true;
    }
    if (this.dates.includes(yearMonthKey)) {
      return true;
    }
    if (this.dates.includes(fullDayKey)) {
      return true;
    }
    return false;
  }

  getNested(obj, path) {
    return path.split('.').reduce((acc, part) => acc && acc[part], obj);
  }

  // Person toggles, etc. remain the same
  @action
  togglePerson(personName) {
    let selected = [...this.persons];
    if (selected.includes(personName)) {
      selected = selected.filter((p) => p !== personName);
    } else {
      selected.push(personName);
    }
    this.persons = selected;
    this.page = 1;

    this.updateQueryParams();
  }

  @action
  updateSortAttribute(event) {
    this.sort = event.target.value;
    this.page = 1;
    this.updateQueryParams();
  }

  @action
  updateSortOrder(event) {
    this.order = event.target.value;
    this.page = 1;
    this.updateQueryParams();
  }

  updateQueryParams() {
    let currentRoute = this.router.currentRouteName;
    let albumId = this.router.currentRoute.params.album_id;
    let queryParams = {
      sort: this.sort,
      order: this.order,
      persons: this.persons,
      dates: this.dates,
    };

    this.router.transitionTo(currentRoute, albumId, { queryParams });
  }
}
```

### **./frontend/photo-filter-frontend/app/controllers/albums/album.js**
```
```

### **./frontend/photo-filter-frontend/app/routes/index.js**
```
// frontend/photo-filter-frontend/app/controllers/albums/album.js

import Controller from '@ember/controller';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumController extends Controller {
  @service router;

  // Sorting & Filtering
  @tracked sort = 'score.overall';
  @tracked order = 'desc';
  @tracked persons = [];
  @tracked dates = [];

  // Pagination
  @tracked page = 1;
  pageSize = 50;

  get allPhotos() {
    if (!this.model.isDataReady || !Array.isArray(this.model.photos)) {
      return [];
    }
    return this.model.photos;
  }

  /**
   * Return *all* photos after applying date filtering, person filtering, and sorting,
   * but before pagination.
   */
  get filteredSortedPhotos() {
    let photos = this.allPhotos.slice();

    // 1. Date-based filtering if `dates` is non-empty
    if (this.dates.length > 0) {
      photos = photos.filter((photo) => this.matchesAnySelectedDate(photo));
    }

    // 2. Person-based filtering
    if (this.persons.length > 0) {
      photos = photos.filter((photo) => {
        let photoPersonNames = photo.persons.map((p) => p.name);
        return this.persons.every((personName) =>
          photoPersonNames.includes(personName),
        );
      });
    }

    // 3. Sort by attribute
    photos.sort((a, b) => {
      const aValue = this.getNested(a, this.sort);
      const bValue = this.getNested(b, this.sort);

      if (aValue === undefined || aValue === null) return 1;
      if (bValue === undefined || bValue === null) return -1;

      return this.order === 'asc' ? aValue - bValue : bValue - aValue;
    });

    return photos;
  }

  get visiblePhotos() {
    const startIndex = (this.page - 1) * this.pageSize;
    const endIndex = this.page * this.pageSize;
    return this.filteredSortedPhotos.slice(startIndex, endIndex);
  }

  /**
   * Parse the photo's date to see if it matches any of the selected date-keys:
   *   - "YYYY"
   *   - "YYYY-MM"
   *   - "YYYY-MM-DD"
   */
  matchesAnySelectedDate(photo) {
    if (!photo.exifInfo && !photo.score) {
      return false; // minimal fallback
    }
    let dateStr = photo.date; // e.g. "2024-12-07 15:30:00-05:00"
    let dObj = new Date(dateStr);
    if (isNaN(dObj.getTime())) {
      return false;
    }
    const y = dObj.getFullYear();
    const m = String(dObj.getMonth() + 1).padStart(2, '0');
    const d = String(dObj.getDate()).padStart(2, '0');

    // e.g. "2024", "2024-12", "2024-12-07"
    const yearKey = `${y}`;
    const yearMonthKey = `${y}-${m}`;
    const fullDayKey = `${y}-${m}-${d}`;

    // If ANY of these matches is in this.dates, we pass
    if (this.dates.includes(yearKey)) {
      return true;
    }
    if (this.dates.includes(yearMonthKey)) {
      return true;
    }
    if (this.dates.includes(fullDayKey)) {
      return true;
    }
    return false;
  }

  getNested(obj, path) {
    return path.split('.').reduce((acc, part) => acc && acc[part], obj);
  }

  // Person toggles, etc. remain the same
  @action
  togglePerson(personName) {
    let selected = [...this.persons];
    if (selected.includes(personName)) {
      selected = selected.filter((p) => p !== personName);
    } else {
      selected.push(personName);
    }
    this.persons = selected;
    this.page = 1;

    this.updateQueryParams();
  }

  @action
  updateSortAttribute(event) {
    this.sort = event.target.value;
    this.page = 1;
    this.updateQueryParams();
  }

  @action
  updateSortOrder(event) {
    this.order = event.target.value;
    this.page = 1;
    this.updateQueryParams();
  }

  updateQueryParams() {
    let currentRoute = this.router.currentRouteName;
    let albumId = this.router.currentRoute.params.album_id;
    let queryParams = {
      sort: this.sort,
      order: this.order,
      persons: this.persons,
      dates: this.dates,
    };

    this.router.transitionTo(currentRoute, albumId, { queryParams });
  }
}
// frontend/photo-filter-frontend/app/routes/index.js

import Route from '@ember/routing/route';

export default class IndexRoute extends Route {
  // No redirect now, so the user stays at '/'
  // (Add a template if you want a custom landing page.)
}
```
```


### **./frontend/photo-filter-frontend/app/routes/albums.js**
### **./frontend/photo-filter-frontend/app/routes/index.js**
```
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
// frontend/photo-filter-frontend/app/routes/index.js

import Route from '@ember/routing/route';

export default class IndexRoute extends Route {
  // No redirect now, so the user stays at '/'
  // (Add a template if you want a custom landing page.)
}
```

```
### **./frontend/photo-filter-frontend/app/routes/application.js**

```
### **./frontend/photo-filter-frontend/app/routes/albums.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  @service store;

  async model() {
    // Fetch all albums so we can display them in the universal sidebar
    return this.store.findAll('album');
  }
}
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsRoute extends Route {
  @service store;

  async model() {
    return this.store.findAll('album');
  }
}
```

```
### **./frontend/photo-filter-frontend/app/routes/albums/album.js**

```
### **./frontend/photo-filter-frontend/app/routes/application.js**
```
// frontend/photo-filter-frontend/app/routes/albums/album.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;
  @service currentAlbum;

  // We add `dates` to the recognized queryParams
  queryParams = {
    sort: {},
    order: {},
    persons: {
      serialize(value) {
        return JSON.stringify(value);
      },
      deserialize(value) {
        if (typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch {
            return [];
          }
        }
        return value || [];
      },
    },
    dates: {
      serialize(value) {
        return JSON.stringify(value);
      },
      deserialize(value) {
        if (typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch {
            return [];
          }
        }
        return value || [];
      },
    },
  };

  async model(params) {
    const {
      album_id,
      sort = 'score.overall',
      order = 'desc',
      persons = [],
      dates = [],
    } = params;

    const album = await this.store.findRecord('album', album_id, {
      include: 'persons',
      reload: true,
    });

    const loadedPersons = album.persons;
    const allPersons = loadedPersons.map((p) => p.name);

    const allPhotos = await this.store.query('photo', { album_id });

    let scoreAttributes = [];
    if (allPhotos.meta?.scoreAttributes) {
      scoreAttributes = allPhotos.meta.scoreAttributes;
    } else if (allPhotos.length > 0 && allPhotos.firstObject.score) {
      scoreAttributes = Object.keys(allPhotos.firstObject.score);
    }

    // Sort persons by frequency
    const personCountMap = {};
    allPhotos.forEach((photo) => {
      photo.persons.forEach((p) => {
        personCountMap[p.name] = (personCountMap[p.name] || 0) + 1;
      });
    });
    const sortedAllPersons = allPersons.sort((a, b) => {
      const countA = personCountMap[a] || 0;
      const countB = personCountMap[b] || 0;
      if (countB !== countA) return countB - countA;
      return a.localeCompare(b);
    });

    this.currentAlbum.isAlbumRoute = true;
    this.currentAlbum.albumTitle = album.title;
    this.currentAlbum.scoreAttributes = scoreAttributes;
    this.currentAlbum.sortAttribute = sort;
    this.currentAlbum.sortOrder = order;

    const isDataReady = true;
    return {
      album,
      photos: allPhotos,
      albumUUID: allPhotos.meta?.albumUUID || album_id,
      sortAttribute: sort,
      sortOrder: order,
      scoreAttributes,
      persons: sortedAllPersons,
      selectedPersons: persons,
      selectedDates: dates,
      isDataReady,
    };
  }

  resetController(controller, isExiting) {
    super.resetController(...arguments);
    if (isExiting) {
      this.currentAlbum.isAlbumRoute = false;
      this.currentAlbum.albumTitle = null;
      this.currentAlbum.scoreAttributes = [];
      this.currentAlbum.sortAttribute = 'score.overall';
      this.currentAlbum.sortOrder = 'desc';
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/eq.js**
```
import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class ApplicationRoute extends Route {
  @service store;

  async model() {
    // Fetch all albums so we can display them in the universal sidebar
    return this.store.findAll('album');
  }
}
```

### **./frontend/photo-filter-frontend/app/routes/albums/album.js**
```
// frontend/photo-filter-frontend/app/helpers/eq.js

import { helper } from '@ember/component/helper';

export default helper(function eq([a, b]) {
  return a === b;
});
```

### **./frontend/photo-filter-frontend/app/helpers/type-of.js**
```
// frontend/photo-filter-frontend/app/routes/albums/album.js

import Route from '@ember/routing/route';
import { inject as service } from '@ember/service';

export default class AlbumsAlbumRoute extends Route {
  @service store;
  @service currentAlbum;

  // We add `dates` to the recognized queryParams
  queryParams = {
    sort: {},
    order: {},
    persons: {
      serialize(value) {
        return JSON.stringify(value);
      },
      deserialize(value) {
        if (typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch {
            return [];
          }
        }
        return value || [];
      },
    },
    dates: {
      serialize(value) {
        return JSON.stringify(value);
      },
      deserialize(value) {
        if (typeof value === 'string') {
          try {
            return JSON.parse(value);
          } catch {
            return [];
          }
        }
        return value || [];
      },
    },
  };

  async model(params) {
    const {
      album_id,
      sort = 'score.overall',
      order = 'desc',
      persons = [],
      dates = [],
    } = params;

    const album = await this.store.findRecord('album', album_id, {
      include: 'persons',
      reload: true,
    });

    const loadedPersons = album.persons;
    const allPersons = loadedPersons.map((p) => p.name);

    const allPhotos = await this.store.query('photo', { album_id });

    let scoreAttributes = [];
    if (allPhotos.meta?.scoreAttributes) {
      scoreAttributes = allPhotos.meta.scoreAttributes;
    } else if (allPhotos.length > 0 && allPhotos.firstObject.score) {
      scoreAttributes = Object.keys(allPhotos.firstObject.score);
    }

    // Sort persons by frequency
    const personCountMap = {};
    allPhotos.forEach((photo) => {
      photo.persons.forEach((p) => {
        personCountMap[p.name] = (personCountMap[p.name] || 0) + 1;
      });
    });
    const sortedAllPersons = allPersons.sort((a, b) => {
      const countA = personCountMap[a] || 0;
      const countB = personCountMap[b] || 0;
      if (countB !== countA) return countB - countA;
      return a.localeCompare(b);
    });

    this.currentAlbum.isAlbumRoute = true;
    this.currentAlbum.albumTitle = album.title;
    this.currentAlbum.scoreAttributes = scoreAttributes;
    this.currentAlbum.sortAttribute = sort;
    this.currentAlbum.sortOrder = order;

    const isDataReady = true;
    return {
      album,
      photos: allPhotos,
      albumUUID: allPhotos.meta?.albumUUID || album_id,
      sortAttribute: sort,
      sortOrder: order,
      scoreAttributes,
      persons: sortedAllPersons,
      selectedPersons: persons,
      selectedDates: dates,
      isDataReady,
    };
  }

  resetController(controller, isExiting) {
    super.resetController(...arguments);
    if (isExiting) {
      this.currentAlbum.isAlbumRoute = false;
      this.currentAlbum.albumTitle = null;
      this.currentAlbum.scoreAttributes = [];
      this.currentAlbum.sortAttribute = 'score.overall';
      this.currentAlbum.sortOrder = 'desc';
    }
  }
}
```

### **./frontend/photo-filter-frontend/app/helpers/eq.js**
```
import { helper } from '@ember/component/helper';

/**
 * A helper function that returns the JavaScript type
 * (as given by the built-in `typeof`) of the provided value.
 *
 * Usage in a template:
 *   {{#if (eq (type-of this.someValue) "object")}}
 *     <!-- do something if it's an object -->
 *   {{/if}}
 */
export default helper(function typeOf([value]) {
  return typeof value;
});
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
// frontend/photo-filter-frontend/app/helpers/eq.js

import { helper } from '@ember/component/helper';

export default helper(function eq([a, b]) {
  return a === b;
});
```

### **./frontend/photo-filter-frontend/app/helpers/type-of.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

/**
 * A helper function that returns the JavaScript type
 * (as given by the built-in `typeof`) of the provided value.
 *
 * Usage in a template:
 *   {{#if (eq (type-of this.someValue) "object")}}
 *     <!-- do something if it's an object -->
 *   {{/if}}
 */
export default helper(function typeOf([value]) {
  return typeof value;
});
```

### **./frontend/photo-filter-frontend/app/helpers/capitalize.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/contains.js**
```
import { helper } from '@ember/component/helper';

export default helper(function capitalize([str]) {
  if (typeof str !== 'string') return '';
  return str
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
});
```

### **./frontend/photo-filter-frontend/app/helpers/replace.js**
```
import { helper } from '@ember/component/helper';

export default helper(function contains([item, array]) {
  return array.includes(item);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import { helper } from '@ember/component/helper';

export default helper(function replace([str, find, replace]) {
  return str.replace(find, replace);
});
```

### **./frontend/photo-filter-frontend/app/helpers/contains.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import { helper } from '@ember/component/helper';

export default helper(function contains([item, array]) {
  return array.includes(item);
});
```

### **./frontend/photo-filter-frontend/app/helpers/get-nested-property.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/current-album.js**
```
import { helper } from '@ember/component/helper';

export default helper(function getNestedProperty([obj, propertyPath]) {
  return propertyPath
    .split('.')
    .reduce(
      (acc, part) => (acc && acc[part] !== undefined ? acc[part] : null),
      obj,
    );
});
```

### **./frontend/photo-filter-frontend/app/app.js**
```
import Service from '@ember/service';
import { tracked } from '@glimmer/tracking';

export default class CurrentAlbumService extends Service {
  @tracked isAlbumRoute = false;
  @tracked albumTitle = null;
  @tracked scoreAttributes = [];
  @tracked sortAttribute = 'score.overall';
  @tracked sortOrder = 'desc';
  @tracked persons = [];
}
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
import Application from '@ember/application';
import Resolver from 'ember-resolver';
import loadInitializers from 'ember-load-initializers';
import config from 'photo-filter-frontend/config/environment';

export default class App extends Application {
  modulePrefix = config.modulePrefix;
  podModulePrefix = config.podModulePrefix;
  Resolver = Resolver;
}

loadInitializers(App, config.modulePrefix);
```

### **./frontend/photo-filter-frontend/app/services/current-album.js**
```
// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
import Service from '@ember/service';
import { tracked } from '@glimmer/tracking';

export default class CurrentAlbumService extends Service {
  @tracked isAlbumRoute = false;
  @tracked albumTitle = null;
  @tracked scoreAttributes = [];
  @tracked sortAttribute = 'score.overall';
  @tracked sortOrder = 'desc';
  @tracked persons = [];
}
```

### **./frontend/photo-filter-frontend/app/services/store.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
```

// app/services/store.js

export { default } from 'ember-data/store';
```

### **./frontend/photo-filter-frontend/config/targets.js**
```
'use strict';

const browsers = [
  'last 1 Chrome versions',
  'last 1 Firefox versions',
  'last 1 Safari versions',
];

module.exports = {
  browsers,
};
### **./frontend/photo-filter-frontend/config/optional-features.json**
```
```

{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
### **./frontend/photo-filter-frontend/config/optional-features.json**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    historySupportMiddleware: true, // enable for ember-router-scroll
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {},
    },

    APP: {
      apiHost: 'http://localhost:3000',
    },

    // Add routerScroll configuration here
    routerScroll: {
      targetElement: '#main-content-area',
    },
  };

  if (environment === 'development') {
    // ...
  }

  if (environment === 'test') {
    ENV.locationType = 'none';
    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // ...
  }

  return ENV;
};
```

{
  "application-template-wrapper": false,
  "default-async-observers": true,
  "jquery-integration": false,
  "template-only-glimmer-components": true,
  "no-implicit-route-model": true
}
```

### **./frontend/photo-filter-frontend/config/environment.js**
```
'use strict';

module.exports = function (environment) {
  const ENV = {
    modulePrefix: 'photo-filter-frontend',
    environment,
    rootURL: '/',
    locationType: 'history',
    historySupportMiddleware: true, // enable for ember-router-scroll
    EmberENV: {
      EXTEND_PROTOTYPES: false,
      FEATURES: {},
    },

    APP: {
      apiHost: 'http://localhost:3000',
    },

    // Add routerScroll configuration here
    routerScroll: {
      targetElement: '#main-content-area',
    },
  };

  if (environment === 'development') {
    // ...
  }

  if (environment === 'test') {
    ENV.locationType = 'none';
    ENV.APP.rootElement = '#ember-testing';
    ENV.APP.autoboot = false;
  }

  if (environment === 'production') {
    // ...
  }

  return ENV;
};
```

### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": ["--ci-provider=github"]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
### **./frontend/photo-filter-frontend/config/ember-cli-update.json**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
{
  "schemaVersion": "1.0.0",
  "packages": [
    {
      "name": "ember-cli",
      "version": "5.12.0",
      "blueprints": [
        {
          "name": "app",
          "outputRepo": "https://github.com/ember-cli/ember-new-output",
          "codemodsSource": "ember-app-codemods-manifest@1",
          "isBaseBlueprint": true,
          "options": ["--ci-provider=github"]
        }
      ]
    }
  ]
}
```

### **./frontend/photo-filter-frontend/tests/unit/models/photo-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | photo', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('photo', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/models/album-test.js**
```
// tests/unit/routes/album-test.js

import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    // Correctly look up the nested route
    let route = this.owner.lookup('route:albums/album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { setupTest } from 'photo-filter-frontend/tests/helpers';
import { module, test } from 'qunit';

module('Unit | Model | album', function (hooks) {
  setupTest(hooks);

  // Replace this with your real tests.
  test('it exists', function (assert) {
    const store = this.owner.lookup('service:store');
    const model = store.createRecord('album', {});
    assert.ok(model, 'model exists');
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/album-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
// tests/unit/routes/album-test.js

import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | album', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    // Correctly look up the nested route
    let route = this.owner.lookup('route:albums/album');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/routes/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Route | albums', function (hooks) {
  setupTest(hooks);

  test('it exists', function (assert) {
    let route = this.owner.lookup('route:albums');
    assert.ok(route);
  });
});
```

### **./frontend/photo-filter-frontend/tests/unit/services/store-test.js**
```
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
import { module, test } from 'qunit';
import { setupTest } from 'photo-filter-frontend/tests/helpers';

module('Unit | Service | store', function (hooks) {
  setupTest(hooks);

  // TODO: Replace this with your real tests.
  test('it exists', function (assert) {
    let service = this.owner.lookup('service:store');
    assert.ok(service);
  });
});
```

### **./frontend/photo-filter-frontend/tests/test-helper.js**
```
// tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from 'photo-filter-frontend/tests/helpers';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('Visiting /albums shows the album list', async function (assert) {
    // 1. Go to /albums
    await visit('/albums');

    // 2. Confirm we landed on the correct route
    assert.strictEqual(currentURL(), '/albums', 'We are on the /albums route');

    // 3. Check that album links appear in the sidebar menu
    let albumLinks = findAll('.menu li a');
    assert.ok(
      albumLinks.length > 0,
      `Expected at least one album link in the sidebar, found ${albumLinks.length}`,
    );

    // Just to demonstrate how many albums we found
    console.log(`Found ${albumLinks.length} album link(s)`);
  });

  test('Clicking an album link transitions to that album’s route', async function (assert) {
    // 1. Visit /albums
    await visit('/albums');
    assert.strictEqual(
      currentURL(),
      '/albums',
      'We start on the /albums route',
    );

    // 2. Grab all the album links
    let albumLinks = findAll('.menu li a');
    assert.ok(albumLinks.length > 0, 'We have at least one album link');

    // 3. Click the first album link
    await click(albumLinks[0]);

    // 4. The current URL should now reflect that album’s route
    let url = currentURL();
    assert.ok(
      url.startsWith('/albums/'),
      'After clicking the first album link, we navigate to /albums/:album_id',
    );

    // 5. Verify that the photo grid or similar content is displayed
    // In your photo-grid.hbs, the root container is class="grid ..."
    // So let's confirm that .grid is in the DOM
    assert
      .dom('.grid')
      .exists('The photo-grid component (with class `.grid`) is displayed');

    // 6. Check for photo items
    // In your photo-grid.hbs, each item is inside a .card or .photo-item, so adjust as needed
    let photoCards = findAll('.card');
    assert.ok(photoCards.length > 0, 'We see at least one .card in the album');

    // 7. Confirm an image is displayed
    assert
      .dom('.card figure img')
      .exists('An image is rendered for each photo item');
  });
});
import Application from 'photo-filter-frontend/app';
import config from 'photo-filter-frontend/config/environment';
import * as QUnit from 'qunit';
import { setApplication } from '@ember/test-helpers';
import { setup } from 'qunit-dom';
import { start } from 'ember-qunit';

setApplication(Application.create(config.APP));

setup(QUnit.assert);

start();
```

### **./frontend/photo-filter-frontend/tests/acceptance/person-filtering-test.js**
```
```

### **./frontend/photo-filter-frontend/tests/acceptance/albums-test.js**
```
// tests/acceptance/person-filtering-test.js

import { module, test } from 'qunit';
import {
  visit,
  click,
  findAll,
  currentURL,
  settled,
} from '@ember/test-helpers';
import { setupApplicationTest } from 'photo-filter-frontend/tests/helpers';

module('Acceptance | Person Filtering', function (hooks) {
  setupApplicationTest(hooks);

  test('toggle multiple people in an album', async function (assert) {
    // 1. Go to /albums
    await visit('/albums');
    assert.strictEqual(currentURL(), '/albums', 'We are at the /albums route');

    // 2. Grab all album links
    const albumLinks = findAll('.menu li a');
    assert.ok(
      albumLinks.length > 0,
      'We have at least one album link in the sidebar',
    );

    // We'll iterate through each album link in sequence, click it, and see if we find person toggles.
    let foundPersonButtons = false;
    let clickedAlbumIndex = 0;

    for (let i = 0; i < albumLinks.length; i++) {
      // 3. Click this album link
      await click(albumLinks[i]);
      await settled(); // Wait for any async rendering/data

      // 4. Check if this album has .btn.btn-xs elements
      const personButtons = findAll('.btn.btn-xs');
      if (personButtons.length > 0) {
        foundPersonButtons = true;
        clickedAlbumIndex = i;
        break;
      } else {
        // If not found, navigate back to /albums and try the next link
        // (Or skip the "navigate back" step if your app can handle direct re-clicking)
        await visit('/albums');
      }
    }

    // Now, if foundPersonButtons is false, it means we never found an album with people.
    assert.ok(
      foundPersonButtons,
      'Expected to find at least one album that has person toggles',
    );
    if (!foundPersonButtons) {
      // If we truly never found any toggles, we can bail out:
      return;
    }

    // 5. We are now on an album route that does have person toggles
    let url = currentURL();
    assert.ok(
      url.startsWith('/albums/'),
      `Navigated to an album detail route (album index = ${clickedAlbumIndex})`,
    );

    // 6. Confirm we do see those toggles
    const personButtons = findAll('.btn.btn-xs');
    assert.ok(
      personButtons.length > 0,
      'Person toggles exist on the page for filtering',
    );

    // 7. Toggle the first person
    await click(personButtons[0]);

    // 8. Check that the URL now includes a query param for persons
    url = currentURL();
    assert.ok(
      url.includes('persons='),
      'URL now contains persons query param after toggling the first person',
    );

    // 9. Optionally toggle a second person if available
    if (personButtons.length > 1) {
      await click(personButtons[1]);
      url = currentURL();
      assert.ok(
        url.includes('%2C'),
        'Multiple persons are included in the query param (comma-encoded)',
      );
    }
  });
});
// tests/acceptance/albums-test.js

import { module, test } from 'qunit';
import { visit, click, findAll, currentURL } from '@ember/test-helpers';
import { setupApplicationTest } from 'photo-filter-frontend/tests/helpers';

module('Acceptance | albums', function (hooks) {
  setupApplicationTest(hooks);

  test('Visiting /albums shows the album list', async function (assert) {
    // 1. Go to /albums
    await visit('/albums');

    // 2. Confirm we landed on the correct route
    assert.strictEqual(currentURL(), '/albums', 'We are on the /albums route');

    // 3. Check that album links appear in the sidebar menu
    let albumLinks = findAll('.menu li a');
    assert.ok(
      albumLinks.length > 0,
      `Expected at least one album link in the sidebar, found ${albumLinks.length}`,
    );

    // Just to demonstrate how many albums we found
    console.log(`Found ${albumLinks.length} album link(s)`);
  });

  test('Clicking an album link transitions to that album’s route', async function (assert) {
    // 1. Visit /albums
    await visit('/albums');
    assert.strictEqual(
      currentURL(),
      '/albums',
      'We start on the /albums route',
    );

    // 2. Grab all the album links
    let albumLinks = findAll('.menu li a');
    assert.ok(albumLinks.length > 0, 'We have at least one album link');

    // 3. Click the first album link
    await click(albumLinks[0]);

    // 4. The current URL should now reflect that album’s route
    let url = currentURL();
    assert.ok(
      url.startsWith('/albums/'),
      'After clicking the first album link, we navigate to /albums/:album_id',
    );

    // 5. Verify that the photo grid or similar content is displayed
    // In your photo-grid.hbs, the root container is class="grid ..."
    // So let's confirm that .grid is in the DOM
    assert
      .dom('.grid')
      .exists('The photo-grid component (with class `.grid`) is displayed');

    // 6. Check for photo items
    // In your photo-grid.hbs, each item is inside a .card or .photo-item, so adjust as needed
    let photoCards = findAll('.card');
    assert.ok(photoCards.length > 0, 'We see at least one .card in the album');

    // 7. Confirm an image is displayed
    assert
      .dom('.card figure img')
      .exists('An image is rendered for each photo item');
  });
});
```
```


### **./frontend/photo-filter-frontend/tests/helpers.js**
### **./frontend/photo-filter-frontend/tests/acceptance/person-filtering-test.js**
```
```
// tests/helpers.js

import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file provides wrappers around ember-qunit's test setup functions.
// Additional per-test-type setup could be added here.

export function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // For example:
  // hooks.beforeEach(async function () {
  //   // e.g., authenticateSession(); // for ember-simple-auth
  // });
}

export function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);
}

export function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);
}
// tests/acceptance/person-filtering-test.js

import { module, test } from 'qunit';
import {
  visit,
  click,
  findAll,
  currentURL,
  settled,
} from '@ember/test-helpers';
import { setupApplicationTest } from 'photo-filter-frontend/tests/helpers';

module('Acceptance | Person Filtering', function (hooks) {
  setupApplicationTest(hooks);

  test('toggle multiple people in an album', async function (assert) {
    // 1. Go to /albums
    await visit('/albums');
    assert.strictEqual(currentURL(), '/albums', 'We are at the /albums route');

    // 2. Grab all album links
    const albumLinks = findAll('.menu li a');
    assert.ok(
      albumLinks.length > 0,
      'We have at least one album link in the sidebar',
    );

    // We'll iterate through each album link in sequence, click it, and see if we find person toggles.
    let foundPersonButtons = false;
    let clickedAlbumIndex = 0;

    for (let i = 0; i < albumLinks.length; i++) {
      // 3. Click this album link
      await click(albumLinks[i]);
      await settled(); // Wait for any async rendering/data

      // 4. Check if this album has .btn.btn-xs elements
      const personButtons = findAll('.btn.btn-xs');
      if (personButtons.length > 0) {
        foundPersonButtons = true;
        clickedAlbumIndex = i;
        break;
      } else {
        // If not found, navigate back to /albums and try the next link
        // (Or skip the "navigate back" step if your app can handle direct re-clicking)
        await visit('/albums');
      }
    }

    // Now, if foundPersonButtons is false, it means we never found an album with people.
    assert.ok(
      foundPersonButtons,
      'Expected to find at least one album that has person toggles',
    );
    if (!foundPersonButtons) {
      // If we truly never found any toggles, we can bail out:
      return;
    }

    // 5. We are now on an album route that does have person toggles
    let url = currentURL();
    assert.ok(
      url.startsWith('/albums/'),
      `Navigated to an album detail route (album index = ${clickedAlbumIndex})`,
    );

    // 6. Confirm we do see those toggles
    const personButtons = findAll('.btn.btn-xs');
    assert.ok(
      personButtons.length > 0,
      'Person toggles exist on the page for filtering',
    );

    // 7. Toggle the first person
    await click(personButtons[0]);

    // 8. Check that the URL now includes a query param for persons
    url = currentURL();
    assert.ok(
      url.includes('persons='),
      'URL now contains persons query param after toggling the first person',
    );

    // 9. Optionally toggle a second person if available
    if (personButtons.length > 1) {
      await click(personButtons[1]);
      url = currentURL();
      assert.ok(
        url.includes('%2C'),
        'Multiple persons are included in the query param (comma-encoded)',
      );
    }
  });
});
```

### **./frontend/photo-filter-frontend/README.md**
```
```

### **./frontend/photo-filter-frontend/tests/helpers.js**
```
// tests/helpers.js

import {
  setupApplicationTest as upstreamSetupApplicationTest,
  setupRenderingTest as upstreamSetupRenderingTest,
  setupTest as upstreamSetupTest,
} from 'ember-qunit';

// This file provides wrappers around ember-qunit's test setup functions.
// Additional per-test-type setup could be added here.

export function setupApplicationTest(hooks, options) {
  upstreamSetupApplicationTest(hooks, options);

  // For example:
  // hooks.beforeEach(async function () {
  //   // e.g., authenticateSession(); // for ember-simple-auth
  // });
}

export function setupRenderingTest(hooks, options) {
  upstreamSetupRenderingTest(hooks, options);
}

export function setupTest(hooks, options) {
  upstreamSetupTest(hooks, options);
}
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
```

### **./frontend/photo-filter-frontend/README.md**
```
```

### **./frontend/photo-filter-frontend/.gitignore**
```
# photo-filter-frontend

This README outlines the details of collaborating on this Ember application.
A short introduction of this app could easily go here.

## Prerequisites

You will need the following things properly installed on your computer.

- [Git](https://git-scm.com/)
- [Node.js](https://nodejs.org/) (with npm)
- [Ember CLI](https://cli.emberjs.com/release/)
- [Google Chrome](https://google.com/chrome/)

## Installation

- `git clone <repository-url>` this repository
- `cd photo-filter-frontend`
- `npm install`

## Running / Development

- `npm run start`
- Visit your app at [http://localhost:4200](http://localhost:4200).
- Visit your tests at [http://localhost:4200/tests](http://localhost:4200/tests).

### Code Generators

Make use of the many generators for code, try `ember help generate` for more details

### Running Tests

- `npm run test`
- `npm run test:ember -- --server`

### Linting

- `npm run lint`
- `npm run lint:fix`

### Building

- `npm exec ember build` (development)
- `npm run build` (production)

### Deploying

Specify what it takes to deploy your app.

## Further Reading / Useful Links

- [ember.js](https://emberjs.com/)
- [ember-cli](https://cli.emberjs.com/release/)
- Development Browser Extensions
  - [ember inspector for chrome](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi)
  - [ember inspector for firefox](https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/)
# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/.gitignore**
```
```

# compiled output
/dist/
/declarations/

# dependencies
/node_modules/

# misc
/.env*
/.pnp*
/.eslintcache
/coverage/
/npm-debug.log*
/testem.log
/yarn-error.log

# ember-try
/.node_modules.ember-try/
/npm-shrinkwrap.json.ember-try
/package.json.ember-try
/package-lock.json.ember-try
/yarn.lock.ember-try

# broccoli-debug
/DEBUG/
```

### **./frontend/photo-filter-frontend/package.json**
```json
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Photo Filter Frontend",
  "scripts": {
    "build": "ember build --environment=production",
    "start": "ember serve",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "dependencies": {
...
### **./frontend/photo-filter-frontend/package.json**
```
```json

### **./frontend/photo-filter-frontend/.prettierrc.js**
```
{
  "name": "photo-filter-frontend",
  "version": "0.0.0",
  "private": true,
  "description": "Photo Filter Frontend",
  "scripts": {
    "build": "ember build --environment=production",
    "start": "ember serve",
    "lint": "concurrently \"npm:lint:*(!fix)\" --names \"lint:\"",
    "lint:css": "stylelint \"**/*.css\"",
    "lint:css:fix": "concurrently \"npm:lint:css -- --fix\"",
    "lint:fix": "concurrently \"npm:lint:*:fix\" --names \"fix:\"",
    "lint:hbs": "ember-template-lint .",
    "lint:hbs:fix": "ember-template-lint . --fix",
    "lint:js": "eslint . --cache",
    "lint:js:fix": "eslint . --fix",
    "test": "concurrently \"npm:lint\" \"npm:test:*\" --names \"lint,test:\"",
    "test:ember": "ember test"
  },
  "dependencies": {
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
...
```
```


### **./frontend/photo-filter-frontend/.eslintrc.js**
### **./frontend/photo-filter-frontend/.prettierrc.js**
```
```
'use strict';

module.exports = {
  overrides: [
    {
      files: '*.{js,ts}',
      options: {
        singleQuote: true,
      },
    },
  ],
};
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
```
```


### **./frontend/photo-filter-frontend/.eslintrc.js**
```
### **./frontend/photo-filter-frontend/testem.js**
```
'use strict';

module.exports = {
  root: true,
  parser: '@babel/eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    requireConfigFile: false,
    babelOptions: {
      plugins: [
        ['@babel/plugin-proposal-decorators', { decoratorsBeforeExport: true }],
      ],
    },
  },
  plugins: ['ember'],
  extends: [
    'eslint:recommended',
    'plugin:ember/recommended',
    'plugin:prettier/recommended',
  ],
  env: {
    browser: true,
  },
  rules: {},
  overrides: [
    // node files
    {
      files: [
        './.eslintrc.js',
        './.prettierrc.js',
        './.stylelintrc.js',
        './.template-lintrc.js',
        './ember-cli-build.js',
        './testem.js',
        './blueprints/*/index.js',
        './config/**/*.js',
        './lib/*/index.js',
        './server/**/*.js',
      ],
      parserOptions: {
        sourceType: 'script',
      },
      env: {
        browser: false,
        node: true,
      },
      extends: ['plugin:n/recommended'],
    },
    {
      // test files
      files: ['tests/**/*-test.{js,ts}'],
      extends: ['plugin:qunit/recommended'],
    },
  ],
};
'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/testem.js**
```
```

'use strict';

module.exports = {
  test_page: 'tests/index.html?hidepassed',
  disable_watching: true,
  launch_in_ci: ['Chrome'],
  launch_in_dev: ['Chrome'],
  browser_start_timeout: 120,
  browser_args: {
    Chrome: {
      ci: [
        // --no-sandbox is needed when running Chrome inside a container
        process.env.CI ? '--no-sandbox' : null,
        '--headless',
        '--disable-dev-shm-usage',
        '--disable-software-rasterizer',
        '--mute-audio',
        '--remote-debugging-port=0',
        '--window-size=1440,900',
      ].filter(Boolean),
    },
  },
};
```

### **./frontend/photo-filter-frontend/tsconfig.json**
```
{
  "compilerOptions": {
    "target": "es2020",
    "allowJs": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": true,
    "noFallthroughCasesInSwitch": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noEmitOnError": true,
    "noEmit": true,
    "inlineSourceMap": true,
    "inlineSources": true,
    "baseUrl": ".",
    "module": "es6",
    "experimentalDecorators": true,
    "paths": {
      "photo-filter-frontend/tests/*": [
        "tests/*"
      ],
      "photo-filter-frontend/*": [
        "app/*"
      ],
      "*": [
        "types/*"
      ]
    }
  },
  "include": [
    "app/**/*",
    "tests/**/*",
    "types/**/*"
  ]
}
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
### **./frontend/photo-filter-frontend/tsconfig.json**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
{
  "compilerOptions": {
    "target": "es2020",
    "allowJs": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": true,
    "noFallthroughCasesInSwitch": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noEmitOnError": true,
    "noEmit": true,
    "inlineSourceMap": true,
    "inlineSources": true,
    "baseUrl": ".",
    "module": "es6",
    "experimentalDecorators": true,
    "paths": {
      "photo-filter-frontend/tests/*": [
        "tests/*"
      ],
      "photo-filter-frontend/*": [
        "app/*"
      ],
      "*": [
        "types/*"
      ]
    }
  },
  "include": [
    "app/**/*",
    "tests/**/*",
    "types/**/*"
  ]
}
```

### **./frontend/photo-filter-frontend/postcss.config.js**
```
```

### **./frontend/photo-filter-frontend/.template-lintrc.js**
```
'use strict';

module.exports = {
  extends: 'recommended',
};
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

### **./frontend/photo-filter-frontend/postcss.config.js**
```
```

## Time Index from /api/time-index

Fetching http://localhost:3000/api/time-index ...

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

## Time Index from /api/time-index

Fetching http://localhost:3000/api/time-index ...

{"years":[{"year":2019,"months":[{"month":11,"days":[29]}]},{"year":2022,"months":[{"month":8,"days":[30]},{"month":12,"days":[1]}]},{"year":2023,"months":[{"month":1,"days":[7]},{"month":12,"days":[30]}]},{"year":2024,"months":[{"month":4,"days":[25]},{"month":6,"days":[4]}]},{"year":2025,"months":[{"month":3,"days":[30]},{"month":4,"days":[2,4,5,6,8,9,10,11,13,14,15,17,18,19,22,23,24,25,26,28,29,30]},{"month":5,"days":[1,3,4,5,7,8,9,10,12,13,14,15,16,17,22,23,25,26,27,28,29,30,31]},{"month":6,"days":[1,2,3,4,5,6,7,8,9,10,12,13,14,15,19]}]}]}
---

## Photos.json Summaries in ./backend/data/albums

{"years":[{"year":2019,"months":[{"month":11,"days":[29]}]},{"year":2022,"months":[{"month":8,"days":[30]},{"month":12,"days":[1]}]},{"year":2023,"months":[{"month":1,"days":[7]},{"month":12,"days":[30]}]},{"year":2024,"months":[{"month":4,"days":[25]},{"month":6,"days":[4]}]},{"year":2025,"months":[{"month":3,"days":[30]},{"month":4,"days":[2,4,5,6,8,9,10,11,13,14,15,17,18,19,22,23,24,25,26,28,29,30]},{"month":5,"days":[1,3,4,5,7,8,9,10,12,13,14,15,16,17,22,23,25,26,27,28,29,30,31]},{"month":6,"days":[1,2,3,4,5,6,7,8,9,10,12,13,14,15,19]}]}]}
---

## Photos.json Summaries in ./backend/data/albums

### Album UUID: 240AEA0E-D789-44BB-9BCF-AFCCC122A4EA
Location: ./backend/data/albums/240AEA0E-D789-44BB-9BCF-AFCCC122A4EA/photos.json
Photo Count: 1402
Earliest Date: 2025-06-06 16:33:02-05:00
Latest Date: 2025-06-06 19:22:20-05:00

### Album UUID: 240AEA0E-D789-44BB-9BCF-AFCCC122A4EA
Location: ./backend/data/albums/240AEA0E-D789-44BB-9BCF-AFCCC122A4EA/photos.json
Photo Count: 1402
Earliest Date: 2025-06-06 16:33:02-05:00
Latest Date: 2025-06-06 19:22:20-05:00

### Album UUID: 0EB23188-CA33-4FDA-BA27-A3B290466224
Location: ./backend/data/albums/0EB23188-CA33-4FDA-BA27-A3B290466224/photos.json
Photo Count: 13242
Earliest Date: 2025-05-30 08:52:35.160000-06:00
Latest Date: 2025-06-10 11:25:17-04:00

### Album UUID: B8F95C71-AF41-47E2-95F5-635AD81101E4
Location: ./backend/data/albums/B8F95C71-AF41-47E2-95F5-635AD81101E4/photos.json
Photo Count: 1724
Earliest Date: 2025-06-15 13:31:51-04:00
Latest Date: 2025-06-19 20:58:23-04:00

### Album UUID: 13F82066-89B7-44D1-B42E-C6D139EDB3EA
Location: ./backend/data/albums/13F82066-89B7-44D1-B42E-C6D139EDB3EA/photos.json
Photo Count: 15
Earliest Date: 2019-11-29 11:22:40-05:00
Latest Date: 2024-06-04 17:52:13-04:00

### Album UUID: 0EB23188-CA33-4FDA-BA27-A3B290466224
Location: ./backend/data/albums/0EB23188-CA33-4FDA-BA27-A3B290466224/photos.json
Photo Count: 13242
Earliest Date: 2025-05-30 08:52:35.160000-06:00
Latest Date: 2025-06-10 11:25:17-04:00

### Album UUID: B8F95C71-AF41-47E2-95F5-635AD81101E4
Location: ./backend/data/albums/B8F95C71-AF41-47E2-95F5-635AD81101E4/photos.json
Photo Count: 1724
Earliest Date: 2025-06-15 13:31:51-04:00
Latest Date: 2025-06-19 20:58:23-04:00

### Album UUID: 13F82066-89B7-44D1-B42E-C6D139EDB3EA
Location: ./backend/data/albums/13F82066-89B7-44D1-B42E-C6D139EDB3EA/photos.json
Photo Count: 15
Earliest Date: 2019-11-29 11:22:40-05:00
Latest Date: 2024-06-04 17:52:13-04:00

### Album UUID: A6B54487-D9FC-4F22-981D-3B521EBE2B67
Location: ./backend/data/albums/A6B54487-D9FC-4F22-981D-3B521EBE2B67/photos.json
Photo Count: 48418
Earliest Date: 2025-03-30 17:12:39-04:00
Latest Date: 2025-06-19 20:58:23-04:00

### Album UUID: A6B54487-D9FC-4F22-981D-3B521EBE2B67
Location: ./backend/data/albums/A6B54487-D9FC-4F22-981D-3B521EBE2B67/photos.json
Photo Count: 48418
Earliest Date: 2025-03-30 17:12:39-04:00
Latest Date: 2025-06-19 20:58:23-04:00

